# Исправление критической проблемы #5: Rate Limiting, валидация входных данных и улучшение обработки ошибок

**Дата:** 2025-01-XX  
**Статус:** ✅ Выполнено

## Проблемы

1. **Отсутствие rate limiting** — сервер уязвим к DDoS атакам и брутфорсу паролей
2. **Отсутствие валидации входных данных** — нет проверки длины, типов и формата данных
3. **Уязвимость к DoS через JSON** — нет защиты от больших или циклических JSON объектов
4. **Раскрытие деталей ошибок** — в продакшене показываются детальные сообщения об ошибках

## Решение

### 1. Реализован Rate Limiting

Добавлена собственная реализация rate limiting без внешних зависимостей:

#### Функции:
- `rateLimit(maxRequests, windowMs)` — middleware для ограничения запросов
- `cleanRateLimitStore()` — автоматическая очистка старых записей
- Хранение в памяти с автоматической очисткой каждые 5 минут

#### Настройки:
- **Общий лимит**: 100 запросов за 15 минут для всех API эндпоинтов
- **Строгий лимит для авторизации**: 5 попыток за 15 минут для `/api/auth`
- **Определение IP**: учитывает прокси (`x-forwarded-for`)

#### Применение:
```javascript
// Общий rate limiting для всех API
app.use('/api/', rateLimit(RATE_LIMIT_MAX_REQUESTS));

// Строгий rate limiting для авторизации
app.post('/api/auth', rateLimit(RATE_LIMIT_AUTH_MAX, 15 * 60 * 1000), ...);
```

### 2. Добавлена валидация входных данных

Созданы функции валидации для всех типов входных данных:

#### Функции валидации:

**`validateString(value, fieldName, minLength, maxLength)`**
- Проверка типа (должно быть строкой)
- Проверка минимальной и максимальной длины
- Автоматический trim

**`validateCompanyId(id)`**
- Проверка формата (только латинские буквы, цифры, дефисы, подчеркивания)
- Проверка максимальной длины (100 символов)
- Использование `isValidCompanyId()`

**`validateLogin(login)`**
- Проверка формата (латинские буквы, цифры, дефисы, подчеркивания, точки)
- Длина от 1 до 50 символов

**`validatePassword(password)`**
- Минимум 6 символов
- Максимум 200 символов

**`validateRole(role)`**
- Только 'admin' или 'user'

**`validateArray(value, fieldName, maxLength)`**
- Проверка типа (должно быть массивом)
- Ограничение максимального количества элементов

#### Применение валидации:

**Создание компании:**
```javascript
const idValidation = validateCompanyId(id);
const nameValidation = validateString(name, 'Название компании', 1, 200);
```

**Создание пользователя:**
```javascript
const nameValidation = validateString(name, 'Имя пользователя', 1, 100);
const loginValidation = validateLogin(login);
const passwordValidation = validatePassword(password);
const roleValidation = validateRole(role || 'user');
const companiesValidation = validateArray(companies || [], 'Компании', 100);
```

### 3. Защита от DoS через JSON

Создана функция `safeJsonParse()` для безопасного парсинга JSON:

#### Функциональность:
- Проверка типа (должно быть строкой)
- Ограничение размера (по умолчанию 10MB)
- Проверка на циклические ссылки через `JSON.stringify()`
- Детальные сообщения об ошибках

#### Применение:
```javascript
// Вместо JSON.parse(raw)
const users = safeJsonParse(raw);
```

**Заменено в критичных местах:**
- `requireAuth` — загрузка пользователей
- `/api/companies` — загрузка компаний
- `/api/users` — загрузка пользователей
- `/api/auth` — проверка авторизации

### 4. Улучшена обработка ошибок

#### Глобальный обработчик ошибок:
```javascript
app.use((err, req, res, next) => {
  // В продакшене скрываем детали
  const isProduction = process.env.NODE_ENV === 'production';
  const errorMessage = isProduction 
    ? 'Внутренняя ошибка сервера' 
    : err.message;
  
  res.status(err.status || 500).json({ 
    ok: false, 
    error: errorMessage,
    ...(isProduction ? {} : { details: err.message })
  });
});
```

#### Особенности:
- В продакшене (`NODE_ENV=production`) детали ошибок скрыты
- В режиме разработки показываются детали для отладки
- Логирование всех ошибок на сервере для диагностики

## Безопасность

✅ Rate limiting защищает от DDoS и брутфорса  
✅ Валидация входных данных предотвращает некорректные данные  
✅ Защита от DoS через JSON (большие объекты, циклические ссылки)  
✅ Скрытие деталей ошибок в продакшене  
✅ Автоматическая очистка rate limit хранилища  

## Обратная совместимость

- ✅ Все существующие запросы продолжают работать
- ✅ Валидация применяется только к новым/обновленным эндпоинтам
- ✅ Старые данные не требуют миграции

## Тестирование

### Проверка rate limiting:

1. **Общий лимит (100 запросов):**
   ```bash
   for i in {1..101}; do curl http://localhost:3001/api/companies; done
   # 101-й запрос должен вернуть 429
   ```

2. **Лимит авторизации (5 попыток):**
   ```bash
   for i in {1..6}; do 
     curl -X POST http://localhost:3001/api/auth \
       -H "Content-Type: application/json" \
       -d '{"login":"test","password":"wrong"}'
   done
   # 6-я попытка должна вернуть 429
   ```

### Проверка валидации:

1. **Создание компании с неверным ID:**
   ```bash
   curl -X POST http://localhost:3001/api/companies \
     -H "Content-Type: application/json" \
     -H "X-User-Login: Driga_VA" \
     -d '{"id":"test@123","name":"Test"}'
   # Должна вернуть ошибку валидации
   ```

2. **Создание пользователя с коротким паролем:**
   ```bash
   curl -X POST http://localhost:3001/api/users \
     -H "Content-Type: application/json" \
     -H "X-User-Login: Driga_VA" \
     -d '{"name":"Test","login":"test","password":"123","role":"user"}'
   # Должна вернуть ошибку валидации пароля
   ```

## Следующие шаги

1. ✅ Заменить все оставшиеся `JSON.parse()` на `safeJsonParse()` (выполнено - 33 использования заменены)
2. ⏳ Применить валидацию к остальным эндпоинтам (обновление компаний, пользователей)
3. ⏳ Добавить валидацию для данных графика Ганта (задачи, даты)
4. ⏳ Рассмотреть добавление CSRF защиты для дополнительной безопасности

---

**Важно:** Rate limiting и валидация критичны для безопасности. Все новые эндпоинты должны использовать эти функции.

