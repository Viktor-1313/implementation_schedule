<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>График внедрения и обучения системы ICONA</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <!-- html2pdf.js загружается асинхронно только при необходимости (при экспорте в PDF) -->
    <!-- Локальная копия XLSX для корпоративной сети (без зависимости от CDN).
         Файл xlsx.min.js должен лежать рядом с implementation_schedule.html или в указанной папке. -->
    <script src="xlsx.min.js"></script>
    <style>
        :root {
            --color-primary: #1e88e5;
            --color-primary-hover: #1565c0;
            --color-bg: #f5f5f5;
            --color-surface: #ffffff;
            --color-text: #1a1a1a;
            --color-text-secondary: #666666;
            --color-border: #e0e0e0;
            --color-success: #4caf50;
            --color-warning: #ff9800;
            --color-error: #f44336;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
            opacity: 0;
            animation: fadeInFromFog 1.5s ease-out forwards;
        }

        /* Анимация появления из тумана */
        @keyframes fadeInFromFog {
            0% {
                opacity: 0;
                filter: blur(30px);
                transform: scale(0.95);
            }
            50% {
                opacity: 0.3;
                filter: blur(15px);
                transform: scale(0.98);
            }
            100% {
                opacity: 1;
                filter: blur(0px);
                transform: scale(1);
            }
        }

        /* Эффект тумана при появлении */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 50% 50%, rgba(200, 230, 255, 0.4) 0%, transparent 60%),
                radial-gradient(circle at 30% 30%, rgba(173, 216, 230, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(135, 206, 250, 0.3) 0%, transparent 50%);
            animation: fogDissolve 1.5s ease-out forwards;
            z-index: 9999;
            pointer-events: none;
        }

        @keyframes fogDissolve {
            0% {
                opacity: 1;
                transform: scale(1.2);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
            100% {
                opacity: 0;
                transform: scale(1);
            }
        }

        .container {
            /* Было 1400px — увеличили примерно на 400px по вашей просьбе */
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            animation: containerAppear 1.5s ease-out 0.3s both;
        }

        @keyframes containerAppear {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        header {
            position: relative; /* Для правильного позиционирования кнопок */
            background: var(--color-surface);
            padding: 30px 20px;
            border-bottom: 2px solid var(--color-primary);
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            position: relative;
        }

        /* Кнопка профиля в правом верхнем углу */
        .profile-btn {
            position: absolute !important;
            top: 30px !important;
            right: 30px !important;
            left: auto !important;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            border: 2px solid #2c2c2c;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            z-index: 1000;
            overflow: visible;
        }

        /* Анимация вращения золотой точки по кругу по часовой стрелке */
        @keyframes rotateDot {
            0% {
                transform: translateX(-50%) rotate(0deg) translateY(20px) rotate(0deg);
            }
            100% {
                transform: translateX(-50%) rotate(360deg) translateY(20px) rotate(-360deg);
            }
        }

        /* Золотая точка, вращающаяся по кругу при наведении */
        .profile-btn::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            opacity: 0;
            z-index: 1001;
            transition: opacity 0.3s ease;
        }

        /* При наведении показываем золотую точку и запускаем анимацию */
        .profile-btn:hover::after {
            opacity: 1;
            animation: rotateDot 2s linear infinite;
        }

        .profile-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(66, 165, 245, 0.4);
        }

        /* Иконка профиля (голова) */
        .profile-btn .profile-icon-head {
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 8px;
            z-index: 1002;
        }

        /* Иконка профиля (плечи) */
        .profile-btn .profile-icon-shoulders {
            position: absolute;
            width: 22px;
            height: 12px;
            background: white;
            border-radius: 12px 12px 0 0;
            bottom: 6px;
            z-index: 1002;
        }

        /* Подсказка для кнопки профиля */
        .profile-btn[data-tooltip] {
            position: relative;
        }

        .profile-btn[data-tooltip]:hover .profile-tooltip {
            opacity: 1;
            transition-delay: 1s;
        }

        .profile-tooltip {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: #000000 !important;
            color: white !important;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.75rem;
            white-space: normal;
            min-width: max-content;
            max-width: 200px;
            word-wrap: break-word;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10001;
            width: auto;
            height: auto;
        }

        /* Кнопка выхода к выбору компаний (скрыта, используется новая кнопка ниже) */
        .companies-btn {
            display: none !important;
        }

        /* Золотая точка, вращающаяся по кругу для кнопки компаний при наведении */
        .companies-btn::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            opacity: 0;
            z-index: 1001;
            transition: opacity 0.3s ease;
        }

        /* При наведении показываем золотую точку и запускаем анимацию */
        .companies-btn:hover::after {
            opacity: 1;
            animation: rotateDot 2s linear infinite;
        }

        .companies-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        /* Иконка квадрата с точкой для кнопки компаний */
        .companies-btn .companies-icon {
            width: 18px;
            height: 18px;
            border: 2px solid white;
            border-radius: 4px;
            position: absolute;
            z-index: 1002;
        }

        /* Точка внутри квадрата для кнопки компаний */
        .companies-btn .companies-icon::before {
            content: '';
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 4px;
            left: 4px;
        }

        /* Подсказка для кнопки компаний */
        .companies-btn {
            position: relative;
        }
        
        .companies-btn:hover .companies-tooltip {
            opacity: 1 !important;
            visibility: visible !important;
            transition-delay: 1s;
        }

        .companies-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            border-radius: 8px;
            background: #000000;
            color: #ffffff;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 10001;
        }

        /* Точка внутри квадрата */
        .companies-btn > span {
            content: '';
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 4px;
            left: 4px;
            z-index: 2;
        }

        /* Кнопка выхода */
        .logout-btn {
            position: absolute;
            top: 80px;
            right: 30px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            border: 2px solid #2c2c2c;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            z-index: 1000;
            overflow: visible;
        }

        /* Золотая точка, вращающаяся по кругу для кнопки выхода при наведении */
        .logout-btn::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            opacity: 0;
            z-index: 1001;
            transition: opacity 0.3s ease;
        }

        /* При наведении показываем золотую точку и запускаем анимацию */
        .logout-btn:hover::after {
            opacity: 1;
            animation: rotateDot 2s linear infinite;
        }

        .logout-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
        }

        /* Иконка выхода (стрелка влево) */
        .logout-btn .logout-icon {
            width: 12px;
            height: 12px;
            border-left: 3px solid white;
            border-top: 3px solid white;
            transform: rotate(-45deg) translateX(2px);
            z-index: 1002;
            position: absolute;
        }

        /* Подсказка для кнопки выхода */
        .logout-btn[data-tooltip]:hover .logout-tooltip {
            opacity: 1;
            transform: translate(-50%, 6px);
            transition-delay: 1s;
        }

        .logout-tooltip {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, 0);
            padding: 8px 12px;
            border-radius: 8px;
            background: #000000 !important;
            color: #fff !important;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top center;
            margin-top: 8px;
            z-index: 10001;
        }

        /* Новая кнопка компаний под кнопкой выхода */
        .companies-bottom-btn {
            position: absolute;
            top: 130px;
            right: 30px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%);
            border: 2px solid #2c2c2c;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            z-index: 1000;
            overflow: visible;
        }

        /* Золотая точка, вращающаяся по кругу для нижней кнопки компаний */
        .companies-bottom-btn::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -20px);
            opacity: 0;
            z-index: 1001;
            transition: opacity 0.3s ease;
        }

        .companies-bottom-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .companies-bottom-btn:hover::after {
            opacity: 1;
            animation: rotateDot 2s linear infinite;
        }

        /* Иконка квадрата с точкой для новой кнопки компаний */
        .companies-bottom-icon {
            width: 18px;
            height: 18px;
            border: 2px solid white;
            border-radius: 4px;
            position: relative;
        }

        .companies-bottom-icon::before {
            content: '';
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 4px;
            left: 4px;
        }

        /* Подсказка для новой кнопки компаний */
        .companies-bottom-btn:hover .companies-bottom-tooltip {
            opacity: 1 !important;
            visibility: visible !important;
            transition-delay: 1s;
        }

        .companies-bottom-tooltip {
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            border-radius: 8px;
            background: #000000;
            color: #ffffff;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 10001;
        }

        /* Модальное окно редактирования профиля */
        .profile-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease;
        }

        .profile-modal.show {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 10vh; /* Поднимаем окно выше */
        }

        @media (max-width: 768px) {
            .profile-modal.show {
                padding-top: 5vh;
                align-items: center;
            }
        }

        @media (max-width: 480px) {
            .profile-modal.show {
                padding-top: 2vh;
                padding-left: 5px;
                padding-right: 5px;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .profile-modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
            position: relative;
            margin-top: 10vh; /* Поднимаем окно выше */
            cursor: default;
        }

        .profile-modal-header {
            cursor: move;
            user-select: none;
        }

        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .profile-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .profile-modal-header h2 {
            color: #1565c0;
            font-size: 1.8rem;
            font-weight: 700;
        }

        .profile-modal-close {
            background: none;
            border: none;
            font-size: 2rem;
            color: #999;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .profile-modal-close:hover {
            background: #f5f5f5;
            color: #333;
        }

        .profile-form-group {
            margin-bottom: 25px;
        }

        .profile-form-group label {
            display: block;
            color: #1565c0;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .profile-form-group input {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid rgba(100, 181, 246, 0.3);
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
            color: #1565c0;
        }

        .profile-form-group input:focus {
            outline: none;
            border-color: #42a5f5;
            box-shadow: 0 0 0 4px rgba(66, 165, 245, 0.15);
            background: white;
        }

        .profile-form-group input::placeholder {
            color: #90caf9;
        }

        .profile-form-actions {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .profile-btn-save {
            flex: 1;
            padding: 14px 24px;
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.3);
        }

        .profile-btn-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(33, 150, 243, 0.4);
        }

        .profile-btn-cancel {
            flex: 1;
            padding: 14px 24px;
            background: #e0e0e0;
            color: #666;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .profile-btn-cancel:hover {
            background: #d0d0d0;
        }

        .profile-message {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            font-size: 0.9rem;
        }

        .profile-message.success {
            background: rgba(129, 199, 132, 0.2);
            color: #2e7d32;
            border: 1px solid rgba(129, 199, 132, 0.5);
        }

        .profile-message.error {
            background: rgba(239, 83, 80, 0.2);
            color: #c62828;
            border: 1px solid rgba(239, 83, 80, 0.5);
        }

        .profile-message.show {
            display: block;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            color: var(--color-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-subtitle {
            color: var(--color-text-secondary);
            font-size: 14px;
        }

        .header-icon {
            width: 26px;
            height: 26px;
            border-radius: 6px;
            background: radial-gradient(circle at 20% 20%, #ffffff 0, #ffffff 10%, #bbdefb 30%, #1e88e5 80%);
            box-shadow: 0 0 0 2px rgba(30, 136, 229, 0.3), 0 4px 8px rgba(0, 0, 0, 0.18);
            position: relative;
        }

        .header-icon::before {
            content: '';
            position: absolute;
            inset: 6px;
            border-radius: 4px;
            border: 2px solid #ffffff;
            box-shadow: inset 0 0 0 1px rgba(21, 101, 192, 0.6);
        }

        .header-icon::after {
            content: '';
            position: absolute;
            left: 6px;
            right: 6px;
            bottom: 7px;
            height: 2px;
            background: rgba(255, 255, 255, 0.9);
        }

        .company-info {
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .company-logo-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            position: relative;
        }

        .company-logo-preview {
            width: 192px;
            height: 192px;
            border-radius: 8px;
            border: 1px solid var(--color-border);
            object-fit: contain;
            background: #fafafa;
            padding: 4px;
        }

        .company-logo-hint {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: var(--color-text-secondary);
            pointer-events: none;
            text-align: center;
        }

        .company-name-block {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .company-name-label {
            font-size: 11px;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        .company-name-display {
            font-size: 40px;
            color: #9e9e9e;
            font-style: italic;
            min-height: 32px;
            outline: none;
            cursor: default;
            user-select: none;
        }

        .company-name-display.has-value {
            font-size: 64px;
            font-weight: 700;
            background: linear-gradient(135deg, #f44336 0%, #5b0001 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-style: normal;
        }

        .controls {
            background: var(--color-surface);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-sm);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            border-bottom: 3px solid var(--color-primary);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
        }

        .zoom-controls .btn {
            min-width: auto !important;
            width: auto !important;
            justify-content: center;
            padding: 6px 8px !important;
            flex-shrink: 0;
        }

        .zoom-label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .zoom-range {
            width: 120px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-icon {
            width: 18px;
            height: 18px;
            display: inline-block;
            position: relative;
        }

        /* Единый стиль основных кнопок управления (PDF, Excel, Гант/Таблица, Сбросить план) */
        .controls .btn-primary,
        .controls .btn-secondary {
            background: var(--color-primary);
            color: #ffffff;
            border-radius: 6px;
            border: 1px solid var(--color-primary-hover);
            width: 180px;
            justify-content: flex-start;
            height: 40px;
            padding-left: 16px;
        }

        /* Исключаем кнопки масштаба из фиксированной ширины */
        .zoom-controls .btn-primary,
        .zoom-controls .btn-secondary {
            width: auto;
        }

        .controls .btn-primary:hover,
        .controls .btn-secondary:hover {
            background: var(--color-primary-hover);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .btn-primary .btn-icon {
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));
        }

        .btn-secondary .btn-icon {
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.15));
        }

        /* Иконка PDF: стилизованный лист с уголком */
        .btn-icon-pdf::before {
            content: '';
            position: absolute;
            inset: 1px 3px 3px 3px;
            border-radius: 3px;
            border: 2px solid currentColor;
        }

        .btn-icon-pdf::after {
            content: '';
            position: absolute;
            top: 1px;
            right: 3px;
            width: 7px;
            height: 7px;
            border-top: 2px solid currentColor;
            border-right: 2px solid currentColor;
            border-radius: 0 3px 0 0;
        }

        /* Иконка Excel: таблица */
        .btn-icon-excel::before {
            content: '';
            position: absolute;
            inset: 2px;
            border-radius: 3px;
            border: 2px solid currentColor;
        }

        .btn-icon-excel::after {
            content: '';
            position: absolute;
            inset: 5px 3px;
            border-top: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            box-shadow: inset 0 0 0 1px transparent;
        }

        .btn-icon-excel {
            --col: currentColor;
        }

        .btn-icon-excel::before,
        .btn-icon-excel::after {
            color: inherit;
        }

        /* Иконка переключения вида: два прямоугольника */
        .btn-icon-toggle::before,
        .btn-icon-toggle::after {
            content: '';
            position: absolute;
            width: 7px;
            height: 10px;
            border-radius: 2px;
            border: 2px solid currentColor;
        }

        .btn-icon-toggle::before {
            left: 1px;
            top: 3px;
        }

        .btn-icon-toggle::after {
            right: 1px;
            top: 3px;
        }

        /* Иконка сброса: круг со стрелкой */
        .btn-icon-reset::before {
            content: '';
            position: absolute;
            inset: 3px;
            border-radius: 50%;
            border: 2px solid currentColor;
            border-right-color: transparent;
        }

        .btn-icon-reset::after {
            content: '';
            position: absolute;
            right: 1px;
            top: 4px;
            width: 5px;
            height: 5px;
            border-top: 2px solid currentColor;
            border-right: 2px solid currentColor;
            transform: rotate(30deg);
        }

        /* Иконка таблицы для заголовка "Детальная таблица задач" */
        .btn-icon-table::before,
        .btn-icon-table::after {
            content: '';
            position: absolute;
        }

        .btn-icon-table::before {
            inset: 2px;
            border-radius: 3px;
            border: 2px solid currentColor;
        }

        .btn-icon-table::after {
            inset: 5px 3px;
            border-top: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
        }

        .btn-primary {
            background: var(--color-primary);
            color: white;
        }

        /* Стили для кнопки сохранения */
        #saveButton {
            background: #4caf50 !important;
            border-color: #4caf50 !important;
            font-weight: 600 !important;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important;
            position: relative;
            display: none !important; /* Скрыта, так как работает автоматическое сохранение */
        }

        #saveButton:hover {
            background: #45a049 !important;
            border-color: #45a049 !important;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4) !important;
            transform: translateY(-2px);
        }

        #saveButton.saving-success {
            background: #4caf50 !important;
            border-color: #4caf50 !important;
        }

        #saveButton.saving-error {
            background: #f44336 !important;
            border-color: #f44336 !important;
        }

        #saveButton:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Скрыть кнопку сохранения в режиме просмотра */
        body.view-mode #saveButton {
            display: none !important;
        }

        .btn-primary:hover {
            background: var(--color-primary-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }

        .btn-secondary:hover {
            background: #e8e8e8;
        }

        /* Переключатель "Гант / Таблица" с подсветкой активного режима */
        .view-toggle-label {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            font-size: 13px;
            height: 100%;
        }

        .view-toggle-part {
            display: inline-flex;
            align-items: center;
            line-height: 1.2;
            padding: 2px 10px;
            border-radius: 999px;
            transition: background-color 0.4s ease, color 0.4s ease,
                        transform 0.4s ease, box-shadow 0.4s ease;
        }

        .view-toggle-part.active {
            background: #e3f2fd;
            color: var(--color-primary);
            font-weight: 600;
            box-shadow: 0 0 0 1px rgba(30,136,229,0.5);
        }

        .view-toggle-part:not(.active) {
            opacity: 0.75;
        }

        /* Кнопка переключателя Гант / Таблица — центрируем содержимое */
        .view-toggle-btn {
            justify-content: center !important;
            padding-left: 16px;
            padding-right: 16px;
        }

        /* Лёгкая подсветка активного блока (Гант / Таблица)
           Оставляем анимацию только по opacity/transform (GPU),
           чтобы не фризило из-за анимации высоты и отступов */
        .chart-container,
        .table-section {
            transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                        box-shadow 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        background-color 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        /* Начальное состояние - элемент скрыт и снизу */
        .chart-container:not(.view-active),
        .table-section:not(.view-active) {
            opacity: 0;
            transform: translateY(20px);
            max-height: 0;
            overflow: hidden;
            margin-bottom: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        /* Активный элемент - видим и на месте */
        .chart-container.view-active,
        .table-section.view-active {
            box-shadow: 0 0 0 2px #bbdefb, var(--shadow-md);
            background-color: #f9fcff;
            opacity: 1;
            transform: translateY(0);
            max-height: 2000px;
        }

        /* Скрытый элемент - уезжает вниз */
        .view-hidden {
            max-height: 0;
            opacity: 0;
            transform: translateY(20px);
            overflow: hidden;
            pointer-events: none;
            margin-bottom: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            transition: max-height 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                        box-shadow 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        background-color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                        margin-bottom 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-top 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-bottom 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Подсказка для кнопки "Сбросить план" в стиле редакции этапов */
        .reset-plan-btn {
            position: relative;
        }
        
        /* Блокировка кнопки "Сбросить план" в режиме просмотра (только визуальная, кнопка видна) */
        .reset-plan-btn.view-mode-disabled {
            opacity: 1;
            cursor: not-allowed;
            pointer-events: auto; /* Разрешаем клики, но функция canEdit() заблокирует действие */
        }

        .reset-plan-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translate(-50%, 0);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom center;
        }

        .reset-plan-btn:hover::after {
            opacity: 1;
            transform: translate(-50%, -6px);
            transition-delay: 0.8s;
        }

        /* Подсказка для длинного списка ответственных в таблице (чёрный фон, как у остальных) */
        .table-col-responsible[data-tooltip] {
            position: relative;
        }

        .table-col-responsible[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, 4px);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top center;
            z-index: 9999;
        }

        .table-col-responsible[data-tooltip]:hover::after {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        /* Подсказка для длинного списка ответственных в Ганте (чёрный фон, как у остальных) */
        .gantt-details-cell[data-tooltip] {
            position: relative;
        }

        .gantt-details-cell[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, 4px);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top center;
            z-index: 9999;
        }

        .gantt-details-cell[data-tooltip]:hover::after {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-group label {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text-secondary);
        }

        .form-group input {
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-size: 14px;
        }

        .chart-container {
            background: var(--color-surface);
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            overflow-x: auto;
            overflow-y: auto;
            max-height: 480px;
            margin-bottom: 20px;
            border-bottom: 3px solid var(--color-primary);
        }

        .gantt-chart {
            display: flex;
            flex-direction: column;
            min-width: 100%;
            font-size: 12px;
            position: relative;
            /* Ограничиваем область, чтобы sticky-элементы не выходили за пределы */
            contain: layout style paint;
        }

        /* Для планшетов и мобильных убираем contain, чтобы не блокировать прокрутку */
        @media (max-width: 1024px) {
            .gantt-chart {
                contain: none; /* Убираем contain для корректной прокрутки */
            }
        }

        .gantt-header {
            display: flex;
            margin-bottom: 2px;
            background: var(--color-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .gantt-header-label {
            min-width: 180px;
            max-width: 180px;
            padding: 10px 10px;
            border-right: 2px solid var(--color-border);
            background: var(--color-bg);
            position: sticky;
            left: 0;
            z-index: 11;
            text-align: center;
            font-size: 16px;
            font-weight: 700;
            box-sizing: border-box;
            /* Ограничиваем область sticky, чтобы не выходила за пределы контейнера */
            clip-path: inset(0);
        }

        .gantt-details-header {
            display: flex;
        }

        .gantt-details-row {
            display: flex;
        }

        .gantt-details-cell {
            padding: 8px 6px;
            border-right: 1px solid var(--color-border);
            background: var(--color-bg);
            text-align: center;
            font-size: 11px;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        /* Анимация для колонки "Ответственный" в Ганте */
        .gantt-details-cell.responsible-cell {
            flex-basis: 0 !important;
            width: 0 !important;
            min-width: 0 !important;
            max-width: 0 !important;
            opacity: 0;
            overflow: hidden;
            padding-left: 0;
            padding-right: 0;
            margin-right: 0;
            border-right: none;
            flex-shrink: 0;
            flex-grow: 0;
            transition: flex-basis 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        max-width 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        min-width 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        width 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        padding-left 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-right 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        margin-right 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        border-right 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body.show-responsible .gantt-details-cell.responsible-cell {
            flex-basis: 200px !important;
            width: 200px !important;
            min-width: 150px !important;
            max-width: 200px !important;
            opacity: 1;
            padding-left: 6px;
            padding-right: 6px;
            margin-right: 0;
            border-right: 1px solid var(--color-border);
        }

        .gantt-details-input {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            box-sizing: border-box;
        }

        .gantt-resizable {
            position: relative;
        }

        .gantt-resizer {
            position: absolute;
            top: 0;
            right: -2px;
            width: 4px;
            height: 100%;
            cursor: col-resize;
            z-index: 20;
        }

        .gantt-header-dates-row {
            display: flex;
            flex: 1;
        }

        .gantt-header-month-row {
            display: flex;
            background: var(--color-bg);
            font-weight: 600;
            margin-bottom: 2px;
        }

        .gantt-header-month-label {
            flex: 1;
            text-align: center;
            padding: 8px 0;
            font-size: 14px;
            border-bottom: 2px solid var(--color-border);
            background: #f9f9f9;
        }

        .gantt-header-month-spacer {
            min-width: 300px;
        }

        .gantt-header-cell {
            min-width: 60px;
            padding: 10px 5px;
            text-align: center;
            border-right: 1px solid var(--color-border);
            border-bottom: 2px solid var(--color-border);
            background: var(--color-primary);
            color: white;
            line-height: 1.1;
        }

        .gantt-header-week-days {
            display: block;
        }

        .gantt-header-week-month {
            display: block;
            margin-top: 2px;
            font-size: 11px;
        }

        .gantt-row {
            display: flex;
            border-bottom: 1px solid var(--color-border);
            min-height: 35px;
            align-items: center;
            transition: background 0.15s ease, box-shadow 0.15s ease;
        }

        .gantt-row:hover {
            background: #f9f9f9;
        }

        .gantt-row.selected {
            background: #bbdefb;
            box-shadow: inset 0 0 0 1px #64b5f6;
        }

        /* При выделении задачи подсвечиваем и название, и три колонки с датами/днями,
           чтобы визуально вся строка в Ганте вела себя так же, как строка в таблице */
        .gantt-row.selected .gantt-label,
        .gantt-row.selected .gantt-details-cell {
            background: #bbdefb;
        }

        .gantt-row.dragging {
            opacity: 0.6;
        }

        .gantt-row-drop-target {
            background: #e3f2fd;
            box-shadow: inset 0 3px 0 var(--color-primary);
        }

        .gantt-label {
            min-width: 180px;
            max-width: 180px;
            padding: 8px 10px;
            border-right: 2px solid var(--color-border);
            background: var(--color-bg);
            font-weight: 500;
            font-size: 11px;
            position: sticky;
            left: 0;
            z-index: 5;
            box-sizing: border-box;
            /* Ограничиваем область sticky, чтобы не выходила за пределы контейнера */
            clip-path: inset(0);
        }

        .gantt-task-input {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--color-primary);
            box-sizing: border-box;
        }

        .gantt-cell {
            min-width: 60px;
            height: 100%;
            border-right: 1px solid var(--color-border);
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Жёлтая полоска директивного плана (baseline) под основным баром */
        .baseline-bar {
            position: absolute;
            left: 3px;
            right: 3px;
            height: 4px;
            bottom: 2px;
            background: #ffd54f;
            border-radius: 2px;
            pointer-events: none; /* не мешает кликам по основному бару */
            opacity: 0.9;
        }

        .gantt-bar {
            height: 24px;
            background: linear-gradient(135deg, var(--color-primary) 0%, #0b5ed7 100%);
            border-radius: 3px;
            border: 1px solid var(--color-primary-hover);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            width: 100%;
        }

        .gantt-bar:hover {
            transform: scaleY(1.2);
            box-shadow: var(--shadow-md);
            background: linear-gradient(135deg, var(--color-primary-hover) 0%, #073a3d 100%);
        }

        .gantt-bar.completed {
            background: linear-gradient(135deg, var(--color-success) 0%, #388e3c 100%);
            border-color: #2e7d32;
        }

        .gantt-bar.in-progress {
            background: linear-gradient(135deg, var(--color-warning) 0%, #f57c00 100%);
            border-color: #e65100;
        }

        /* В режиме сплошных полос убираем зазоры между днями, бары выглядят как единая линия */
        body.gantt-style-segments .gantt-cell {
            padding: 0;
            border-right: none;
        }

        body.gantt-style-segments .gantt-bar {
            border-radius: 0;
            width: 100%;
            /* Однородные цвета без градиента, чтобы визуально получалась сплошная полоса */
            background: var(--color-primary);
            border-color: var(--color-primary-hover);
        }

        body.gantt-style-segments .gantt-bar.in-progress {
            background: var(--color-warning);
            border-color: #e65100;
        }

        body.gantt-style-segments .gantt-bar.completed {
            background: var(--color-success);
            border-color: #2e7d32;
        }

        /* В режиме полос сглаживаем середину и оставляем скругление только на краях непрерывного отрезка */
        body.gantt-style-segments .gantt-bar.segment-middle {
            border-radius: 0;
            border-left: none;
            border-right: none;
        }

        body.gantt-style-segments .gantt-bar.segment-start {
            border-radius: 12px 0 0 12px;
            border-right: none;
        }

        body.gantt-style-segments .gantt-bar.segment-end {
            border-radius: 0 12px 12px 0;
            border-left: none;
        }

        /* Одиночный сегмент (задача не тянется на соседние интервалы)
           — скругляем оба края, чтобы не было «острых» концов. */
        body.gantt-style-segments .gantt-bar.segment-single {
            border-radius: 12px;
        }

        body.gantt-style-segments .gantt-bar:hover {
            transform: scaleY(1.05);
            box-shadow: var(--shadow-md);
        }

        .gantt-weekend {
            background: #ffe0e0;
        }

        .gantt-holiday {
            background: #fff9c4;
        }

        /* Ячейки будущего периода (после конца плана) */
        .gantt-future-header {
            background: #d4d4d4;
            color: #555555;
        }

        .gantt-future-cell {
            background: #f1f1f1;
        }

        /* Колонка "Ответственный" в таблице задач — управляем видимостью через класс на body */
        .table-col-responsible {
            display: table-cell;
            width: 0 !important;
            min-width: 0 !important;
            max-width: 0 !important;
            opacity: 0;
            overflow: hidden;
            padding-left: 0;
            padding-right: 0;
            border-left: none;
            border-right: none;
            white-space: nowrap;
            transition: width 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        max-width 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        min-width 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        opacity 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        padding-left 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-right 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        border-left 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        border-right 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body.show-responsible .table-col-responsible {
            width: 200px !important;
            min-width: 150px !important;
            max-width: 300px !important;
            opacity: 1;
            padding-left: 12px;
            padding-right: 12px;
            border-left: 1px solid var(--color-border);
            border-right: 1px solid var(--color-border);
        }

        /* Подсказка-комментарий для ячеек Ганта */
        .gantt-bar[data-tooltip] {
            position: relative;
            z-index: 5; /* поднимаем ячейку над шкалой дат */
        }

        .gantt-bar[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, 4px);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top center;
            z-index: 9999; /* всегда поверх дат и других элементов Ганта */
        }

        .gantt-bar[data-tooltip]:hover::after {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        .status-comment-input {
            width: 100%;
            resize: vertical;
            min-height: 70px;
            padding: 6px 8px;
            font-size: 13px;
            border-radius: 6px;
            border: 1px solid var(--color-border);
        }

        /* Меню статуса задачи по дате */
        .status-menu {
            position: fixed;
            z-index: 200;
            background: var(--color-surface);
            border-radius: 6px;
            box-shadow: var(--shadow-md);
            padding: 8px 0;
            min-width: 180px;
            border: 1px solid var(--color-border);
            display: none;
        }

        @media (max-width: 480px) {
            .status-menu {
                min-width: 160px;
                padding: 6px 0;
            }
        }

        .status-menu-item {
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-menu-item:hover {
            background: #f5f5f5;
        }

        .status-color-box {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid #999;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding: 15px;
            background: var(--color-bg);
            border-radius: 6px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .legend {
                gap: 15px;
                padding: 12px;
                margin-top: 15px;
            }
        }

        @media (max-width: 480px) {
            .legend {
                gap: 10px;
                padding: 10px;
                margin-top: 12px;
            }
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        @media (max-width: 480px) {
            .legend-item {
                font-size: 0.7rem;
                gap: 6px;
            }

            .status-color-box {
                width: 12px;
                height: 12px;
            }
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #999;
        }

        .stats {
            background: var(--color-surface);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-sm);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            border-bottom: 3px solid var(--color-primary);
        }

        .stat-card {
            padding: 15px;
            background: var(--color-bg);
            border-left: 4px solid var(--color-primary);
            border-radius: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--color-primary);
        }

        .table-section {
            background: var(--color-surface);
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            margin-bottom: 20px;
            margin-top: 0;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 600px;
            border-bottom: 3px solid var(--color-primary);
        }

        .table-section h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: var(--color-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        th {
            background: var(--color-primary);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border: 1px solid var(--color-primary-hover);
        }

        /* Шапка таблицы задач: делаем подписи крупнее и по центру */
        #tasksTable thead th {
            font-size: 13px;
            text-align: center;
            vertical-align: middle;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        td {
            padding: 10px 12px;
            border: 1px solid var(--color-border);
        }

        .tasks-table-input {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
        }

        .tasks-table-input[type="number"] {
            text-align: center;
        }

        .tasks-table-input-select {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            background: #fff;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        tr:hover {
            background: #f0f0f0;
        }

        tr.selected {
            background: #bbdefb !important;
        }

        /* Подсветка/затемнение задач при фильтрации по этапам */
        .gantt-row.stage-active {
            background: #e3f2fd;
        }

        .gantt-row.inactive {
            opacity: 0.25;
            filter: grayscale(0.4);
            pointer-events: none;
        }

        tr.stage-active {
            background: #e3f2fd;
        }

        tr.inactive {
            opacity: 0.4;
            color: #aaaaaa;
            pointer-events: none;
        }

        tr.dragging {
            opacity: 0.6;
        }

        tr.table-row-drop-target {
            background: #e3f2fd;
            box-shadow: inset 0 3px 0 var(--color-primary);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .baseline-toast {
            position: fixed;
            right: 20px;
            bottom: 20px;
            max-width: 320px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 13px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 10000;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .baseline-toast {
                right: 15px;
                bottom: 15px;
                max-width: calc(100% - 30px);
                font-size: 11px;
                padding: 10px 14px;
            }
        }

        @media (max-width: 480px) {
            .baseline-toast {
                right: 10px;
                bottom: 10px;
                max-width: calc(100% - 20px);
                font-size: 10px;
                padding: 8px 12px;
            }
        }

        .baseline-toast.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Окно удаления этапа всегда поверх окна настроек этапов */
        #stageDeleteModal {
            z-index: 110;
        }

        .modal-content {
            background-color: var(--color-surface);
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            box-shadow: var(--shadow-md);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .modal-header h2 {
            font-size: 18px;
            color: var(--color-primary);
        }

        .stage-settings-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .stage-settings-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px dashed var(--color-border);
            background: #fafafa;
            cursor: grab;
        }

        .stage-settings-item.dragging {
            opacity: 0.7;
            background: #e3f2fd;
        }

        .stage-settings-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stage-settings-handle {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: var(--color-muted);
        }

        .stage-settings-name {
            font-size: 14px;
            font-weight: 500;
            cursor: default;
        }

        .stage-settings-name.editable {
            border-bottom: 1px dashed var(--color-border);
        }

        .stage-settings-delete-btn {
            border: none;
            background: transparent;
            color: #d32f2f;
            cursor: pointer;
            font-size: 13px;
            padding: 4px 8px;
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .stage-settings-delete-btn:hover {
            background: #ffebee;
        }

        .stage-settings-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 16px;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--color-text-secondary);
        }

        .close:hover {
            color: var(--color-text);
        }

        .hidden {
            display: none;
        }

        .stage-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        }

        .stage-tabs-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .stage-tab-btn {
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--color-primary);
            background: #e3f2fd;
            color: var(--color-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
            min-width: 120px;
            text-align: center;
        }

        .stage-tab-btn:hover {
            background: #bbdefb;
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .stage-tab-btn.active {
            background: var(--color-primary);
            color: #fff;
            box-shadow: var(--shadow-md);
        }

        /* Кнопка "Ответственный" — по размеру и форме как переключатель вида,
           но с цветами, как у табов этапов. */
        .responsible-toggle-btn {
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        /* Кнопка "Задать базовый план" — такой же стиль как "Ответственный" и "Детальный вид" */
        .baseline-set-btn {
            padding: 6px 14px !important;
            border-radius: 999px !important;
            font-size: 12px !important;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        /* Кнопка "Директивный план" — такой же стиль как остальные кнопки */
        .baseline-toggle-btn {
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid var(--color-primary);
            background: #e3f2fd;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            color: var(--color-primary);
            box-shadow: var(--shadow-sm);
            transition:
                background 0.25s ease,
                color 0.25s ease,
                box-shadow 0.25s ease,
                transform 0.25s ease;
        }

        .baseline-toggle-btn.active {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-hover) 100%);
            color: #ffffff;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .baseline-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        /* Кнопка переключения стиля баров в Ганте (детальный / общий вид).
           В неактивном состоянии соответствует «Детальному виду» и выглядит как таб этапов
           (голубой фон, синий бордер). В активном состоянии показывает «Общий вид» и
           становится синей «пилюлей». */
        .gantt-style-toggle-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid var(--color-primary);
            background: #e3f2fd;
            font-size: 12px;
            cursor: pointer;
            color: var(--color-primary);
            box-shadow: var(--shadow-sm);
            transition:
                background 0.25s ease,
                color 0.25s ease,
                box-shadow 0.25s ease,
                transform 0.25s ease;
        }

        .gantt-style-toggle-btn span {
            white-space: nowrap;
        }

        .gantt-style-toggle-btn.active {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-hover) 100%);
            color: #ffffff;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .gantt-style-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .stage-settings-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 32px;
            border-radius: 10px;
            border: 1px solid var(--color-primary);
            background: #e3f2fd;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: background 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
            position: relative;
        }

        .stage-settings-btn:hover {
            background: #bbdefb;
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .stage-settings-btn::after,
        .gantt-style-toggle-btn::after,
        .baseline-toggle-btn::after,
        .baseline-set-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translate(-50%, 0);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom center;
        }

        .stage-settings-btn:hover::after,
        .gantt-style-toggle-btn:hover::after,
        .baseline-toggle-btn:hover::after,
        .baseline-set-btn:hover::after {
            opacity: 1;
            transform: translate(-50%, -6px);
            transition-delay: 1s;
        }

        .stage-settings-icon {
            position: relative;
            width: 18px;
            height: 16px;
        }

        .stage-settings-bar {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--color-primary);
            border-radius: 999px;
        }

        .stage-settings-bar-1 {
            top: 2px;
        }

        .stage-settings-bar-2 {
            top: 7px;
        }

        .stage-settings-bar-3 {
            top: 12px;
        }

        .stage-settings-knob {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            border: 2px solid var(--color-primary);
            background: #fff;
        }

        .stage-settings-knob-1 {
            top: -1px;
            left: 2px;
        }

        .stage-settings-knob-2 {
            top: 4px;
            right: 2px;
        }

        .stage-settings-knob-3 {
            top: 9px;
            left: 6px;
        }

        /* Адаптивность для планшетов и мобильных */
        @media (max-width: 1024px) {
            .container {
                max-width: 100%;
                padding: 15px;
            }

            header {
                padding: 25px 15px;
            }

            header h1 {
                font-size: 1.4rem;
            }

            .header-subtitle {
                font-size: 0.9rem;
            }

            .company-info {
                flex-direction: column;
                gap: 20px;
                align-items: center;
            }

            .company-logo-display {
                width: 100%;
                max-width: 300px;
                justify-content: center;
                margin: 0 auto;
            }
            
            .company-logo-preview {
                margin: 0 auto;
            }

            .company-name-block {
                width: 100%;
                text-align: center;
            }

            .controls {
                flex-wrap: wrap;
                gap: 10px;
            }

            .btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }

            /* Для планшетов включаем прокрутку графика */
            .chart-container {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                touch-action: pan-x pan-y;
            }

            .gantt-chart {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                touch-action: pan-x pan-y;
                min-width: 100%;
            }

            .gantt-label {
                min-width: 120px;
                font-size: 0.75rem;
            }

            .gantt-header-cell {
                min-width: 35px;
                font-size: 0.7rem;
            }

            /* Кнопки управления на мобильных - вертикальное выравнивание с одинаковыми отступами */
            .profile-btn,
            .companies-btn,
            .companies-bottom-btn,
            .logout-btn {
                width: 40px;
                height: 40px;
                right: 25px !important;
            }

            .profile-btn {
                top: 25px;
            }

            .companies-bottom-btn {
                top: 75px; /* 25px + 40px (высота) + 10px (отступ) */
            }

            .logout-btn {
                top: 125px; /* 75px + 40px (высота) + 10px (отступ) */
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            header {
                padding: 20px 15px;
                margin-bottom: 20px;
            }

            header h1 {
                font-size: 1.2rem;
                line-height: 1.3;
            }

            .header-subtitle {
                font-size: 0.85rem;
                margin-top: 8px;
            }

            .company-info {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
                align-items: center;
            }

            .company-logo-display {
                width: 100%;
                max-width: 250px;
                justify-content: center;
                margin: 0 auto;
            }

            .company-logo-preview {
                max-width: 200px;
                max-height: 150px;
                margin: 0 auto;
                display: block;
            }

            .company-name-display {
                font-size: 1.2rem;
                padding: 10px;
            }

            .controls {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .controls-left,
            .controls-right {
                width: 100%;
                flex-direction: column;
                gap: 10px;
            }

            .btn {
                width: 100%;
                padding: 12px;
                font-size: 0.9rem;
                justify-content: center;
                min-height: 44px; /* Минимальный размер для touch на iOS */
                touch-action: manipulation; /* Улучшает отзывчивость на touch */
            }

            .btn-icon {
                margin-right: 8px;
            }

            /* Кнопки управления на мобильных - вертикальное выравнивание с одинаковыми отступами */
            .profile-btn,
            .companies-btn,
            .companies-bottom-btn,
            .logout-btn {
                width: 38px;
                height: 38px;
                right: 15px !important;
            }

            .profile-btn {
                top: 15px;
            }

            .companies-bottom-btn {
                top: 63px; /* 15px + 38px (высота) + 10px (отступ) */
            }

            .logout-btn {
                top: 111px; /* 63px + 38px (высота) + 10px (отступ) */
            }

            .profile-btn::before {
                width: 18px;
                height: 18px;
                border-width: 2.5px;
            }

            .companies-btn::before {
                width: 16px;
                height: 16px;
                border-width: 1.5px;
            }

            .logout-btn::before {
                border-right-width: 10px;
                border-top-width: 7px;
                border-bottom-width: 7px;
            }

            /* График Ганта на мобильных */
            .chart-container {
                isolation: isolate;
                contain: layout style;
                position: relative;
                z-index: 1;
                max-width: 100%;
                overflow: hidden;
            }

            .gantt-chart {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                position: relative;
                max-width: 100%;
                box-sizing: border-box;
                z-index: 1;
                touch-action: pan-x pan-y; /* Разрешаем прокрутку на планшетах и мобильных */
            }

            /* На мобильных отключаем sticky для колонки названий, чтобы она не перекрывала график */
            .gantt-header-label,
            .gantt-label {
                position: static !important; /* Отключаем sticky на мобильных */
                max-width: 100%;
                width: 100%;
                min-width: auto;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                z-index: auto;
            }

            /* Ячейки графика */
            .gantt-row .gantt-cell {
                position: relative;
                z-index: 1;
                background: var(--color-bg);
            }

            .gantt-chart::-webkit-scrollbar {
                height: 8px;
            }

            .gantt-chart::-webkit-scrollbar-thumb {
                background: #90caf9;
                border-radius: 4px;
            }

            .gantt-chart::-webkit-scrollbar-track {
                background: #e3f2fd;
            }

            .gantt-label {
                min-width: 120px;
                max-width: 120px;
                width: 120px;
                font-size: 0.7rem;
                padding: 8px 6px;
                z-index: auto;
                position: static !important; /* Отключаем sticky на мобильных */
            }

            .gantt-header-label {
                min-width: 120px;
                max-width: 120px;
                width: 120px;
                z-index: auto;
                position: static !important; /* Отключаем sticky на мобильных */
            }

            /* Убеждаемся, что график не перекрывается */
            .gantt-cell,
            .gantt-header-cell {
                position: relative;
                z-index: 1;
            }

            .gantt-header-cell {
                min-width: 30px;
                font-size: 0.65rem;
                padding: 6px 4px;
            }

            .gantt-cell {
                min-width: 30px;
            }

            .gantt-bar {
                min-width: 20px;
            }

            /* Таблица задач на мобильных */
            .table-section {
                position: relative;
                z-index: 1;
                max-width: 100%;
                overflow-x: auto;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Отключаем sticky для шапки таблицы на мобильных, чтобы не блокировать прокрутку */
            #tasksTable thead th {
                position: static !important;
            }

            .tasks-table-wrapper {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                position: relative;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                touch-action: pan-x pan-y; /* Разрешаем прокрутку на мобильных */
            }

            .tasks-table-wrapper::-webkit-scrollbar {
                height: 8px;
            }

            .tasks-table-wrapper::-webkit-scrollbar-thumb {
                background: #90caf9;
                border-radius: 4px;
            }

            .tasks-table-wrapper::-webkit-scrollbar-track {
                background: #e3f2fd;
            }

            .tasks-table {
                width: 100%;
                font-size: 0.85rem;
                min-width: 800px; /* Минимальная ширина для читаемости */
            }

            .tasks-table th,
            .tasks-table td {
                padding: 8px 6px;
                font-size: 0.8rem;
            }

            .tasks-table-input {
                padding: 6px 8px;
                font-size: 0.8rem;
            }

            /* Статистика */
            .statistics {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .stat-item {
                width: 100%;
                padding: 12px;
            }

            /* Этапы */
            .stage-tabs {
                flex-wrap: wrap;
                gap: 8px;
                padding: 10px;
                flex-direction: column;
            }

            .stage-tabs-buttons {
                width: 100%;
                display: flex;
                flex-direction: column; /* Вертикальное расположение на планшетах */
                gap: 8px;
            }

            .stage-tab-btn {
                width: 100%; /* Все кнопки одинаковой ширины */
                padding: 10px 12px;
                font-size: 0.85rem;
                min-height: 44px;
            }

            /* Контейнер с дополнительными кнопками тоже вертикально на планшетах */
            .stage-controls-buttons {
                flex-direction: column !important;
                width: 100%;
                gap: 8px !important;
            }

            /* Одинаковый размер всех кнопок на планшетах - одинаковой ширины */
            .responsible-toggle-btn,
            .gantt-style-toggle-btn,
            .baseline-set-btn,
            .baseline-toggle-btn,
            .stage-settings-btn {
                width: 100%; /* Все кнопки одинаковой ширины */
                padding: 10px 12px;
                font-size: 0.8rem;
                min-height: 44px;
                justify-content: center;
            }

            /* Уменьшаем размер текста кнопки "Директивный план" на планшетах */
            .baseline-toggle-btn {
                font-size: 0.75rem;
            }

            /* Убираем min-width для кнопки "Ответственный" на планшетах */
            .stage-tab-btn.responsible-toggle-btn {
                min-width: auto;
                flex: 0 0 auto;
            }

            .stage-tab {
                padding: 8px 12px;
                font-size: 0.85rem;
            }

            /* Модальные окна */
            .modal-content {
                width: 95%;
                max-width: 95%;
                padding: 20px 15px;
                margin: 10% auto;
            }

            .modal-header h2 {
                font-size: 1.3rem;
            }

            .profile-modal-content {
                width: 95%;
                max-width: 95%;
                padding: 20px 15px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 8px;
            }

            header {
                padding: 15px 12px;
                margin-bottom: 15px;
            }

            header h1 {
                font-size: 1rem;
                line-height: 1.2;
            }

            .header-subtitle {
                font-size: 0.75rem;
                margin-top: 6px;
            }

            .company-info {
                padding: 12px;
                align-items: center;
            }
            
            .company-logo-display {
                justify-content: center;
                margin: 0 auto;
            }

            .company-logo-preview {
                max-width: 150px;
                max-height: 120px;
                margin: 0 auto;
                display: block;
            }

            .company-name-display {
                font-size: 1rem;
                padding: 8px;
            }

            .controls {
                padding: 12px;
            }

            .btn {
                padding: 10px;
                font-size: 0.85rem;
                min-height: 44px; /* Минимальный размер для touch на iOS */
                touch-action: manipulation; /* Улучшает отзывчивость на touch */
            }

            /* Кнопки управления на маленьких экранах - вертикальное выравнивание с одинаковыми отступами */
            .profile-btn,
            .companies-btn,
            .companies-bottom-btn,
            .logout-btn {
                width: 35px;
                height: 35px;
                right: 12px !important;
            }

            .profile-btn {
                top: 12px;
            }

            .companies-bottom-btn {
                top: 57px; /* 12px + 35px (высота) + 10px (отступ) */
            }

            .logout-btn {
                top: 102px; /* 57px + 35px (высота) + 10px (отступ) */
            }

            .gantt-label {
                min-width: 80px;
                max-width: 80px;
                font-size: 0.65rem;
                padding: 6px 4px;
                word-break: break-word;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .gantt-header-cell {
                min-width: 25px;
                font-size: 0.6rem;
                padding: 4px 2px;
            }

            .gantt-cell {
                min-width: 25px;
            }

            /* Улучшенный скролл для мобильных */
            .gantt-chart {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                scrollbar-color: #90caf9 #e3f2fd;
            }

            .tasks-table {
                font-size: 0.75rem;
            }

            .tasks-table th,
            .tasks-table td {
                padding: 6px 4px;
                font-size: 0.7rem;
                white-space: nowrap;
            }

            .tasks-table-input {
                padding: 4px 6px;
                font-size: 0.7rem;
                width: 100%;
                min-width: 60px;
            }

            /* Улучшенный скролл для таблицы на мобильных */
            .tasks-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                scrollbar-color: #90caf9 #e3f2fd;
            }

            .statistics {
                padding: 12px;
            }

            .stat-item {
                padding: 10px;
            }

            .stat-value {
                font-size: 1.5rem;
            }

            .stat-label {
                font-size: 0.75rem;
            }

            .stage-tabs {
                padding: 8px;
                flex-direction: column;
            }

            .stage-tabs-buttons {
                width: 100%;
                display: flex;
                flex-direction: column; /* Вертикальное расположение на мобильных */
                gap: 8px;
            }

            .stage-tab-btn {
                width: 100%; /* Все кнопки одинаковой ширины */
                min-height: 44px; /* Минимальный размер для touch на iOS */
                padding: 10px 12px;
                font-size: 0.875rem;
                touch-action: manipulation; /* Улучшает отзывчивость на touch */
            }

            /* Контейнер с дополнительными кнопками тоже вертикально на мобильных */
            .stage-controls-buttons {
                flex-direction: column !important;
                width: 100%;
                gap: 8px !important;
            }

            /* Одинаковый размер всех кнопок на мобильных - одинаковой ширины */
            .responsible-toggle-btn,
            .gantt-style-toggle-btn,
            .baseline-set-btn,
            .baseline-toggle-btn,
            .stage-settings-btn {
                width: 100% !important; /* Все кнопки одинаковой ширины */
                padding: 10px 12px;
                font-size: 0.75rem;
                min-height: 44px; /* Минимальный размер для touch на iOS */
                touch-action: manipulation;
                justify-content: center;
                display: flex !important;
                align-items: center;
            }

            /* Уменьшаем размер текста кнопки "Директивный план" на мобильных */
            .baseline-toggle-btn {
                font-size: 0.7rem;
                white-space: nowrap;
            }

            /* Кнопка "Редакция этапов" на мобильных - полная ширина с текстом */
            .stage-settings-btn {
                height: auto !important;
            }

            /* Убираем min-width для кнопки "Ответственный" на мобильных, чтобы она была такого же размера */
            .stage-tab-btn.responsible-toggle-btn {
                min-width: auto;
                flex: 0 0 auto;
            }

            .stage-tab {
                padding: 6px 10px;
                font-size: 0.75rem;
            }

            .modal-content {
                width: 98%;
                max-width: 98%;
                padding: 15px 12px;
                margin: 5% auto;
            }

            .modal-header h2 {
                font-size: 1.1rem;
            }

            .profile-modal-content {
                width: 98%;
                max-width: 98%;
                padding: 15px 12px;
            }

            .profile-modal-header h2 {
                font-size: 1.1rem;
            }

            .profile-form-group input {
                padding: 10px;
                font-size: 16px; /* Предотвращает зум на iOS */
            }
        }

        /* Landscape ориентация для мобильных */
        @media (max-width: 768px) and (orientation: landscape) {
            .container {
                padding: 8px;
            }

            header {
                padding: 15px 12px;
                margin-bottom: 10px;
            }

            header h1 {
                font-size: 1.1rem;
            }

            .controls {
                padding: 10px;
                gap: 8px;
            }

            .btn {
                padding: 8px 12px;
                font-size: 0.85rem;
            }

            .gantt-chart {
                max-height: 50vh;
            }

            .tasks-table-wrapper {
                max-height: 40vh;
            }
        }

        @media (max-width: 360px) {
            header h1 {
                font-size: 0.9rem;
            }

            .gantt-label {
                min-width: 70px;
                font-size: 0.6rem;
            }

            .gantt-header-cell {
                min-width: 20px;
                font-size: 0.55rem;
            }
        }

        /* Горизонтальная прокрутка для графика на планшетах и мобильных */
        @media (max-width: 1024px) {
            .chart-container {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                touch-action: pan-x pan-y;
            }

            .gantt-chart-wrapper {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                position: relative;
                touch-action: pan-x pan-y;
            }

            .gantt-chart {
                min-width: 800px; /* Минимальная ширина для корректного отображения */
                touch-action: pan-x pan-y;
            }
        }

        @media (max-width: 768px) {
            .tasks-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                touch-action: pan-x pan-y;
            }

            .tasks-table {
                min-width: 600px; /* Минимальная ширина для таблицы */
            }
        }

        @media print {
            .controls {
                display: none;
            }

            .chart-container {
                box-shadow: none;
                border: 1px solid var(--color-border);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <button class="logout-btn" id="logoutBtn" data-tooltip="Выход" style="display: none;" onclick="logout()">
                <span class="logout-icon"></span>
                <span class="logout-tooltip">Выход</span>
            </button>
            <button class="profile-btn" id="profileBtn" data-tooltip="Редактировать профиль" style="display: none;">
                <span class="profile-icon-head"></span>
                <span class="profile-icon-shoulders"></span>
                <span class="profile-tooltip">Редактировать профиль</span>
            </button>
            <button class="companies-bottom-btn" id="companiesBottomBtn" data-tooltip="Компании" style="display: none;" onclick="goToCompanies()">
                <span class="companies-bottom-icon"></span>
                <span class="companies-bottom-tooltip">Компании</span>
            </button>
            <h1>
                <span class="header-icon"></span>
                <span>График внедрения и обучения системы ICONA</span>
            </h1>
            <p class="header-subtitle">Интерактивная визуализация плана цифровизации процессов</p>
            <div class="company-info">
                <div class="company-logo-display" id="companyLogoWrapper">
                    <img id="companyLogo" class="company-logo-preview" src="favicon.png" alt="Логотип компании">
                </div>
                <div class="company-name-block">
                    <span class="company-name-label">Название компании</span>
                    <div
                        id="companyNameDisplay"
                        class="company-name-display"
                        data-placeholder="Введите название компании"
                    >Введите название компании</div>
                </div>
            </div>
        </header>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">Всего этапов</div>
                <div class="stat-value" id="totalStages">4</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Всего задач</div>
                <div class="stat-value" id="totalTasks">51</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Рабочих дней</div>
                <div class="stat-value" id="totalDays">265</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Дата завершения</div>
                <div class="stat-value" id="completionDate">-</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="saveButton" onclick="manualSaveGantt()" data-tooltip="Принудительно сохранить все изменения">
                <span class="btn-icon">💾</span>
                <span id="saveButtonText">Сохранить</span>
            </button>
            <button class="btn btn-secondary view-toggle-btn" onclick="toggleView()">
                <span class="btn-icon btn-icon-toggle"></span>
                <span class="view-toggle-label">
                    <span class="view-toggle-part view-toggle-gantt">Гант</span>
                    <span class="view-toggle-separator">/</span>
                    <span class="view-toggle-part view-toggle-table">Таблица</span>
                </span>
            </button>
            <button class="btn btn-primary" onclick="openPDFExportModal()">
                <span class="btn-icon btn-icon-pdf"></span>
                <span>Выгрузить в PDF</span>
            </button>
            <button class="btn btn-primary" onclick="openExcelExportModal()">
                <span class="btn-icon btn-icon-excel"></span>
                <span>Выгрузить в Excel</span>
            </button>
            <button class="btn btn-secondary reset-plan-btn" onclick="resetSchedule()" data-tooltip="Сбросить все даты до дефолтных значений">
                <span class="btn-icon btn-icon-reset"></span>
                <span>Сбросить план</span>
            </button>

            <div class="zoom-controls">
                <span class="zoom-label">Масштаб по времени:</span>
                <button class="btn btn-secondary" onclick="decreaseZoom()">−</button>
                <input type="range" id="zoomRange" class="zoom-range" min="40" max="200" value="120" step="5" onchange="onZoomChange(this.value)">
                <button class="btn btn-secondary" onclick="increaseZoom()">+</button>
                <span class="zoom-label" style="margin-left: 8px;">Для зумирования зажмите Z+колесо мыши</span>
            </div>
        </div>

        <div class="stage-tabs">
            <div class="stage-tabs-buttons">
                <button class="stage-tab-btn active">Все этапы</button>
                <button class="stage-tab-btn">Этап 1</button>
                <button class="stage-tab-btn">Этап 2</button>
                <button class="stage-tab-btn">Этап 3</button>
                <button class="stage-tab-btn">Этап 4</button>
            </div>
            <div class="stage-controls-buttons" style="display: flex; align-items: center; gap: 8px;">
                <button
                    class="baseline-toggle-btn"
                    id="baselineToggleBtn"
                    onclick="toggleBaselineDisplay()"
                    data-tooltip="Показать/скрыть директивный план (F3)"
                >
                    Директивный план
                </button>
                <button
                    class="stage-tab-btn baseline-set-btn"
                    id="baselineSetBtn"
                    onclick="setBaselinePlan()"
                    data-tooltip="Задать базовый план (F2)"
                >
                    Задать базовый план
                </button>
                <button
                    class="stage-tab-btn responsible-toggle-btn"
                    id="responsibleToggleBtn"
                    onclick="toggleResponsibleColumn()"
                    data-tooltip="Показать/скрыть столбец 'Ответственный'"
                >
                    Ответственный
                </button>
                <button
                    class="gantt-style-toggle-btn"
                    id="ganttStyleToggleBtn"
                    onclick="toggleGanttBarStyle()"
                    data-tooltip="Отображение дней в диаграмме Ганта"
                >
                    <span>Детальный вид</span>
                </button>
                <button class="stage-settings-btn" onclick="openStageSettingsModal()" data-tooltip="Редакция этапов">
                    <span class="stage-settings-icon">
                        <span class="stage-settings-bar stage-settings-bar-1"></span>
                        <span class="stage-settings-bar stage-settings-bar-2"></span>
                        <span class="stage-settings-bar stage-settings-bar-3"></span>
                        <span class="stage-settings-knob stage-settings-knob-1"></span>
                        <span class="stage-settings-knob stage-settings-knob-2"></span>
                        <span class="stage-settings-knob stage-settings-knob-3"></span>
                    </span>
                </button>
            </div>
        </div>

        <div class="chart-container view-active">
            <div id="ganttChart" class="gantt-chart"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, #1e88e5 0%, #0b5ed7 100%);"></div>
                    <span>Запланированные работы</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);"></div>
                    <span>В процессе выполнения</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);"></div>
                    <span>Завершено</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffe0e0;"></div>
                    <span>Выходные дни</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fff9c4;"></div>
                    <span>Праздничные дни</span>
                </div>
            </div>
        </div>

        <div class="table-section view-hidden">
            <h2><span class="btn-icon btn-icon-table"></span> Детальная таблица задач</h2>
            <table id="tasksTable">
                <thead>
                    <tr>
                        <th>№ п/п</th>
                        <th>Этап</th>
                        <th>Вид контроля</th>
                        <th>Мероприятие</th>
                        <th>Дата начала</th>
                        <th>Дата окончания</th>
                        <th>Рабочих дней</th>
                        <th class="table-col-responsible">Ответственный</th>
                        <th>Статус</th>
                    </tr>
                </thead>
                <tbody id="tasksTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Меню изменения статуса ячейки/диапазона по дате -->
    <div id="statusMenu" class="status-menu">
        <div class="status-menu-item" data-status="pending">
            <div class="status-color-box" style="background: linear-gradient(135deg, #1e88e5 0%, #0b5ed7 100%);"></div>
            <span>Запланировано</span>
        </div>
        <div class="status-menu-item" data-status="in-progress">
            <div class="status-color-box" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);"></div>
            <span>В работе</span>
        </div>
        <div class="status-menu-item" data-status="completed">
            <div class="status-color-box" style="background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);"></div>
            <span>Завершено (с начала по выбранную дату)</span>
        </div>
        <div class="status-menu-item" data-status="weekend-manual">
            <div class="status-color-box" style="background: #ffe0e0;"></div>
            <span>Выходной</span>
        </div>
        <div class="status-menu-item" data-status="holiday-manual">
            <div class="status-color-box" style="background: #fff9c4;"></div>
            <span>Праздник</span>
        </div>
    </div>

    <div id="editModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Изменить дату начала проекта</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="form-group">
                <label for="startDateInput">Выберите дату начала (рабочий день):</label>
                <input type="date" id="startDateInput" value="">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-primary" onclick="updateStartDate()">Применить</button>
                <button class="btn btn-secondary" onclick="closeModal()">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Модал для комментария к статусу "В работе"/"Завершено" -->
    <div id="statusCommentModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Комментарий к статусу</h2>
                <span class="close" onclick="cancelStatusComment()">&times;</span>
            </div>
            <div class="form-group">
                <label for="statusCommentInput">Опишите, что было сделано (необязательно):</label>
                <textarea id="statusCommentInput" class="status-comment-input" rows="3"></textarea>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-primary" onclick="confirmStatusComment()">Сохранить</button>
                <button class="btn btn-secondary" onclick="cancelStatusComment()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="pdfExportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Выгрузка в PDF</h2>
                <span class="close" onclick="closePDFExportModal()">&times;</span>
            </div>
            <p style="margin-bottom: 12px;">
                Будет сформирован PDF-файл с диаграммой Ганта в выбранном масштабе и детальной таблицей задач с комментариями.
            </p>
            <div class="form-group" style="margin-bottom: 16px;">
                <label for="pdfScaleMode">Масштаб представления Ганта:</label>
                <select id="pdfScaleMode">
                    <option value="day">Дни</option>
                    <option value="week">Недели</option>
                    <option value="month">Месяцы</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="btn btn-primary" onclick="confirmPDFExport()">Выгрузить</button>
                <button class="btn btn-secondary" onclick="closePDFExportModal()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="excelExportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Выгрузка в Excel</h2>
                <span class="close" onclick="closeExcelExportModal()">&times;</span>
            </div>
            <p style="margin-bottom: 12px;">
                Будет сформирован файл Excel с двумя листами:
                на первом — диаграмма Ганта в выбранном масштабе, на втором — таблица задач.
            </p>
            <div class="form-group" style="margin-bottom: 16px;">
                <label for="excelScaleMode">Масштаб Ганта:</label>
                <select id="excelScaleMode">
                    <option value="day">Дни</option>
                    <option value="week">Недели</option>
                    <option value="month">Месяцы</option>
                    <option value="year">Годы</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="btn btn-primary" onclick="confirmExcelExport()">Выгрузить</button>
                <button class="btn btn-secondary" onclick="closeExcelExportModal()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="deleteConfirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Удалить задачу?</h2>
                <span class="close" onclick="cancelDeleteTask()">&times;</span>
            </div>
            <p>Вы действительно хотите удалить выбранную задачу из графика?</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmDeleteTask()">Да, удалить</button>
                <button class="btn btn-secondary" onclick="cancelDeleteTask()">Нет</button>
            </div>
        </div>
    </div>

    <div id="stageDeleteModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Удалить этап?</h2>
                <span class="close" onclick="cancelDeleteStage()">&times;</span>
            </div>
            <p id="stageDeleteText">Вы действительно хотите удалить выбранный этап со всеми его задачами?</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmDeleteStage()">Да, удалить</button>
                <button class="btn btn-secondary" onclick="cancelDeleteStage()">Нет</button>
            </div>
        </div>
    </div>

    <div id="resetPlanConfirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Сбросить план?</h2>
                <span class="close" onclick="cancelResetPlan()">&times;</span>
            </div>
            <p>Вы действительно хотите сбросить все даты, статусы и комментарии до значений по умолчанию?</p>
            <p style="color: #f44336; font-weight: 500; margin-top: 10px;">Это действие не может быть отменено.</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmResetPlan()">Да, сбросить</button>
                <button class="btn btn-secondary" onclick="cancelResetPlan()">Нет</button>
            </div>
        </div>
    </div>

    <div id="stageSettingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Настройка этапов</h2>
                <span class="close" onclick="closeStageSettingsModal()">&times;</span>
            </div>
            <p style="margin-bottom: 12px;">
                Перетащите этапы, чтобы изменить порядок. Дважды кликните по названию, чтобы переименовать.
            </p>
            <div id="stageSettingsList" class="stage-settings-list"></div>
            <div class="stage-settings-footer">
                <button class="btn btn-secondary" onclick="addNewStage()">Добавить этап</button>
                <button class="btn btn-secondary" onclick="closeStageSettingsModal()">Готово</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно подтверждения перезаписи базового плана -->
    <div id="baselineConfirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Перезаписать базовый план?</h2>
                <span class="close" onclick="cancelBaselineOverwrite()">&times;</span>
            </div>
            <p>Директивный график уже сохранён. Перезаписать его текущим состоянием задач?</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmBaselineOverwrite()">Да, перезаписать</button>
                <button class="btn btn-secondary" onclick="cancelBaselineOverwrite()">Нет</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для ошибок валидации дат -->
    <div id="dateValidationModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Некорректный интервал дат</h2>
                <span class="close" onclick="closeDateValidationModal()">&times;</span>
            </div>
            <p id="dateValidationMessage">
                Дата окончания не может быть раньше даты начала.
            </p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="closeDateValidationModal()">Понятно</button>
            </div>
        </div>
    </div>

    <!-- Небольшой toast для сообщений по базовому плану -->
    <div id="baselineToast" class="baseline-toast">    </div>

    <!-- Модальное окно редактирования профиля -->
    <div id="profileModal" class="profile-modal">
        <div class="profile-modal-content">
            <div class="profile-modal-header">
                <h2>Редактирование профиля</h2>
                <button class="profile-modal-close" onclick="closeProfileModal()">&times;</button>
            </div>
            <form id="profileForm">
                <div class="profile-form-group">
                    <label for="profileLogin">Логин:</label>
                    <input type="text" id="profileLogin" required>
                </div>
                <div class="profile-form-group">
                    <label for="profilePassword">Новый пароль (минимум 6 символов):</label>
                    <input type="password" id="profilePassword" minlength="6" placeholder="Оставьте пустым, чтобы не менять">
                </div>
                <div class="profile-form-group">
                    <label for="profilePasswordConfirm">Подтвердите пароль:</label>
                    <input type="password" id="profilePasswordConfirm" minlength="6" placeholder="Оставьте пустым, чтобы не менять">
                </div>
                <div id="profileMessage" class="profile-message"></div>
                <div class="profile-form-actions">
                    <button type="submit" class="btn btn-primary">Сохранить</button>
                    <button type="button" class="btn btn-secondary" onclick="closeProfileModal()">Отмена</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Данные о задачах из Excel файла
        // ========== ПОЛУЧЕНИЕ COMPANY ИЗ URL ==========
        function getCompanyFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('company') || localStorage.getItem('gantt-company') || null;
        }

        let currentCompany = getCompanyFromURL();
        if (currentCompany) {
            localStorage.setItem('gantt-company', currentCompany);
            console.log('🏢 Текущая компания:', currentCompany);
        } else {
            console.warn('⚠️ Компания не определена из URL или localStorage');
        }

        // Показать кнопки авторизации (определяем раньше, чтобы использовать ниже)
        function showAuthButtons() {
            const profileBtn = document.getElementById('profileBtn');
            const companiesBottomBtn = document.getElementById('companiesBottomBtn');
            const logoutBtn = document.getElementById('logoutBtn');
            
            console.log('🔧 showAuthButtons called', { 
                profileBtn: !!profileBtn, 
                companiesBottomBtn: !!companiesBottomBtn,
                logoutBtn: !!logoutBtn 
            });
            
            if (profileBtn) {
                profileBtn.style.display = 'flex';
            }
            if (companiesBottomBtn) {
                companiesBottomBtn.style.display = 'flex';
                console.log('✅ Нижняя кнопка компаний показана через showAuthButtons');
            }
            if (logoutBtn) {
                logoutBtn.style.display = 'flex';
            }
        }

        // Показываем кнопки авторизации сразу, если пользователь авторизован
        (function checkAuthButtons() {
            const userStr = localStorage.getItem('gantt-user');
            if (userStr) {
                // Функция для показа кнопок
                const tryShowButtons = () => {
                    const companiesBottomBtn = document.getElementById('companiesBottomBtn');
                    const profileBtn = document.getElementById('profileBtn');
                    const logoutBtn = document.getElementById('logoutBtn');
                    
                    if (companiesBottomBtn) {
                        companiesBottomBtn.style.display = 'flex';
                        companiesBottomBtn.style.visibility = 'visible';
                        companiesBottomBtn.style.opacity = '1';
                    }
                    if (profileBtn) {
                        profileBtn.style.display = 'flex';
                        profileBtn.style.visibility = 'visible';
                    }
                    if (logoutBtn) {
                        logoutBtn.style.display = 'flex';
                        logoutBtn.style.visibility = 'visible';
                    }
                };
                
                // Ждем загрузки DOM
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', function() {
                        tryShowButtons();
                        setTimeout(tryShowButtons, 100);
                        setTimeout(tryShowButtons, 500);
                    });
                } else {
                    tryShowButtons();
                    setTimeout(tryShowButtons, 100);
                    setTimeout(tryShowButtons, 500);
                }
            }
        })();
        
        // Принудительное сохранение при уходе со страницы
        window.addEventListener('beforeunload', function() {
            if (currentCompany && !isViewMode) {
                // Сбрасываем таймер и сохраняем сразу синхронно
                if (saveTimeout) {
                    clearTimeout(saveTimeout);
                    saveTimeout = null;
                }
                
                // Используем navigator.sendBeacon для надежного сохранения при закрытии страницы
                try {
                    const snapshot = createFullGanttSnapshot();
                    const companyParam = `?company=${currentCompany}`;
                    // sendBeacon требует FormData или Blob, но наш API ожидает JSON
                    // Поэтому используем обычный fetch с keepalive
                    fetch(`/api/gantt-state${companyParam}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(snapshot),
                        keepalive: true // Позволяет запросу завершиться даже после закрытия страницы
                    }).catch(e => console.error('Ошибка сохранения при уходе:', e));
                    console.log('💾 Запрос на сохранение отправлен при уходе');
                } catch (e) {
                    console.error('Ошибка сохранения при уходе:', e);
                }
            }
        });

        // ========== РЕЖИМ ДОСТУПА ==========
        // Проверяем режим из localStorage (edit или view)
        const ganttMode = localStorage.getItem('gantt-mode') || 'edit';
        const isViewMode = ganttMode === 'view';
        
        // Функция проверки возможности редактирования
        function canEdit() {
            if (isViewMode) {
                return false;
            }
            return true;
        }
        
        // Показываем индикатор режима просмотра и скрываем кнопку сохранения
        if (isViewMode) {
            document.body.classList.add('view-mode');
            document.addEventListener('DOMContentLoaded', function() {
                const style = document.createElement('style');
                style.textContent = `
                    body::after {
                        content: 'Режим просмотра';
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: rgba(100, 180, 255, 0.9);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: 600;
                        z-index: 10000;
                        box-shadow: 0 4px 15px rgba(100, 180, 255, 0.3);
                        pointer-events: none;
                    }
                `;
                document.head.appendChild(style);
            });
        }

        let projectData = [
            {
                stage: "Подготовка новой ветки ПО",
                control: "",
                task: "Создание базы данных ПО ICONA (серверная часть)",
                days: 14,
                substage: ""
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание структуры объекта (Excel)",
                days: 3,
                substage: "Подзадача 1"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание схем объекта",
                days: 3,
                substage: "Подзадача 2"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание паспорта объекта, Регистрация пользователей по ролям",
                days: 2,
                substage: "Подзадача 3"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Загрузка структуры и схем в ПО ICONA",
                days: 2,
                substage: "Подзадача 4"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Выполнение заливки локаций на схемах",
                days: 3,
                substage: "Подзадача 5"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание Тактического плана строительства (Классификатор СМР)",
                days: 11,
                substage: "Подзадача 6"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Расчет коэффициентов СТК",
                days: 10,
                substage: "Подзадача 7"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Локализация СТК (привязка СТК к локациям структуры объекта)",
                days: 3,
                substage: "Подзадача 8"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Наполнение базы подрядчиков и привязка подрядчика к цифровой модели",
                days: 3,
                substage: "Подзадача 9"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание Директивного и Рабочего ГПР",
                days: 17,
                substage: "Подзадача 10"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Проставление факта в ПО ICONA и использование отчетов (web, desktop и android версии)",
                days: 15,
                substage: "Контроль"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Общая структура статистического контроля по этапам",
                days: 2,
                substage: "Подзадача 1"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Настройка ICONA Статистический контроль (регистрация пользователей, настройка штрафов)",
                days: 2,
                substage: "Подзадача 2"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Создание графиков контроля",
                days: 1,
                substage: "Подзадача 3"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Процедура проведения статистического контроля на площадке (android)",
                days: 2,
                substage: "Подзадача 4"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Настройка и генерация доклада (ICONA автодоклад)",
                days: 3,
                substage: "Подзадача 5"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Подготовка к планерке и проведение планерки",
                days: 2,
                substage: "Подзадача 6"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Проведение конкретного контроля после планерки",
                days: 1,
                substage: "Подзадача 7"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Использование и редакция отчетов",
                days: 6,
                substage: "Подзадача 8"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Общая структура контроля ИСК и настройка прав доступа",
                days: 2,
                substage: "Подзадача 1"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Настройка процедур оценки качества СТК",
                days: 20,
                substage: "Подзадача 2"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Обучение подрядчиков ICONA Вызов технадзора (web интерфейс)",
                days: 10,
                substage: "Подзадача 3"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Процедура контроля ИСК на площадке (android)",
                days: 10,
                substage: "Подзадача 4"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Использование и редакция отчетов",
                days: 9,
                substage: "Подзадача 5"
            },
            {
                stage: "Этап 4. Приемка квартир",
                control: "ICONA Приемка квартир",
                task: "Общая структура приемки квартир и настройка прав доступа",
                days: 5,
                substage: "Подзадача 1"
            },
            {
                stage: "Этап 4. Приемка квартир",
                control: "ICONA Приемка квартир",
                task: "Обучение процедуре выполнения приемки квартир",
                days: 4,
                substage: "Подзадача 2"
            },
            {
                stage: "Этап 4. Приемка квартир",
                control: "ICONA Приемка квартир",
                task: "Использование и редакция отчетов",
                days: 3,
                substage: "Подзадача 3"
            }
        ];

        // Российские выходные и праздники
        const holidays = [
            "2025-01-01", "2025-01-02", "2025-01-03", "2025-01-04", "2025-01-05",
            "2025-01-06", "2025-01-07", "2025-01-08", "2025-02-23", "2025-03-08",
            "2025-05-01", "2025-05-09", "2025-06-12", "2025-11-04"
        ];

        const INITIAL_START_DATE = new Date(2025, 0, 9); // 9 января 2025 (дефолт для сброса)
        let startDate = new Date(INITIAL_START_DATE); // текущее начало проекта
        let tasks = [];
        // Счётчик для генерации уникальных id новых задач (поверх исходного массива)
        let nextTaskId = projectData.length;
        let currentView = 'gantt';
        // Стиль отображения баров в Ганте: 'dots' (как сейчас, точки/короткие отрезки)
        // или 'segments' (слитные полосы без покраски по отдельным дням)
        let ganttBarStyle = 'dots';
        // Флаг отображения колонки "Ответственный"
        let showResponsible = false;
        // Ожидающий применения статус, для которого нужен комментарий
        let pendingStatusForComment = null;
        let zoomLevel = 1; // 1 = 100%, влияет только на ширину колонок
        let viewStartDate = null; // если задано, используем как левую границу отображения
        let viewEndDate = null;   // если задано, используем как правую границу отображения
        let isExporting = false;  // специальный режим отрисовки для PDF
        let saveTimeout = null; // таймер для отложенного сохранения




        // Текущая ячейка, для которой открыто меню статуса
        let currentStatusTarget = null; // { taskId, dateStrs }
        // Координаты последнего клика для позиционирования модальных окон на мобильных
        let lastClickCoordinates = { x: 0, y: 0 };

        // Выделение задач (можно выделять несколько строк)
        let selectedTaskIds = new Set(); // множество id выделенных задач
        let lastSelectedTaskId = null;   // последняя "базовая" задача для Shift-выделения
        // Флаг и ссылка на модал удаления
        let isDeleteConfirmOpen = false;
        // Текущий фильтр по этапу: 'all' | 'Этап 1' | 'Этап 2' | ...
        let currentStageFilter = 'all';

        // Для модального удаления этапа
        let pendingStageToDelete = null;

        // Конфигурация этапов для вкладок и модального окна
        let stageConfig = [];
        let draggedStageIndex = null;

        function initializeStageConfig() {
            const numbers = new Set();
            projectData.forEach(item => {
                if (!item.stage) return;
                const match = item.stage.match(/^Этап\s+(\d+)/);
                if (match) {
                    numbers.add(parseInt(match[1], 10));
                }
            });
            stageConfig = Array.from(numbers)
                .sort((a, b) => a - b)
                .map(n => `Этап ${n}`);
        }

        initializeStageConfig();

        // Данные о компании (название и логотип)
        let companyName = '';
        let companyLogoData = null; // data URL (base64) или null

        // Текущие ширины колонок в левой части Ганта (в пикселях)
        let ganttColumnWidths = {
            label: 260,
            start: 120,
            end: 120,
            days: 90,
            responsible: 160
        };

        function formatDateForInput(date) {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        }

        function formatDateKey(date) {
            return formatDateForInput(date);
        }

        // --- Блок информации о компании ---

        function applyCompanyInfoToUI() {
            const logoEl = document.getElementById('companyLogo');
            const nameDisplay = document.getElementById('companyNameDisplay');

            if (logoEl) {
                if (companyLogoData) {
                    logoEl.src = companyLogoData;
                } else {
                    logoEl.src = 'favicon.png';
                }
            }

            if (nameDisplay) {
                if (companyName && companyName.trim().length > 0) {
                    // Используем innerText для правильного отображения текста в любой кодировке
                    nameDisplay.innerText = companyName;
                    nameDisplay.classList.add('has-value');
                } else {
                    const placeholder = nameDisplay.getAttribute('data-placeholder') || 'Введите название компании';
                    nameDisplay.innerText = placeholder;
                    nameDisplay.classList.remove('has-value');
                }
            }
        }

        function saveCompanyInfoLocally() {
            try {
                const payload = {
                    name: companyName,
                    logoData: companyLogoData
                };
                localStorage.setItem('iconaCompanyInfo', JSON.stringify(payload));
            } catch (e) {
                console.warn('Не удалось сохранить информацию о компании в localStorage:', e);
            }
        }

        async function saveCompanyInfoToServer() {
            try {
                const payload = {
                    name: companyName,
                    logoData: companyLogoData
                };
                const companyParam = currentCompany ? `?company=${currentCompany}` : '';
                await fetch(`/api/company-info${companyParam}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ...payload, company: currentCompany })
                });
            } catch (e) {
                // На локальной машине/без сервера просто игнорируем ошибку
                console.warn('Не удалось сохранить информацию о компании на сервере:', e);
            }
        }

        function handleCompanyNameInput(event) {
            if (!canEdit()) {
                event.preventDefault();
                return; // Блокируем редактирование названия компании в режиме просмотра
            }
            const raw = (event.target.innerText || event.target.textContent) || '';
            const placeholder = event.target.getAttribute('data-placeholder') || 'Введите название компании';

            // Если пользователь стёр всё — считаем, что названия нет и показываем плейсхолдер
            companyName = raw.trim() === '' || raw === placeholder ? '' : raw.trim();

            // Во время ввода не трогаем текст в DOM и каретку, только меняем класс
            if (companyName) {
                event.target.classList.add('has-value');
            } else {
                event.target.classList.remove('has-value');
            }

            saveCompanyInfoLocally();
            saveCompanyInfoToServer();
        }

        function handleCompanyNameFocus(event) {
            const el = event.target;
            const placeholder = el.getAttribute('data-placeholder') || 'Введите название компании';
            if (!el.classList.contains('has-value') && el.textContent === placeholder) {
                el.textContent = '';
            }
        }

        function handleCompanyLogoChange(event) {
            if (!canEdit()) {
                event.target.value = ''; // Сбрасываем выбор файла
                return; // Блокируем загрузку логотипа в режиме просмотра
            }
            const file = event.target.files && event.target.files[0];
            if (!file) return;

            if (file.type !== 'image/png') {
                alert('Пожалуйста, загрузите логотип в формате PNG.');
                return;
            }

            const reader = new FileReader();
            reader.onload = () => {
                companyLogoData = reader.result;
                applyCompanyInfoToUI();
                saveCompanyInfoLocally();
                saveCompanyInfoToServer();
            };
            reader.readAsDataURL(file);
        }

        async function loadCompanyInfo() {
            // 1. Пытаемся загрузить с сервера, если он есть
            try {
                const companyParam = currentCompany ? `?company=${currentCompany}` : '';
                const res = await fetch(`/api/company-info${companyParam}`);
                if (res.ok) {
                    const data = await res.json();
                    if (data && (data.name || data.logoData)) {
                        // Убеждаемся, что название компании правильно декодируется
                        companyName = data.name ? String(data.name) : '';
                        companyLogoData = data.logoData || null;
                        applyCompanyInfoToUI();
                        return;
                    }
                }
            } catch (e) {
                // если сервер недоступен — идём в localStorage
            }

            // 2. Фоллбек на localStorage
            try {
                const raw = localStorage.getItem('iconaCompanyInfo');
                if (raw) {
                    const stored = JSON.parse(raw);
                    // Убеждаемся, что название компании правильно декодируется
                    companyName = stored.name ? String(stored.name) : '';
                    companyLogoData = stored.logoData || null;
                }
            } catch (e) {
                console.warn('Не удалось загрузить информацию о компании из localStorage:', e);
            }

            applyCompanyInfoToUI();
        }

        // Перерисовать вкладки этапов на основе текущей конфигурации
        function renderStageTabs() {
            const container = document.querySelector('.stage-tabs-buttons');
            if (!container) return;

            container.innerHTML = '';

            const allBtn = document.createElement('button');
            allBtn.className = 'stage-tab-btn';
            allBtn.textContent = 'Все этапы';
            if (currentStageFilter === 'all') {
                allBtn.classList.add('active');
            }
            allBtn.addEventListener('click', () => {
                currentStageFilter = 'all';
                renderStageTabs();
                renderGantt();
                renderTable();
                applySelectionHighlight();
            });
            container.appendChild(allBtn);

            stageConfig.forEach(shortName => {
                const btn = document.createElement('button');
                btn.className = 'stage-tab-btn';
                btn.textContent = shortName;
                if (currentStageFilter === shortName) {
                    btn.classList.add('active');
                }
                btn.addEventListener('click', () => {
                    currentStageFilter = shortName;
                    renderStageTabs();
                    renderGantt();
                    renderTable();
                    applySelectionHighlight();
                });
                container.appendChild(btn);
            });
        }

        // Проверка, относится ли задача к текущему выбранному этапу
        function isTaskInCurrentStage(task) {
            if (currentStageFilter === 'all') return true;
            if (!task.stage) return false;
            return task.stage.startsWith(currentStageFilter);
        }

        function isTaskSelected(taskId) {
            return selectedTaskIds.has(taskId);
        }

        // Применить визуальное выделение к текущему набору выбранных задач
        function applySelectionHighlight() {
            document.querySelectorAll('.gantt-row').forEach(row => {
                if (!row.dataset.taskId) return;
                const idStr = row.dataset.taskId;
                const isSelected = selectedTaskIds.has(Number(idStr));
                row.classList.toggle('selected', isSelected);
            });

            const tbody = document.getElementById('tasksTableBody');
            if (tbody) {
                tbody.querySelectorAll('tr').forEach(tr => {
                    if (!tr.dataset.taskId) return;
                    const idStr = tr.dataset.taskId;
                    const isSelected = selectedTaskIds.has(Number(idStr));
                    tr.classList.toggle('selected', isSelected);
                });
            }
        }

        function clearSelection() {
            selectedTaskIds.clear();
            lastSelectedTaskId = null;
            applySelectionHighlight();
        }

        function getPrimarySelectedTaskId() {
            if (lastSelectedTaskId !== null && selectedTaskIds.has(lastSelectedTaskId)) {
                return lastSelectedTaskId;
            }
            const first = selectedTaskIds.values().next();
            return first.done ? null : first.value;
        }

        // Выбор задач по клику (поддержка Shift для диапазона)
        function selectTask(taskId, options = {}) {
            const { range = false } = options;

            if (range && lastSelectedTaskId !== null) {
                // Диапазон между lastSelectedTaskId и текущей задачей
                const startIndex = tasks.findIndex(t => t.id === lastSelectedTaskId);
                const endIndex = tasks.findIndex(t => t.id === taskId);
                if (startIndex === -1 || endIndex === -1) {
                    // если что-то пошло не так — просто обычное выделение
                    selectedTaskIds.clear();
                    selectedTaskIds.add(taskId);
                    lastSelectedTaskId = taskId;
                    applySelectionHighlight();
                    return;
                }
                selectedTaskIds.clear();
                const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];
                for (let i = from; i <= to; i++) {
                    selectedTaskIds.add(tasks[i].id);
                }
            } else {
                // Одиночный клик — выделяем только одну строку
                selectedTaskIds.clear();
                selectedTaskIds.add(taskId);
                lastSelectedTaskId = taskId;
            }

            applySelectionHighlight();
        }

        // Обработка клика по строке (Гант или таблица)
        function handleTaskRowClick(taskId, event) {
            if (event.shiftKey) {
                selectTask(taskId, { range: true });
            } else {
                selectTask(taskId, { range: false });
            }
        }

        // Функция для проверки рабочего дня
        function isWorkday(date) {
            const dayOfWeek = date.getDay();
            const dateStr = formatDateKey(date);
            return dayOfWeek !== 0 && dayOfWeek !== 6 && !holidays.includes(dateStr);
        }

        // Функция для получения дней для задачи
        function getTaskDates(startDate, workDays) {
            const dates = [];
            let currentDate = new Date(startDate);
            let daysAdded = 0;

            while (daysAdded < workDays) {
                if (isWorkday(currentDate)) {
                    dates.push(new Date(currentDate));
                    daysAdded++;
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }

            return dates;
        }

        // Получить рабочие дни между датами (включительно)
        function getWorkdaysBetween(start, end) {
            const dates = [];
            const current = new Date(start);
            const last = new Date(end);
            while (current <= last) {
                if (isWorkday(current)) {
                    dates.push(new Date(current));
                }
                current.setDate(current.getDate() + 1);
            }
            return dates;
        }

        // Получить рабочие дни, считая назад от конечной даты
        function getWorkdaysBackward(endDate, workDays) {
            const dates = [];
            const current = new Date(endDate);
            while (dates.length < workDays) {
                if (isWorkday(current)) {
                    dates.push(new Date(current));
                }
                current.setDate(current.getDate() - 1);
            }
            return dates.reverse();
        }

        function parseDateFromInput(value) {
            if (!value) return null;
            const [year, month, day] = value.split('-').map(Number);
            if (!year || !month || !day) return null;
            return new Date(year, month - 1, day);
        }

        // Флаг отображения директивного (baseline) плана в Ганте
        let showBaseline = false;
        // Последний сохранённый baseline-план (как пришёл с сервера или после F2)
        let baselineSnapshot = null;
        // Снапшот, ожидающий подтверждения перезаписи
        let pendingBaselineSnapshot = null;
        // Таймер для toast-сообщений
        let baselineToastTimer = null;

        // Инициализация задач
        function initializeTasks() {
            tasks = [];
            // Сбрасываем счётчик id (исходные задачи идут с 0..N-1)
            nextTaskId = projectData.length;
            let currentDate = new Date(startDate);

            projectData.forEach((item, index) => {
                const taskDates = getTaskDates(currentDate, item.days);
                const taskObj = {
                    id: index,
                    ...item,
                    startDate: taskDates[0],
                    endDate: taskDates[taskDates.length - 1],
                    dates: taskDates,
                    status: 'pending',
                    dateStatuses: {} // ключ: YYYY-MM-DD, значение: 'pending' | 'in-progress' | 'completed' | 'weekend-manual' | 'holiday-manual'
                };
                // Синхронизируем task и name для совместимости
                if (taskObj.task && !taskObj.name) {
                    taskObj.name = taskObj.task;
                } else if (taskObj.name && !taskObj.task) {
                    taskObj.task = taskObj.name;
                }
                tasks.push(taskObj);
                currentDate = new Date(taskDates[taskDates.length - 1]);
                currentDate.setDate(currentDate.getDate() + 1);
            });

            updateStatistics();
	    // лок начало: автосохранение
	    autoSaveGanttState();
	    // энд конец
            renderGantt();
            renderTable();
            applyCompanyInfoToUI();
            renderStageTabs();
        }

        // Применить сохранённый baseline-план к текущему массиву tasks
        function applyBaselineToTasks() {
            if (!baselineSnapshot || !Array.isArray(baselineSnapshot.tasks)) return;

            const byId = new Map();
            baselineSnapshot.tasks.forEach(b => {
                byId.set(b.id, b);
            });

            tasks.forEach(task => {
                const b = byId.get(task.id);
                if (!b || !Array.isArray(b.baselineDates) || !b.baselineDates.length) {
                    task.baselineDates = undefined;
                    task.baselineStartDate = undefined;
                    task.baselineEndDate = undefined;
                    return;
                }

                const parsedDates = b.baselineDates
                    .map(ds => parseDateFromInput(ds))
                    .filter(d => d instanceof Date && !isNaN(d.getTime()))
                    .sort((a, b) => a - b);

                if (!parsedDates.length) {
                    task.baselineDates = undefined;
                    task.baselineStartDate = undefined;
                    task.baselineEndDate = undefined;
                    return;
                }

                task.baselineDates = parsedDates;
                task.baselineStartDate = parsedDates[0];
                task.baselineEndDate = parsedDates[parsedDates.length - 1];
            });
        }

        // Построить snapshot директивного плана по текущему состоянию задач
        function buildBaselineSnapshot() {
            return {
                generatedAt: new Date().toISOString(),
                tasks: tasks.map(task => ({
                    id: task.id,
                    baselineDates: Array.isArray(task.dates)
                        ? task.dates.map(d => formatDateKey(d))
                        : []
                }))
            };
        }

        // Построить полный snapshot состояния графика со всеми данными
        function createFullGanttSnapshot() {
            return {
                version: '1.0',
                savedAt: new Date().toISOString(),
                startDate: startDate ? formatDateKey(startDate) : null,
                tasks: tasks.map(task => {
                    // Синхронизируем task и name перед сохранением
                    const taskName = task.task || task.name || '';
                    return {
                        id: task.id,
                        stage: task.stage || '',
                        substage: task.substage || '',
                        control: task.control || task.controlType || '', // Используем control, поддерживаем старый controlType
                        controlType: task.control || task.controlType || '', // Сохраняем также для обратной совместимости
                        name: taskName,
                        task: taskName, // Сохраняем также в поле task для обратной совместимости
                        days: task.days || 0,
                    startDate: task.startDate ? formatDateKey(task.startDate) : null,
                    endDate: task.endDate ? formatDateKey(task.endDate) : null,
                    dates: Array.isArray(task.dates) ? task.dates.map(d => formatDateKey(d)) : [],
                    status: task.status || 'pending',
                    dateStatuses: task.dateStatuses || {},
                    dateComments: task.dateComments || {},
                    responsible: task.responsible || '',
                    baselineDates: Array.isArray(task.baselineDates) ? task.baselineDates.map(d => formatDateKey(d)) : [],
                    baselineStartDate: task.baselineStartDate ? formatDateKey(task.baselineStartDate) : null,
                    baselineEndDate: task.baselineEndDate ? formatDateKey(task.baselineEndDate) : null
                    };
                }),
                settings: {
                    ganttBarStyle: ganttBarStyle || 'dots',
                    showResponsible: showResponsible || false,
                    zoomLevel: zoomLevel || 1
                }
            };
        }

        // Сохранить полное состояние графика на сервер
        async function saveFullGanttState() {
            try {
                if (!currentCompany) {
                    console.warn('⚠️ Компания не указана, сохранение пропущено. currentCompany:', currentCompany);
                    console.warn('⚠️ URL:', window.location.href);
                    console.warn('⚠️ localStorage gantt-company:', localStorage.getItem('gantt-company'));
                    return;
                }
                
                if (isViewMode) {
                    console.warn('⚠️ Режим просмотра, сохранение пропущено');
                    return;
                }
                
                const snapshot = createFullGanttSnapshot();
                const companyParam = `?company=${currentCompany}`;
                const url = `/api/gantt-state${companyParam}`;
                
                console.log('💾 Сохранение графика для компании:', currentCompany);
                console.log('📦 Размер данных:', JSON.stringify(snapshot).length, 'байт');
                console.log('🔗 URL запроса:', url);
                console.log('📊 Количество задач:', snapshot.tasks ? snapshot.tasks.length : 0);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(snapshot)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Ошибка HTTP:', response.status, response.statusText);
                    console.error('❌ Текст ошибки:', errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const responseData = await response.json();
                
                if (responseData && responseData.ok) {
                    console.log('✅ Полное состояние графика сохранено успешно');
                    console.log('✅ Ответ сервера:', responseData);
                    showSaveIndicator(true);
                } else {
                    console.error('❌ Сервер вернул ошибку:', responseData);
                    throw new Error(responseData.error || 'Неизвестная ошибка сохранения');
                }
            } catch (e) {
                console.error('❌ Ошибка при сохранении графика на сервере:', e);
                console.error('❌ Стек ошибки:', e.stack);
                showSaveIndicator(false);
                // Не показываем alert для каждого автосохранения, только логируем
                // alert('Ошибка сохранения: ' + e.message + '\n\nПроверьте консоль браузера для деталей.');
            }
        }

        // Функция для показа индикатора сохранения
        function showSaveIndicator(success) {
            const saveButton = document.getElementById('saveButton');
            const saveButtonText = document.getElementById('saveButtonText');
            
            if (!saveButton || !saveButtonText) return;
            
            if (success) {
                saveButton.classList.add('saving-success');
                saveButtonText.textContent = '✓ Сохранено';
                console.log('💾 Данные сохранены');
                
                // Возвращаем обратно через 2 секунды
                setTimeout(() => {
                    saveButton.classList.remove('saving-success');
                    saveButtonText.textContent = 'Сохранить';
                }, 2000);
            } else {
                saveButton.classList.add('saving-error');
                saveButtonText.textContent = '✗ Ошибка';
                
                setTimeout(() => {
                    saveButton.classList.remove('saving-error');
                    saveButtonText.textContent = 'Сохранить';
                }, 2000);
            }
        }

        // Принудительное сохранение по кнопке
        async function manualSaveGantt() {
            const saveButton = document.getElementById('saveButton');
            const saveButtonText = document.getElementById('saveButtonText');
            
            if (saveButton) {
                saveButton.disabled = true;
                if (saveButtonText) {
                    saveButtonText.textContent = 'Сохранение...';
                }
            }
            
            try {
                await saveFullGanttState();
                showSaveIndicator(true);
            } catch (error) {
                console.error('❌ Ошибка при ручном сохранении:', error);
                showSaveIndicator(false);
                alert('Ошибка сохранения: ' + error.message);
            } finally {
                if (saveButton) {
                    saveButton.disabled = false;
                }
            }
        }

        // Автоматическое сохранение с задержкой (debounce)
        function autoSaveGanttState() {
            console.log('🔄 autoSaveGanttState вызвана');
            console.log('   currentCompany:', currentCompany);
            console.log('   isViewMode:', isViewMode);
            console.log('   URL:', window.location.href);
            
            if (!currentCompany) {
                console.warn('⚠️ autoSaveGanttState: компания не определена, сохранение пропущено');
                console.warn('   Попытка получить из localStorage:', localStorage.getItem('gantt-company'));
                // Попытка восстановить из localStorage
                const savedCompany = localStorage.getItem('gantt-company');
                if (savedCompany) {
                    currentCompany = savedCompany;
                    console.log('✅ Компания восстановлена из localStorage:', currentCompany);
                } else {
                return;
                }
            }
            
            if (isViewMode) {
                console.warn('⚠️ autoSaveGanttState: режим просмотра, сохранение пропущено');
                return;
            }
            
            // Очищаем предыдущий таймер
            if (saveTimeout) {
                clearTimeout(saveTimeout);
                console.log('   Предыдущий таймер очищен');
            }
            
            console.log('⏱️ Запланировано автоматическое сохранение через 1 секунду');
            
            // Уменьшаем задержку до 1 секунды для более быстрого сохранения
            saveTimeout = setTimeout(() => {
                console.log('⏰ Таймер сработал, начинаем сохранение...');
                saveFullGanttState();
            }, 1000);
        }

        // Загрузить полное состояние графика с сервера
        async function loadFullGanttState() {
            try {
                if (!currentCompany) {
                    console.warn('Компания не указана, загрузка пропущена');
                    return false;
                }
                const companyParam = `?company=${currentCompany}`;
                const res = await fetch(`/api/gantt-state${companyParam}`);
                if (!res.ok) return false;
                const data = await res.json();
                if (!data || !data.tasks || !Array.isArray(data.tasks)) return false;

                // Проверяем версию данных (старый формат baseline или новый полный формат)
                const isFullFormat = data.version && data.version === '1.0';

                if (isFullFormat) {
                    // Восстанавливаем startDate проекта
                    if (data.startDate) {
                        const parts = data.startDate.split('-');
                        startDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                    }

                    // Восстанавливаем задачи
                    tasks = data.tasks.map(task => {
                        // Правильно восстанавливаем названия задач с обратной совместимостью
                        let taskName = '';
                        let taskNameField = '';
                        
                        // Приоритет: task.task > task.name > пустая строка
                        if (task.task) {
                            taskName = task.task;
                            taskNameField = task.task;
                        } else if (task.name) {
                            taskName = task.name;
                            taskNameField = task.name;
                        }
                        
                        // Синхронизируем оба поля
                        const taskObj = {
                            id: task.id,
                            stage: task.stage || '',
                            substage: task.substage || '',
                            control: task.control || task.controlType || '', // Поддержка старого названия controlType
                            name: taskName,
                            task: taskNameField,
                            days: task.days || 0,
                            status: task.status || 'pending',
                            dateStatuses: task.dateStatuses || {},
                            dateComments: task.dateComments || {},
                            responsible: task.responsible || '',
                            dates: [],
                            startDate: null,
                            endDate: null
                        };

                        // Восстанавливаем даты
                        if (task.dates && Array.isArray(task.dates)) {
                            taskObj.dates = task.dates.map(dateStr => {
                                const parts = dateStr.split('-');
                                return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                            });
                            if (taskObj.dates.length > 0) {
                                taskObj.startDate = taskObj.dates[0];
                                taskObj.endDate = taskObj.dates[taskObj.dates.length - 1];
                            }
                        }

                        // Восстанавливаем baseline данные
                        if (task.baselineDates && Array.isArray(task.baselineDates)) {
                            taskObj.baselineDates = task.baselineDates;
                        }
                        if (task.baselineStartDate) {
                            const parts = task.baselineStartDate.split('-');
                            taskObj.baselineStartDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                        }
                        if (task.baselineEndDate) {
                            const parts = task.baselineEndDate.split('-');
                            taskObj.baselineEndDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                        }

                        return taskObj;
                    });

                    // Восстанавливаем настройки
                    if (data.settings) {
                        if (data.settings.ganttBarStyle) ganttBarStyle = data.settings.ganttBarStyle;
                        if (data.settings.showResponsible !== undefined) showResponsible = data.settings.showResponsible;
                        if (data.settings.zoomLevel) zoomLevel = data.settings.zoomLevel;
                    }

                    // Обновляем счётчик ID
                    if (tasks.length > 0) {
                        nextTaskId = Math.max(...tasks.map(t => t.id)) + 1;
                    }

                    // Перерисовываем график и таблицу
                    updateStatistics();
                    renderGantt();
                    renderTable();
                    renderStageTabs();
                    autoSaveGanttState(); // Автоматическое сохранение после загрузки

                    console.log('✅ Полное состояние графика загружено');
                    return true;
                } else {
                    // Старый формат baseline - используем существующую логику
                    return false;
                }
            } catch (e) {
                console.warn('Не удалось загрузить полное состояние графика с сервера:', e);
                return false;
            }
        }

        // Сохранить baseline на сервер (без диалогов, просто best-effort)
        async function saveBaselineToServer(snapshot) {
            try {
                const companyParam = currentCompany ? `?company=${currentCompany}` : '';
                await fetch(`/api/gantt-state${companyParam}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(snapshot)
                });
            } catch (e) {
                console.warn('Не удалось сохранить директивный план на сервере:', e);
            }
        }

        // Загрузить baseline-план с сервера (если он есть)
        async function loadBaselineFromServer() {
            try {
                const companyParam = currentCompany ? `?company=${currentCompany}` : '';
                const res = await fetch(`/api/gantt-state${companyParam}`);
                if (!res.ok) return;
                const data = await res.json();
                if (!data || !Array.isArray(data.tasks)) return;
                baselineSnapshot = data;
                applyBaselineToTasks();
                // Обновляем состояние кнопки после загрузки
                updateBaselineToggleButton();
            } catch (e) {
                // тихо игнорируем, если сервер недоступен
                console.warn('Не удалось загрузить директивный план с сервера:', e);
            }
        }

        function showBaselineToast(message) {
            // Создаем элемент если его нет
            let el = document.getElementById('baselineToast');
            if (!el) {
                el = document.createElement('div');
                el.id = 'baselineToast';
                el.className = 'baseline-toast';
                document.body.appendChild(el);
                console.log('Baseline toast element created');
            }
            
            // Убеждаемся что элемент видим
            el.textContent = message;
            el.style.display = 'block';
            el.classList.add('visible');
            
            // Очищаем предыдущий таймер
            if (baselineToastTimer) {
                clearTimeout(baselineToastTimer);
            }
            
            // Скрываем через 3 секунды
            baselineToastTimer = setTimeout(() => {
                if (el) {
                    el.classList.remove('visible');
                    setTimeout(() => {
                        if (el && !el.classList.contains('visible')) {
                            el.style.display = 'none';
                        }
                    }, 300);
                }
            }, 3000);
            
            console.log('Baseline toast shown:', message);
        }

        // Функция для переключения отображения директивного плана (дублирует F3)
        function toggleBaselineDisplay() {
            const hasBaseline =
                baselineSnapshot &&
                Array.isArray(baselineSnapshot.tasks) &&
                baselineSnapshot.tasks.some(t => Array.isArray(t.baselineDates) && t.baselineDates.length > 0);

            if (!hasBaseline) {
                showBaselineToast('Базовый план не задан. Нажмите "Задать базовый план" или F2, чтобы сохранить текущий график как директивный.');
                return;
            }

            showBaseline = !showBaseline;
            updateBaselineToggleButton();
            renderGantt();
        }

        // Обновление состояния кнопки "Директивный план"
        function updateBaselineToggleButton() {
            const btn = document.getElementById('baselineToggleBtn');
            if (!btn) return;
            
            if (showBaseline) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }

        // Функция для установки базового плана (дублирует F2)
        function setBaselinePlan() {
            if (!canEdit()) {
                showBaselineToast('Режим просмотра: редактирование недоступно');
                return;
            }

            const newSnapshot = buildBaselineSnapshot();
            const hasExistingBaseline =
                baselineSnapshot &&
                Array.isArray(baselineSnapshot.tasks) &&
                baselineSnapshot.tasks.some(t => Array.isArray(t.baselineDates) && t.baselineDates.length > 0);

            console.log('setBaselinePlan called. hasExistingBaseline:', hasExistingBaseline, 'baselineSnapshot:', baselineSnapshot);

            if (hasExistingBaseline) {
                // Показываем модальное окно подтверждения перезаписи
                openBaselineConfirmModal(newSnapshot);
            } else {
                // Первое задание базового плана
                try {
                    baselineSnapshot = newSnapshot;
                    applyBaselineToTasks();
                    saveBaselineToServer(baselineSnapshot);
                    console.log('Calling showBaselineToast for first time from button');
                    // Показываем сообщение сразу
                    showBaselineToast('Вы задали базовый план. Нажмите "Директивный план" или F3 для отображения.');
                    // Обновляем состояние кнопки
                    updateBaselineToggleButton();
                } catch (error) {
                    console.error('Ошибка при сохранении базового плана:', error);
                    // Показываем сообщение даже при ошибке
                    showBaselineToast('Вы задали базовый план. Нажмите "Директивный план" или F3 для отображения.');
                    updateBaselineToggleButton();
                }
            }
        }

        function openBaselineConfirmModal(snapshotToApply) {
            const modal = document.getElementById('baselineConfirmModal');
            if (!modal) return;
            pendingBaselineSnapshot = snapshotToApply;
            modal.style.display = 'block';
        }

        function closeBaselineConfirmModal() {
            const modal = document.getElementById('baselineConfirmModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Модальное окно для ошибок валидации дат
        function openDateValidationModal(message) {
            const modal = document.getElementById('dateValidationModal');
            const msgEl = document.getElementById('dateValidationMessage');
            if (!modal || !msgEl) return;
            msgEl.textContent = message || 'Дата окончания не может быть раньше даты начала.';
            modal.style.display = 'block';
        }

        function closeDateValidationModal() {
            const modal = document.getElementById('dateValidationModal');
            if (!modal) return;
            modal.style.display = 'none';
        }

        function confirmBaselineOverwrite() {
            if (pendingBaselineSnapshot) {
                try {
                    baselineSnapshot = pendingBaselineSnapshot;
                    applyBaselineToTasks();
                    saveBaselineToServer(baselineSnapshot);
                    // Показываем сообщение сразу
                    showBaselineToast('Базовый план перезаписан. Нажмите "Директивный план" или F3 для отображения.');
                    // Обновляем состояние кнопки
                    updateBaselineToggleButton();
                } catch (error) {
                    console.error('Ошибка при перезаписи базового плана:', error);
                    // Показываем сообщение даже при ошибке
                    showBaselineToast('Базовый план перезаписан. Нажмите "Директивный план" или F3 для отображения.');
                    updateBaselineToggleButton();
                }
            }
            pendingBaselineSnapshot = null;
            closeBaselineConfirmModal();
        }

        function cancelBaselineOverwrite() {
            pendingBaselineSnapshot = null;
            closeBaselineConfirmModal();
        }

        // Обновление статистики
        function updateStatistics() {
            const stages = new Set(tasks.map(t => t.stage));
            document.getElementById('totalStages').textContent = stages.size;
            document.getElementById('totalTasks').textContent = tasks.length;
            
            const totalDays = tasks.reduce((sum, t) => sum + t.days, 0);
            document.getElementById('totalDays').textContent = totalDays;

            if (tasks.length > 0) {
                const lastTask = tasks[tasks.length - 1];
                const completionDate = new Date(lastTask.endDate);
                const options = { year: 'numeric', month: 'long', day: 'numeric' };
                document.getElementById('completionDate').textContent = 
                    completionDate.toLocaleDateString('ru-RU', options);
            }
        }

        // Вспомогательная функция: применить ширину к элементу колонки
        function applyColumnWidth(element, key) {
            if (!element || !ganttColumnWidths[key]) return;
            
            // Для колонки "Ответственный" CSS управляет шириной через анимацию
            // Не применяем инлайн-стили, чтобы не перезаписывать CSS анимацию
            if (key === 'responsible') {
                return;
            }
            
            const w = ganttColumnWidths[key];
            element.style.width = w + 'px';
            element.style.minWidth = w + 'px';
            element.style.maxWidth = w + 'px';
            element.style.flex = `0 0 ${w}px`;
        }

        // Инициализация ресайзера для колонки
        function addColumnResizer(element, key) {
            if (!element) return;
            element.classList.add('gantt-resizable');
            const resizer = document.createElement('div');
            resizer.className = 'gantt-resizer';
            resizer.dataset.columnKey = key;

            let startX = 0;
            let startWidth = 0;

            function onMouseMove(e) {
                const delta = e.clientX - startX;
                const newWidth = Math.max(80, Math.min(500, startWidth + delta));
                ganttColumnWidths[key] = newWidth;
                renderGantt();
            }

            function onMouseUp() {
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
            }

            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                startX = e.clientX;
                startWidth = ganttColumnWidths[key] || element.getBoundingClientRect().width;
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
            });

            element.appendChild(resizer);
        }

        // Отрисовка названия задачи в левой колонке (с поддержкой редактирования)
        function renderTaskLabelContent(labelElement, task, index) {
            labelElement.innerHTML = '';
            const span = document.createElement('span');
            const taskName = task.task || task.name || 'Без названия';
            span.title = taskName;
            const displayName = taskName.length > 40 ? taskName.substring(0, 40) + '...' : taskName;
            span.textContent = displayName;

            span.addEventListener('dblclick', () => {
                if (!canEdit()) {
                    return; // Блокируем редактирование в режиме просмотра
                }
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'gantt-task-input';
                input.value = task.task || task.name || '';

                labelElement.innerHTML = '';
                labelElement.appendChild(input);
                input.focus();
                input.select();

                const finish = (save) => {
                    if (save) {
                        const newName = input.value.trim();
                        if (newName) {
                            task.task = newName;
                            task.name = newName; // Синхронизируем оба поля
                        }
                    }
                    renderTaskLabelContent(labelElement, task, index);
                    renderTable();
                };

                input.addEventListener('blur', () => finish(true));
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        finish(false);
                    }
                });
            });

            labelElement.appendChild(span);
        }

        // Отрисовка диаграммы Ганта
        function renderGantt() {
            const chartContainer = document.getElementById('ganttChart');
            chartContainer.innerHTML = '';

            if (!tasks.length) return;

            // Определение полного диапазона дат проекта
            const projectFirstDate = new Date(tasks[0].startDate);
            const realLastTaskDate = new Date(tasks[tasks.length - 1].endDate);

            // Правый край проекта:
            //  - в обычном режиме: до конца следующего года (серый "хвост")
            //  - в режиме экспорта: только до последней задачи
            let projectLastDate;
            if (isExporting) {
                projectLastDate = new Date(realLastTaskDate);
            } else {
                projectLastDate = new Date(realLastTaskDate);
                const calendarEnd = new Date(realLastTaskDate.getFullYear() + 1, 11, 31); // 31 декабря следующего года
                if (calendarEnd > projectLastDate) {
                    projectLastDate = calendarEnd;
                }
            }

            // Видимый диапазон: либо весь проект, либо выбранный пользователем месяц
            const firstDate = viewStartDate ? new Date(viewStartDate) : projectFirstDate;
            const lastDate = viewEndDate ? new Date(viewEndDate) : projectLastDate;

            // Базовая плотность: пикселей на день (увеличивается с зумом)
            const pxPerDay = 4 * zoomLevel;

            // Режим шкалы по фактической плотности:
            //  - дни: когда день крупный (≈7px и больше)
            //  - недели: средний масштаб (≈3–7px на день)
            //  - месяцы: когда дни очень плотные (<3px на день)
            let scaleMode;
            if (pxPerDay >= 7) {
                scaleMode = 'day';
            } else if (pxPerDay >= 3) {
                scaleMode = 'week';
            } else {
                scaleMode = 'month';
            }

            // Формируем единицы времени для основной шкалы
            const timelineUnits = [];

            if (scaleMode === 'day') {
                // Каждый день отдельно
                let currentDate = new Date(firstDate);
                while (currentDate <= lastDate) {
                    timelineUnits.push({
                        type: 'day',
                        start: new Date(currentDate),
                        end: new Date(currentDate),
                        label: String(currentDate.getDate())
                    });
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            } else if (scaleMode === 'week') {
                // Недельные интервалы по 7 дней, привязанные к понедельнику (календарные недели)
                let weekStart = new Date(firstDate);
                // Перематываем к ближайшему понедельнику назад
                while (weekStart.getDay() !== 1) { // 1 = понедельник
                    weekStart.setDate(weekStart.getDate() - 1);
                }

                while (weekStart <= lastDate) {
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekEnd.getDate() + 6); // понедельник–воскресенье

                    const labelFrom = weekStart.getDate();
                    const labelTo = weekEnd.getDate();
                    const monthNameShort = weekStart.toLocaleDateString('ru-RU', { month: 'short' });

                    // Для недель, где обе даты однозначные (например, 3–9),
                    // добавляем пробелы вокруг тире: "3 - 9".
                    // Для 6–12, 20–26 и т.п. формат остаётся "6-12", "20-26".
                    const rangeCompact = `${labelFrom}-${labelTo}`;
                    const rangeWithSpaces = `${labelFrom} - ${labelTo}`;
                    const daysLabel = (labelFrom < 10 && labelTo < 10) ? rangeWithSpaces : rangeCompact;

                    timelineUnits.push({
                        type: 'week',
                        start: new Date(weekStart),
                        end: new Date(weekEnd),
                        label: `${daysLabel} ${monthNameShort}`,
                        daysLabel,
                        monthLabel: monthNameShort
                    });

                    weekStart.setDate(weekStart.getDate() + 7);
                }
            } else {
                // По месяцам
                let current = new Date(firstDate.getFullYear(), firstDate.getMonth(), 1);
                while (current <= lastDate) {
                    const y = current.getFullYear();
                    const m = current.getMonth();
                    const monthStart = new Date(y, m, 1);
                    let monthEnd = new Date(y, m + 1, 0);
                    if (monthStart < firstDate) monthStart.setTime(firstDate.getTime());
                    if (monthEnd > lastDate) monthEnd.setTime(lastDate.getTime());

                    const monthName = current.toLocaleDateString('ru-RU', { month: 'long' });

                    timelineUnits.push({
                        type: 'month',
                        start: monthStart,
                        end: monthEnd,
                        label: `${monthName} ${y}`
                    });

                    current.setMonth(current.getMonth() + 1);
                }
            }

            const msInDay = 24 * 60 * 60 * 1000;

            // Заголовок с основной шкалой
            const header = document.createElement('div');
            header.className = 'gantt-header';

            // Обертка для первой строки (label + details header)
            const headerFirstRow = document.createElement('div');
            headerFirstRow.className = 'gantt-header-first-row';
            headerFirstRow.style.display = 'flex';

            const headerLabel = document.createElement('div');
            headerLabel.className = 'gantt-header-label';
            headerLabel.textContent = 'Задача';
            applyColumnWidth(headerLabel, 'label');
            addColumnResizer(headerLabel, 'label');
            headerFirstRow.appendChild(headerLabel);

            // Заголовки для дополнительных колонок: даты и рабочие дни
            const detailsHeader = document.createElement('div');
            detailsHeader.className = 'gantt-details-header';
            detailsHeader.innerHTML = `
                <div class="gantt-details-cell">Дата начала</div>
                <div class="gantt-details-cell">Дата окончания</div>
                <div class="gantt-details-cell">Рабочих дней</div>
                <div class="gantt-details-cell responsible-cell">Ответственный</div>
            `;

            const headerCells = detailsHeader.querySelectorAll('.gantt-details-cell');
            if (headerCells[0]) {
                applyColumnWidth(headerCells[0], 'start');
                addColumnResizer(headerCells[0], 'start');
            }
            if (headerCells[1]) {
                applyColumnWidth(headerCells[1], 'end');
                addColumnResizer(headerCells[1], 'end');
            }
            if (headerCells[2]) {
                applyColumnWidth(headerCells[2], 'days');
            }
            if (headerCells[3]) {
                applyColumnWidth(headerCells[3], 'responsible');
            }

            headerFirstRow.appendChild(detailsHeader);
            header.appendChild(headerFirstRow);

            const datesRow = document.createElement('div');
            datesRow.className = 'gantt-header-dates-row';

            timelineUnits.forEach((unit, unitIdx) => {
                const cell = document.createElement('div');
                cell.className = 'gantt-header-cell';
                const unitDays = Math.round((unit.end - unit.start) / msInDay) + 1;
                const width = Math.max(30, unitDays * pxPerDay);
                cell.style.minWidth = width + 'px';
                cell.style.width = width + 'px';

                // Отрисовка подписи шкалы
                if (scaleMode === 'week' && unit.type === 'week' && unit.daysLabel && unit.monthLabel) {
                    const daysSpan = document.createElement('span');
                    daysSpan.className = 'gantt-header-week-days';
                    daysSpan.textContent = unit.daysLabel;

                    const monthSpan = document.createElement('span');
                    monthSpan.className = 'gantt-header-week-month';
                    monthSpan.textContent = unit.monthLabel;

                    cell.appendChild(daysSpan);
                    cell.appendChild(monthSpan);
                } else {
                    cell.textContent = unit.label;
                }

                const isFutureUnit = unit.start > realLastTaskDate;

                if (scaleMode === 'day') {
                    // Подсветка выходных и праздников только в дневном режиме
                    cell.title = unit.start.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    if (!isWorkday(unit.start)) {
                        const key = formatDateKey(unit.start);
                        cell.classList.add(holidays.includes(key) ? 'gantt-holiday' : 'gantt-weekend');
                    }
                } else if (scaleMode === 'week') {
                    const fromStr = unit.start.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    const toStr = unit.end.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    cell.title = `${fromStr} — ${toStr}`;
                } else {
                    const fromStr = unit.start.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    const toStr = unit.end.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    cell.title = `${fromStr} — ${toStr}`;
                }

                if (isFutureUnit) {
                    cell.classList.add('gantt-future-header');
                }

                // Клик по месяцу в режиме месяцев: зум до выбранного месяца
                if (scaleMode === 'month' && unit.type === 'month') {
                    cell.style.cursor = 'pointer';
                    cell.addEventListener('click', () => {
                        // показываем только выбранный месяц целиком
                        viewStartDate = new Date(unit.start.getFullYear(), unit.start.getMonth(), 1);
                        viewEndDate = new Date(unit.start.getFullYear(), unit.start.getMonth() + 1, 0);
                        // увеличиваем масштаб до дневного уровня
                        setZoom(2); // max зум → точно режим дней
                    });
                }

                datesRow.appendChild(cell);
            });

            header.appendChild(datesRow);

            chartContainer.appendChild(header);

            // Строки задач
            tasks.forEach((task, index) => {
                const row = document.createElement('div');
                row.className = 'gantt-row';
                row.dataset.taskId = String(task.id);

                // Статус строки относительно выбранного этапа
                if (currentStageFilter !== 'all') {
                    if (isTaskInCurrentStage(task)) {
                        row.classList.add('stage-active');
                    } else {
                        row.classList.add('inactive');
                    }
                }

                // Drag & drop поведение
                row.draggable = true;
                row.addEventListener('dragstart', (e) => {
                    draggingTaskId = task.id;
                    row.classList.add('dragging');
                    if (e.dataTransfer) {
                        e.dataTransfer.effectAllowed = 'move';
                    }
                });

                row.addEventListener('dragend', () => {
                    draggingTaskId = null;
                    row.classList.remove('dragging');
                    document.querySelectorAll('.gantt-row-drop-target').forEach(el => el.classList.remove('gantt-row-drop-target'));
                });

                const label = document.createElement('div');
                label.className = 'gantt-label';
                applyColumnWidth(label, 'label');
                renderTaskLabelContent(label, task, index);
                row.appendChild(label);

                // Дополнительные колонки "Дата начала / Дата окончания / Рабочих дней"
                const detailsRow = document.createElement('div');
                detailsRow.className = 'gantt-details-row';

                const startCell = document.createElement('div');
                startCell.className = 'gantt-details-cell';
                const startInput = document.createElement('input');
                startInput.type = 'date';
                startInput.className = 'gantt-details-input';
                startInput.value = task.startDate ? formatDateForInput(task.startDate) : '';
                startInput.setAttribute('data-index', index);
                startInput.setAttribute('data-field', 'startDate');
                startInput.addEventListener('change', onTaskTableInputChange);
                startCell.appendChild(startInput);
                applyColumnWidth(startCell, 'start');

                const endCell = document.createElement('div');
                endCell.className = 'gantt-details-cell';
                const endInput = document.createElement('input');
                endInput.type = 'date';
                endInput.className = 'gantt-details-input';
                endInput.value = task.endDate ? formatDateForInput(task.endDate) : '';
                endInput.setAttribute('data-index', index);
                endInput.setAttribute('data-field', 'endDate');
                endInput.addEventListener('change', onTaskTableInputChange);
                endCell.appendChild(endInput);
                applyColumnWidth(endCell, 'end');

                const daysCell = document.createElement('div');
                daysCell.className = 'gantt-details-cell';
                const daysInput = document.createElement('input');
                daysInput.type = 'number';
                daysInput.min = '0';
                daysInput.className = 'gantt-details-input';
                daysInput.value = task.days;
                daysInput.setAttribute('data-index', index);
                daysInput.setAttribute('data-field', 'days');
                daysInput.addEventListener('change', onTaskTableInputChange);
                daysCell.appendChild(daysInput);
                applyColumnWidth(daysCell, 'days');

                detailsRow.appendChild(startCell);
                detailsRow.appendChild(endCell);
                detailsRow.appendChild(daysCell);

                // Ячейка "Ответственный" всегда создается для анимации
                const respCell = document.createElement('div');
                respCell.className = 'gantt-details-cell responsible-cell';
                if (task.responsible) {
                    respCell.setAttribute('data-tooltip', task.responsible);
                }
                const respInput = document.createElement('input');
                respInput.type = 'text';
                respInput.className = 'gantt-details-input';
                respInput.value = task.responsible || '';
                respInput.setAttribute('data-index', index);
                respInput.setAttribute('data-field', 'responsible');
                respInput.addEventListener('change', onTaskTableInputChange);
                respCell.appendChild(respInput);
                applyColumnWidth(respCell, 'responsible');
                detailsRow.appendChild(respCell);
                row.appendChild(detailsRow);

            timelineUnits.forEach((unit, unitIdx) => {
                    const cell = document.createElement('div');
                    cell.className = 'gantt-cell';
                    const unitDays = Math.round((unit.end - unit.start) / msInDay) + 1;
                    const width = Math.max(30, unitDays * pxPerDay);
                    cell.style.minWidth = width + 'px';
                    cell.style.width = width + 'px';

                    const isFutureUnit = unit.start > realLastTaskDate;

                    // Проверяем, есть ли у задачи рабочие дни внутри текущей единицы времени
                    const unitDatesForTask = task.dates.filter(d => {
                        const time = d.getTime();
                        return time >= unit.start.getTime() && time <= unit.end.getTime();
                    });

                    const hasWorkInUnit = unitDatesForTask.length > 0;

                    if (hasWorkInUnit) {
                        // Для режима "точек" оставляем покраску по отдельным дням,
                        // для режима "полос" рисуем более широкие сегменты, но
                        // статус меняется уже только целиком по задаче.

                        const representativeDate = unitDatesForTask[0];
                        const repDateStr = formatDateKey(representativeDate);
                        const statusForDate = task.dateStatuses[repDateStr] || 'pending';

                        const bar = document.createElement('div');

                        // Подбираем класс оформления бара в зависимости от статуса
                        let barClasses = 'gantt-bar';
                        if (statusForDate === 'completed') {
                            barClasses += ' completed';
                        } else if (statusForDate === 'in-progress') {
                            barClasses += ' in-progress';
                        } else if (statusForDate === 'weekend-manual') {
                            barClasses += ' gantt-weekend';
                        } else if (statusForDate === 'holiday-manual') {
                            barClasses += ' gantt-holiday';
                        }
                        bar.className = barClasses;

                        // Если для этой даты есть комментарий, добавляем data-tooltip,
                        // чтобы при наведении отображалась подсказка с чёрным фоном.
                        if (task.dateComments && task.dateComments[repDateStr]) {
                            bar.setAttribute('data-tooltip', task.dateComments[repDateStr]);
                        }

                        // В режиме полос убираем символ и управляем скруглением/границами
                        if (ganttBarStyle === 'segments') {
                            bar.textContent = '';

                            // Определяем, есть ли дни задачи в соседних единицах времени,
                            // чтобы понять, начало это, середина или конец непрерывного отрезка.
                            const hasPrev = unitIdx > 0 && task.dates.some(d => {
                                const t = d.getTime();
                                const prev = timelineUnits[unitIdx - 1];
                                return t >= prev.start.getTime() && t <= prev.end.getTime();
                            });
                            const hasNext = unitIdx < timelineUnits.length - 1 && task.dates.some(d => {
                                const t = d.getTime();
                                const next = timelineUnits[unitIdx + 1];
                                return t >= next.start.getTime() && t <= next.end.getTime();
                            });

                            if (hasPrev && hasNext) {
                                bar.classList.add('segment-middle');
                            } else if (!hasPrev && hasNext) {
                                bar.classList.add('segment-start');
                            } else if (hasPrev && !hasNext) {
                                bar.classList.add('segment-end');
                            } else if (!hasPrev && !hasNext) {
                                // Одиночный сегмент — задача умещается в одну единицу времени,
                                // поэтому скругляем оба края.
                                bar.classList.add('segment-single');
                            }
                        } else {
                            bar.textContent = '■';
                        }

                        // Стандартный title отключаем, чтобы по наведению
                        // показывалась только чёрная подсказка-комментарий.
                        bar.title = '';

                        bar.style.cursor = 'pointer';
                        
                        // Функция для обработки клика/тапа
                        function handleBarClick(event, clientX, clientY) {
                            event.stopPropagation();
                            handleTaskRowClick(task.id, event);

                            if (!canEdit()) {
                                return; // Блокируем изменение статуса в режиме просмотра
                            }

                            const barElement = event.currentTarget || event.target;
                            const rect = barElement ? barElement.getBoundingClientRect() : null;
                            const fallbackX = rect ? rect.left + rect.width / 2 : window.innerWidth / 2;
                            const fallbackY = rect ? rect.top + rect.height / 2 : window.innerHeight / 2;
                            const clickX = typeof clientX === 'number' ? clientX : fallbackX;
                            const clickY = typeof clientY === 'number' ? clientY : fallbackY;

                            if (ganttBarStyle === 'segments') {
                                // Режим полос — меняем статус по всей задаче
                                const allDates = task.dates.map(d => formatDateKey(d));
                                openStatusMenu(clickX, clickY, task.id, allDates);
                            } else {
                                // Режим по дням — как раньше, только по текущему интервалу
                                const allDatesInUnit = unitDatesForTask.map(d => formatDateKey(d));
                                openStatusMenu(clickX, clickY, task.id, allDatesInUnit);
                            }
                        }
                        
                        // Обработчик клика (для десктопа)
                        bar.addEventListener('click', (event) => {
                            handleBarClick(event, event.clientX, event.clientY);
                        });
                        
                        // Обработчик touch (для мобильных)
                        bar.addEventListener('touchend', (event) => {
                            event.preventDefault();
                            const touch = event.changedTouches[0];
                            if (touch) {
                                handleBarClick(event, touch.clientX, touch.clientY);
                            }
                        });

                        cell.appendChild(bar);
                    }

                    // Отрисовка жёлтой полосы директивного плана (baseline) под текущим баром/ячейкой.
                    // ВАЖНО: baseline рисуем независимо от того, есть ли сейчас работа в этом интервале,
                    // чтобы было видно исходный план даже после сдвигов задач.
                    if (showBaseline && Array.isArray(task.baselineDates) && task.baselineDates.length) {
                        const unitStartTime = unit.start.getTime();
                        const unitEndTime = unit.end.getTime();
                        const hasBaselineInUnit = task.baselineDates.some(d => {
                            const t = d.getTime();
                            return t >= unitStartTime && t <= unitEndTime;
                        });

                        if (hasBaselineInUnit) {
                            const baselineBar = document.createElement('div');
                            baselineBar.className = 'baseline-bar';
                            cell.appendChild(baselineBar);
                        }
                    }

                    if (isFutureUnit) {
                        cell.classList.add('gantt-future-cell');
                    }

                    row.appendChild(cell);
                });

                // Обработка drag-over / drop для изменения порядка задач
                row.addEventListener('dragover', (e) => {
                    if (draggingTaskId === null || draggingTaskId === task.id) return;
                    e.preventDefault();
                    row.classList.add('gantt-row-drop-target');
                });

                row.addEventListener('dragleave', () => {
                    row.classList.remove('gantt-row-drop-target');
                });

                row.addEventListener('drop', (e) => {
                    if (!canEdit()) {
                        e.preventDefault();
                        return;
                    }
                    if (draggingTaskId === null || draggingTaskId === task.id) return;
                    e.preventDefault();
                    row.classList.remove('gantt-row-drop-target');

                    const fromIndex = tasks.findIndex(t => t.id === draggingTaskId);
                    const targetId = task.id;
                    if (fromIndex === -1) return;

                    const [moved] = tasks.splice(fromIndex, 1);
                    const targetIndex = tasks.findIndex(t => t.id === targetId);
                    let newIndex;
                    if (targetIndex === -1) {
                        // если не нашли, кладём в конец
                        tasks.push(moved);
                        newIndex = tasks.length - 1;
                    } else {
                        tasks.splice(targetIndex, 0, moved);
                        newIndex = targetIndex;
                    }

                    // Определяем, с какого места нужно пересчитать даты:
                    // берём минимальный индекс между старой и новой позицией
                    // и пересчитываем цепочку, начиная с этой задачи включительно
                    const startIndex = Math.min(fromIndex, newIndex);
                    recalculateDatesFrom(startIndex);

                    draggingTaskId = null;
                    updateStatistics();
                    renderGantt();
                    renderTable();
                });

                // Клик по строке Ганта — выбираем задачу (поддержка Shift)
                row.addEventListener('click', (event) => {
                    handleTaskRowClick(task.id, event);
                });

                chartContainer.appendChild(row);
            });

            // После перерисовки восстанавливаем подсветку выбранной строки (если была)
            applySelectionHighlight();
        }

        // Отрисовка таблицы
        function renderTable() {
            const tbody = document.getElementById('tasksTableBody');
            tbody.innerHTML = '';

            tasks.forEach((task, index) => {
                const row = document.createElement('tr');
                row.dataset.taskId = String(task.id);

                // Статус строки относительно выбранного этапа
                if (currentStageFilter !== 'all') {
                    if (isTaskInCurrentStage(task)) {
                        row.classList.add('stage-active');
                    } else {
                        row.classList.add('inactive');
                    }
                }
                const startStr = task.startDate ? formatDateForInput(task.startDate) : '';
                const endStr = task.endDate ? formatDateForInput(task.endDate) : '';

                // Разбираем этап на префикс "Этап N" и редактируемый хвост
                let stagePrefix = '';
                let stageSuffix = task.stage || '';
                const stageMatch = (task.stage || '').match(/^(Этап\s+\d+\.?\s*)(.*)$/);
                if (stageMatch) {
                    stagePrefix = stageMatch[1];
                    stageSuffix = stageMatch[2] || '';
                }

                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>
                        <span class="stage-prefix">${stagePrefix}</span>
                        <input type="text"
                               class="tasks-table-input"
                               data-index="${index}"
                               data-field="stageSuffix"
                               data-prefix="${stagePrefix}">
                    </td>
                    <td>
                        <input type="text"
                               class="tasks-table-input"
                               data-index="${index}"
                               data-field="control">
                    </td>
                    <td>
                        <input type="text"
                               class="tasks-table-input"
                               data-index="${index}"
                               data-field="taskTitle">
                    </td>
                    <td>
                        <input type="date"
                               class="tasks-table-input"
                               value="${startStr}"
                               data-index="${index}"
                               data-field="startDate">
                    </td>
                    <td>
                        <input type="date"
                               class="tasks-table-input"
                               value="${endStr}"
                               data-index="${index}"
                               data-field="endDate">
                    </td>
                    <td>
                        <input type="number"
                               class="tasks-table-input"
                               min="0"
                               value="${task.days}"
                               data-index="${index}"
                               data-field="days">
                    </td>
                    <td class="table-col-responsible" ${task.responsible ? `data-tooltip="${task.responsible.replace(/"/g, '&quot;')}"` : ''}>
                        <input type="text"
                               class="tasks-table-input"
                               value="${task.responsible || ''}"
                               data-index="${index}"
                               data-field="responsible">
                    </td>
                    <td>
                        <select class="tasks-table-input-select" data-index="${index}" data-field="status">
                            <option value="pending" ${task.status === 'pending' ? 'selected' : ''}>Запланирована</option>
                            <option value="in-progress" ${task.status === 'in-progress' ? 'selected' : ''}>В работе</option>
                            <option value="completed" ${task.status === 'completed' ? 'selected' : ''}>Завершено</option>
                        </select>
                    </td>
                `;

                // Подставляем текст названия задачи в input
                const titleInput = row.querySelector('input[data-field="taskTitle"]');
                if (titleInput) {
                    // Синхронизируем поля task и name
                    if (task.task && !task.name) {
                        task.name = task.task;
                    } else if (task.name && !task.task) {
                        task.task = task.name;
                    }
                    // Используем существующее название или пустую строку (не устанавливаем "Новая задача" автоматически)
                    titleInput.value = task.task || task.name || '';
                }

                // Поле этапа — редактируется только хвост после "Этап N."
                const stageInput = row.querySelector('input[data-field="stageSuffix"]');
                if (stageInput) {
                    stageInput.value = stageSuffix;
                }

                // Поле "Вид контроля" редактируется индивидуально для каждой задачи
                const controlInput = row.querySelector('input[data-field="control"]');
                if (controlInput) {
                    controlInput.value = task.control || '';
                }

                // Drag & drop для таблицы
                row.draggable = canEdit(); // Блокируем drag&drop в режиме просмотра
                row.addEventListener('dragstart', (e) => {
                    if (!canEdit()) {
                        e.preventDefault();
                        return;
                    }
                    draggingTaskId = task.id;
                    row.classList.add('dragging');
                    if (e.dataTransfer) {
                        e.dataTransfer.effectAllowed = 'move';
                    }
                });

                row.addEventListener('dragend', () => {
                    draggingTaskId = null;
                    row.classList.remove('dragging');
                    tbody.querySelectorAll('.table-row-drop-target').forEach(el => el.classList.remove('table-row-drop-target'));
                });

                row.addEventListener('dragover', (e) => {
                    if (draggingTaskId === null || draggingTaskId === task.id) return;
                    e.preventDefault();
                    row.classList.add('table-row-drop-target');
                });

                row.addEventListener('dragleave', () => {
                    row.classList.remove('table-row-drop-target');
                });

                row.addEventListener('drop', (e) => {
                    if (!canEdit()) {
                        e.preventDefault();
                        return;
                    }
                    if (draggingTaskId === null || draggingTaskId === task.id) return;
                    e.preventDefault();
                    row.classList.remove('table-row-drop-target');

                    const fromIndex = tasks.findIndex(t => t.id === draggingTaskId);
                    const targetId = task.id;
                    if (fromIndex === -1) return;

                    const [moved] = tasks.splice(fromIndex, 1);
                    const targetIndex = tasks.findIndex(t => t.id === targetId);
                    let newIndex;
                    if (targetIndex === -1) {
                        tasks.push(moved);
                        newIndex = tasks.length - 1;
                    } else {
                        tasks.splice(targetIndex, 0, moved);
                        newIndex = targetIndex;
                    }

                    const startIndex = Math.min(fromIndex, newIndex);
                    recalculateDatesFrom(startIndex);

                    draggingTaskId = null;
                    updateStatistics();
                    renderGantt();
                    renderTable();
                });

                // Клик по строке таблицы — выбор задачи и подсветка (поддержка Shift)
                row.addEventListener('click', (event) => {
                    handleTaskRowClick(task.id, event);
                });

                tbody.appendChild(row);
            });

            // После перерисовки восстанавливаем подсветку выбранной строки (если была)
            applySelectionHighlight();

            // Навешиваем обработчики изменений
            tbody.querySelectorAll('.tasks-table-input, .tasks-table-input-select').forEach(input => {
                input.addEventListener('change', onTaskTableInputChange);
            });
        }

        // Обработка изменения полей в детальной таблице
        function onTaskTableInputChange(event) {
            if (!canEdit()) {
                event.preventDefault();
                event.target.blur();
                return; // Блокируем редактирование в режиме просмотра
            }
            const input = event.target;
            const index = parseInt(input.getAttribute('data-index'), 10);
            const field = input.getAttribute('data-field');
            const task = tasks[index];
            if (!task) return;

            // Обновляем базовые поля
            if (field === 'taskTitle') {
                task.task = input.value || '';
                task.name = task.task; // Синхронизируем оба поля
            } else if (field === 'stageSuffix') {
                const oldStage = task.stage || '';
                const prefix = input.getAttribute('data-prefix') || '';
                const suffix = (input.value || '').trim();

                // Если есть известный префикс "Этап N", блокируем его изменение
                let newStage;
                if (prefix) {
                    newStage = suffix ? (prefix + ' ' + suffix) : prefix.trim();
                } else {
                    // Для нестандартных строк (без "Этап N") редактируем всё целиком
                    newStage = suffix;
                }

                // Групповое переименование: меняем название у всех задач
                // с тем же исходным этапом
                if (oldStage && oldStage !== newStage) {
                    tasks.forEach(t => {
                        if (t.stage === oldStage) {
                            t.stage = newStage;
                        }
                    });
                }
                task.stage = newStage;

                // Переинициализируем конфигурацию этапов и вкладки
                initializeStageConfig();
                renderStageTabs();
            } else if (field === 'control') {
                task.control = input.value || '';
            } else if (field === 'startDate') {
                task.startDate = parseDateFromInput(input.value);

                // Если уже есть дата окончания и она стала раньше даты начала — подтягиваем её вперёд
                if (task.startDate && task.endDate && task.endDate < task.startDate) {
                    task.endDate = new Date(task.startDate);
                    // Обновляем все связанные инпуты даты окончания (и в таблице, и в Ганте)
                    document
                        .querySelectorAll(`input[data-index="${index}"][data-field="endDate"]`)
                        .forEach(inp => {
                            inp.value = formatDateForInput(task.endDate);
                        });
                }
            } else if (field === 'endDate') {
                const newEnd = parseDateFromInput(input.value);

                // Правило: дата окончания не может быть раньше даты начала
                if (task.startDate && newEnd && newEnd < task.startDate) {
                    task.endDate = new Date(task.startDate);
                    input.value = formatDateForInput(task.endDate);
                    openDateValidationModal('Дата окончания не может быть раньше даты начала.');
                } else {
                    task.endDate = newEnd;
                }
            } else if (field === 'days') {
                const val = parseInt(input.value, 10);
                task.days = isNaN(val) || val < 0 ? 0 : val;
            } else if (field === 'responsible') {
                task.responsible = input.value || '';
                // Всегда показываем полное значение в data-tooltip на родительской <td> (таблица),
                // чтобы при переполнении можно было увидеть всех ответственных при наведении в едином стиле подсказок.
                const td = input.closest('.table-col-responsible');
                if (td) {
                    if (task.responsible) {
                        td.setAttribute('data-tooltip', task.responsible);
                    } else {
                        td.removeAttribute('data-tooltip');
                    }
                }
                // Также обновляем подсказку в Ганте (если колонка видна)
                const ganttRow = document.querySelector(`.gantt-row[data-task-id="${task.id}"]`);
                if (ganttRow) {
                    const ganttRespCell = ganttRow.querySelector('.gantt-details-cell input[data-field="responsible"]')?.parentElement;
                    if (ganttRespCell) {
                        if (task.responsible) {
                            ganttRespCell.setAttribute('data-tooltip', task.responsible);
                        } else {
                            ganttRespCell.removeAttribute('data-tooltip');
                        }
                    }
                }
            } else if (field === 'status') {
                const newStatus = input.value;
                task.status = newStatus;

                // Применяем статус ко всем датам задачи
                task.dateStatuses = {};
                if (newStatus === 'in-progress' || newStatus === 'completed') {
                    task.dates.forEach(d => {
                        const key = formatDateKey(d);
                        task.dateStatuses[key] = newStatus;
                    });
                }
            }

            // Пересчитываем даты задачи в зависимости от заполненных полей.
            // Логика:
            // - меняем дату начала → фиксируем days и пересчитываем дату конца;
            // - меняем дату окончания → фиксируем дату начала и пересчитываем days;
            // - меняем days → считаем от даты начала (если есть) или от даты конца.
            if (field === 'startDate') {
                if (task.startDate && task.days > 0) {
                    // Дата начала + рабочие дни → считаем дату конца
                    const dates = getTaskDates(task.startDate, task.days);
                    task.dates = dates;
                    task.startDate = dates[0];
                    task.endDate = dates[dates.length - 1];
                } else if (task.startDate && task.endDate) {
                    // Обе даты заданы → пересчитываем количество рабочих дней
                    const dates = getWorkdaysBetween(task.startDate, task.endDate);
                    task.dates = dates;
                    task.days = dates.length;
                }
            } else if (field === 'endDate') {
                if (task.startDate && task.endDate) {
                    // Фиксируем дату начала, двигаем только конец → считаем новые рабочие дни
                    const dates = getWorkdaysBetween(task.startDate, task.endDate);
                    task.dates = dates;
                    task.days = dates.length;
                } else if (task.endDate && task.days > 0) {
                    // Есть дата конца и количество рабочих дней → считаем дату начала назад
                    const dates = getWorkdaysBackward(task.endDate, task.days);
                    task.dates = dates;
                    task.startDate = dates[0];
                    task.endDate = dates[dates.length - 1];
                }
            } else if (field === 'days') {
                if (task.startDate && task.days > 0) {
                    // Есть дата начала и количество рабочих дней → считаем дату конца
                    const dates = getTaskDates(task.startDate, task.days);
                    task.dates = dates;
                    task.startDate = dates[0];
                    task.endDate = dates[dates.length - 1];
                } else if (task.endDate && task.days > 0) {
                    // Есть дата конца и количество рабочих дней → считаем дату начала назад
                    const dates = getWorkdaysBackward(task.endDate, task.days);
                    task.dates = dates;
                    task.startDate = dates[0];
                    task.endDate = dates[dates.length - 1];
                }
            }

            // При ручном редактировании дат/количества дней очищаем
            // покраску по дням, чтобы не путать пользователя (статус
            // по строке управляется отдельно через поле "status")
            if (field === 'startDate' || field === 'endDate' || field === 'days') {
                task.dateStatuses = {};
                if (task.status === 'in-progress' || task.status === 'completed') {
                    task.dates.forEach(d => {
                        const key = formatDateKey(d);
                        task.dateStatuses[key] = task.status;
                    });
                }
            }

            // Жёсткая последовательность: все последующие задачи
            // автоматически сдвигаются так, чтобы начинаться на следующий
            // рабочий день после окончания предыдущей, при этом своё
            // количество рабочих дней каждая задача сохраняет.
            recalculateFollowingTasks(index);

            // Обновляем значения в input полях сразу после пересчета
            // (до полного рендера, чтобы пользователь видел изменения сразу)
            const allInputs = document.querySelectorAll(`[data-index="${index}"]`);
            allInputs.forEach(inp => {
                const field = inp.getAttribute('data-field');
                if (field === 'startDate' && task.startDate) {
                    inp.value = formatDateForInput(task.startDate);
                } else if (field === 'endDate' && task.endDate) {
                    inp.value = formatDateForInput(task.endDate);
                } else if (field === 'days') {
                    inp.value = task.days;
                }
            });

            updateStatistics();
            // Всегда обновляем диаграмму Ганта, чтобы обновить input поля в ней
            renderGantt();
            renderTable();
            
            // Автоматическое сохранение после изменения задачи
            console.log('📝 Изменение задачи:', field, 'для задачи:', task.task || task.name);
            
            // Для критических полей (даты, статусы) сохраняем немедленно
            if (field === 'startDate' || field === 'endDate' || field === 'days' || field === 'status') {
                console.log('💾 Критическое изменение даты/статуса, сохраняем немедленно');
                saveFullGanttState(); // Сохраняем сразу
            } else {
                autoSaveGanttState(); // Для остальных полей - с задержкой
            }
        }

        // Пересчитать все задачи после указанного индекса в строгой последовательности
        function recalculateFollowingTasks(changedIndex) {
            for (let i = changedIndex + 1; i < tasks.length; i++) {
                const prevTask = tasks[i - 1];
                const task = tasks[i];
                if (!prevTask.endDate) continue;

                // Новый старт — следующий календарный день после конца предыдущей задачи
                const newStart = new Date(prevTask.endDate);
                newStart.setDate(newStart.getDate() + 1);

                // Пересчитываем только если реально меняется старт
                if (task.startDate && task.startDate.getTime() === newStart.getTime()) {
                    continue;
                }

                const dates = getTaskDates(newStart, task.days);
                task.dates = dates;
                task.startDate = dates[0];
                task.endDate = dates[dates.length - 1];

                // Сбрасываем индивидуальные статусы дат для сдвинутых задач
                task.dateStatuses = {};
            }
        }

        // Пересчитать даты задач начиная с указанного индекса (используется после drag&drop)
        function recalculateDatesFrom(startIndex) {
            if (startIndex < 0 || startIndex >= tasks.length) return;
	    autoSaveGanttState();
            let prevEnd = null;
            if (startIndex > 0) {
                const prevTask = tasks[startIndex - 1];
                if (!prevTask.endDate) return;
                prevEnd = new Date(prevTask.endDate);
            }

            for (let i = startIndex; i < tasks.length; i++) {
                const task = tasks[i];

                let newStart;
                if (prevEnd) {
                    newStart = new Date(prevEnd);
                    newStart.setDate(newStart.getDate() + 1);
                } else {
                    // Для первой задачи сохраняем её существующую дату начала
                    newStart = new Date(task.startDate);
                }

                const dates = getTaskDates(newStart, task.days);
                task.dates = dates;
                task.startDate = dates[0];
                task.endDate = dates[dates.length - 1];

                // После изменения цепочки сбрасываем покраску дат,
                // но если у задачи есть статус строки, перекидываем его на новые даты
                task.dateStatuses = {};
                if (task.status === 'in-progress' || task.status === 'completed') {
                    task.dates.forEach(d => {
                        const key = formatDateKey(d);
                        task.dateStatuses[key] = task.status;
                    });
                }

                prevEnd = task.endDate;
            }
        }

        // Вставка новой задачи под выбранной (Insert)
        function insertTaskBelowSelected() {
            if (!canEdit()) {
                return; // Блокируем добавление задач в режиме просмотра
            }
            const baseId = getPrimarySelectedTaskId();
            if (baseId === null) return;

            const index = tasks.findIndex(t => t.id === baseId);
            if (index === -1) return;

            const selectedTask = tasks[index];
            if (!selectedTask.endDate) return;

            // Дата начала новой задачи: следующий рабочий день после конца выбранной
            let newStart = new Date(selectedTask.endDate);
            do {
                newStart.setDate(newStart.getDate() + 1);
            } while (!isWorkday(newStart));

            const newDates = getTaskDates(newStart, 1); // длительность 1 рабочий день

            const newTask = {
                id: nextTaskId++,
                stage: selectedTask.stage,
                control: selectedTask.control,
                task: 'Новая задача',
                days: 1,
                substage: '',
                startDate: newDates[0],
                endDate: newDates[newDates.length - 1],
                dates: newDates,
                status: 'pending',
                dateStatuses: {}
            };

            // Вставляем новую задачу сразу после выбранной
            tasks.splice(index + 1, 0, newTask);

            // Пересчитываем все последующие задачи, чтобы они шли после новой
            recalculateFollowingTasks(index + 1);

            updateStatistics();
            renderGantt();
            renderTable();

            // Выделяем только что созданную строку
            selectTask(newTask.id);
	    autoSaveGanttState();
            autoSaveGanttState(); // Автоматическое сохранение после добавления задачи
        }

        // Удаление выбранных задач (Delete)
        function deleteSelectedTask() {
            if (!canEdit()) {
                return; // Блокируем удаление задач в режиме просмотра
            }
            if (!selectedTaskIds.size) return;

            // Получаем индексы всех выделенных задач
            const indices = [];
            tasks.forEach((t, idx) => {
                if (selectedTaskIds.has(t.id)) {
                    indices.push(idx);
                }
            });

            if (!indices.length) return;

            const firstIndex = Math.min(...indices);

            // Удаляем выделенные задачи с конца, чтобы не сбить индексы
            indices
                .sort((a, b) => b - a)
                .forEach(i => {
                    tasks.splice(i, 1);
                });

            selectedTaskIds.clear();
            lastSelectedTaskId = null;

            if (!tasks.length) {
                // Если задач не осталось — просто перерисовываем без пересчёта
                updateStatistics();
                renderGantt();
                renderTable();
                return;
            }

            // Пересчитываем цепочку дат начиная с позиции, где была первая удалённая задача
            const startIndex = Math.min(firstIndex, tasks.length - 1);
            if (startIndex === 0) {
                recalculateDatesFrom(0);
            } else {
                recalculateFollowingTasks(startIndex - 1);
            }
		autoSaveGanttState();

            // Ставим курсор на задачу, которая стала на место первой удалённой (если есть)
            const newIndex = Math.min(startIndex, tasks.length - 1);
            const newSelected = tasks[newIndex];
            if (newSelected) {
                selectedTaskIds.add(newSelected.id);
                lastSelectedTaskId = newSelected.id;
            }

            updateStatistics();
            renderGantt();
            renderTable();

            applySelectionHighlight();
            autoSaveGanttState(); // Автоматическое сохранение после удаления задачи
        }

        // Окно подтверждения удаления
        function openDeleteConfirm() {
            if (!selectedTaskIds.size) return;
            const modal = document.getElementById('deleteConfirmModal');
            if (!modal) return;
            modal.style.display = 'block';
            isDeleteConfirmOpen = true;
        }

        function cancelDeleteTask() {
            const modal = document.getElementById('deleteConfirmModal');
            if (modal) {
                modal.style.display = 'none';
            }
            isDeleteConfirmOpen = false;
        }

        function confirmDeleteTask() {
            deleteSelectedTask();
            cancelDeleteTask();
        }

// Асинхронная загрузка html2pdf.js библиотеки
let html2pdfLoaded = false;
let html2pdfLoading = false;

function loadHtml2Pdf() {
    return new Promise((resolve, reject) => {
        // Если уже загружена, сразу возвращаем
        if (html2pdfLoaded && typeof html2pdf !== 'undefined') {
            resolve();
            return;
        }
        
        // Если уже загружается, ждём
        if (html2pdfLoading) {
            const checkInterval = setInterval(() => {
                if (html2pdfLoaded && typeof html2pdf !== 'undefined') {
                    clearInterval(checkInterval);
                    resolve();
                }
            }, 100);
            return;
        }
        
        // Начинаем загрузку
        html2pdfLoading = true;
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js';
        script.async = true;
        script.onload = () => {
            html2pdfLoaded = true;
            html2pdfLoading = false;
            if (typeof html2pdf !== 'undefined') {
                resolve();
            } else {
                reject(new Error('html2pdf не загрузился'));
            }
        };
        script.onerror = () => {
            html2pdfLoading = false;
            reject(new Error('Не удалось загрузить html2pdf.js. Проверьте подключение к интернету.'));
        };
        
        // Устанавливаем таймаут 10 секунд
        setTimeout(() => {
            if (!html2pdfLoaded) {
                html2pdfLoading = false;
                script.remove();
                reject(new Error('Таймаут загрузки html2pdf.js'));
            }
        }, 10000);
        
        document.head.appendChild(script);
    });
}

// Экспорт в PDF: детальный Гант по выбранному масштабу + таблица задач с комментариями
async function exportPDF(scaleMode = 'day') {
    if (!tasks || !tasks.length) return;
    
    // Загружаем библиотеку html2pdf.js перед использованием
    try {
        await loadHtml2Pdf();
    } catch (error) {
        console.error('Ошибка загрузки html2pdf.js:', error);
        alert('Не удалось загрузить библиотеку для экспорта в PDF. Пожалуйста, проверьте подключение к интернету и попробуйте снова.');
        return;
    }
    
    if (typeof html2pdf === 'undefined') {
        alert('Библиотека html2pdf не доступна. Пожалуйста, обновите страницу и попробуйте снова.');
        return;
    }

    const logoEl = document.getElementById('companyLogo');
    const nameDisplay = document.getElementById('companyNameDisplay');

    // Контейнер для экспорта
    const exportWrapper = document.createElement('div');
    exportWrapper.style.padding = '16px';
    exportWrapper.style.background = '#ffffff';
    exportWrapper.style.fontFamily = window.getComputedStyle(document.body).fontFamily || 'sans-serif';
    exportWrapper.style.fontSize = '10px';
    exportWrapper.style.color = '#000';

    // Функция создания шапки с логотипом
    const createHeader = () => {
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.gap = '16px';
        header.style.marginBottom = '12px';

        if (logoEl) {
            const logoClone = logoEl.cloneNode(true);
            logoClone.style.width = '40px';
            logoClone.style.height = '40px';
            logoClone.style.borderRadius = '8px';
            logoClone.style.border = '1px solid #e0e0e0';
            logoClone.style.objectFit = 'contain';
            logoClone.style.background = '#fafafa';
            logoClone.style.padding = '4px';
            header.appendChild(logoClone);
        }

        const nameBlock = document.createElement('div');
        const title = document.createElement('div');
        title.textContent = 'График внедрения и обучения системы ICONA';
        title.style.fontSize = '14px';
        title.style.fontWeight = '600';

        const company = document.createElement('div');
        const currentNameText =
            nameDisplay && nameDisplay.classList.contains('has-value')
                ? (nameDisplay.innerText || nameDisplay.textContent)
                : '';
        company.innerText = currentNameText || 'Название компании';
        company.style.marginTop = '2px';
        company.style.fontSize = '12px';
        company.style.fontWeight = '600';

        nameBlock.appendChild(title);
        nameBlock.appendChild(company);
        header.appendChild(nameBlock);
        
        return header;
    };

    // --- Шапка ---
    exportWrapper.appendChild(createHeader());

    // --- Подготовка временной шкалы по выбранному масштабу ---
    const timelineUnits = buildExportTimeline(scaleMode);
    if (!timelineUnits.length) return;

    const scaleLabel = getExportScaleLabel(scaleMode);
    const ganttTitle = document.createElement('div');
    ganttTitle.textContent = `Диаграмма Ганта (${scaleLabel})`;
    ganttTitle.style.fontSize = '12px';
    ganttTitle.style.fontWeight = '600';
    ganttTitle.style.margin = '4px 0 6px 0';
    exportWrapper.appendChild(ganttTitle);

    // Функция для создания ячейки с границей
    const addCellBorder = (td) => {
        td.style.border = '1px solid #cccccc';
        td.style.padding = '2px 3px';
    };

    // Цвета статусов
    const statusColors = {
        pending: '#1e88e5',
        'in-progress': '#ff9800',
        completed: '#4caf50',
        'weekend-manual': '#ffe0e0',
        'holiday-manual': '#fff9c4'
    };

    // Разбиваем временную шкалу на чанки - НО НЕ РАЗБИВАЕМ НА СТРАНИЦЫ
    // Вместо этого просто создаём одну большую таблицу
    const unitsPerPage = scaleMode === 'day' ? 22 : scaleMode === 'week' ? 12 : 6;
    const chunks = [];
    for (let i = 0; i < timelineUnits.length; i += unitsPerPage) {
        chunks.push(timelineUnits.slice(i, i + unitsPerPage));
    }

    // Создаём таблицу для каждого чанка
    chunks.forEach((chunk, chunkIdx) => {
        if (chunkIdx > 0) {
            // Добавляем пустое пространство между чанками
            const spacer = document.createElement('div');
            spacer.style.height = '40px';
            exportWrapper.appendChild(spacer);
        }

        const ganttTable = document.createElement('table');
        ganttTable.style.borderCollapse = 'collapse';
        ganttTable.style.width = '100%';
        ganttTable.style.fontSize = '8px';
        ganttTable.style.marginBottom = '20px';

        // Заголовок таблицы
        const headerTr = document.createElement('tr');
        const baseHeaders = ['Задача', 'Ответственный', 'Дата начала', 'Дата окончания', 'Рабочих дней'];
        baseHeaders.forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            th.style.background = '#f5f5f5';
            th.style.color = '#222222';
            th.style.fontWeight = '600';
            th.style.fontSize = '8px';
            th.style.whiteSpace = 'nowrap';
            addCellBorder(th);
            headerTr.appendChild(th);
        });

        chunk.forEach(unit => {
            const th = document.createElement('th');
            th.textContent = unit.label;
            th.style.background = '#e3f2fd';
            th.style.color = '#222222';
            th.style.fontWeight = '600';
            th.style.fontSize = '7px';
            th.style.whiteSpace = 'nowrap';
            addCellBorder(th);
            headerTr.appendChild(th);
        });

        ganttTable.appendChild(headerTr);

        // Строки задач
        tasks.forEach(task => {
            const tr = document.createElement('tr');

            const baseValues = [
                task.task,
                task.responsible || '',
                task.startDate ? task.startDate.toLocaleDateString('ru-RU') : '',
                task.endDate ? task.endDate.toLocaleDateString('ru-RU') : '',
                task.days != null ? String(task.days) : ''
            ];

            baseValues.forEach((val, idx) => {
                const td = document.createElement('td');
                td.textContent = val;
                td.style.fontSize = '8px';
                if (idx === 0) td.style.whiteSpace = 'nowrap';
                addCellBorder(td);
                tr.appendChild(td);
            });

            const statuses = task.dateStatuses || {};

            chunk.forEach(unit => {
                const td = document.createElement('td');
                addCellBorder(td);

                const unitStart = unit.start.getTime();
                const unitEnd = unit.end.getTime();

                let hasWorkday = false;
                let intervalStatus = 'pending';

                if (Array.isArray(task.dates)) {
                    const daysInUnit = task.dates.filter(d => {
                        const t = d.getTime();
                        return t >= unitStart && t <= unitEnd;
                    });

                    if (daysInUnit.length > 0) {
                        hasWorkday = true;
                        if (scaleMode === 'day' && daysInUnit.length === 1) {
                            const key = formatDateKey(daysInUnit[0]);
                            intervalStatus = statuses[key] || 'pending';
                        } else {
                            const statusesInUnit = new Set();
                            daysInUnit.forEach(d => {
                                const key = formatDateKey(d);
                                const s = statuses[key];
                                if (s) statusesInUnit.add(s);
                            });
                            if (statusesInUnit.has('completed')) intervalStatus = 'completed';
                            else if (statusesInUnit.has('in-progress')) intervalStatus = 'in-progress';
                            else if (statusesInUnit.has('weekend-manual')) intervalStatus = 'weekend-manual';
                            else if (statusesInUnit.has('holiday-manual')) intervalStatus = 'holiday-manual';
                            else intervalStatus = 'pending';
                        }
                    }
                }

                if (hasWorkday) {
                    const color = statusColors[intervalStatus] || statusColors.pending;
                    td.style.background = color;
                }

                tr.appendChild(td);
            });

            ganttTable.appendChild(tr);
        });

        exportWrapper.appendChild(ganttTable);
    });

    // --- Разделитель перед детальной таблицей ---
    const separator = document.createElement('div');
    separator.style.height = '60px';
    exportWrapper.appendChild(separator);

    // --- Детальная таблица задач с комментариями ---
    const detailTitle = document.createElement('div');
    detailTitle.textContent = 'Детальная таблица задач';
    detailTitle.style.fontSize = '12px';
    detailTitle.style.fontWeight = '600';
    detailTitle.style.margin = '4px 0 6px 0';
    exportWrapper.appendChild(detailTitle);

    const detailTable = document.createElement('table');
    detailTable.style.borderCollapse = 'collapse';
    detailTable.style.width = '100%';

    // Заголовок таблицы
    const detailHeaderTr = document.createElement('tr');
    [
        '№ п/п',
        'Этап',
        'Вид контроля',
        'Мероприятие',
        'Рабочих дней',
        'Ответственный',
        'Дата начала',
        'Дата окончания',
        'Комментарии по датам'
    ].forEach(text => {
        const th = document.createElement('th');
        th.textContent = text;
        th.style.background = '#f5f5f5';
        th.style.color = '#222222';
        th.style.fontWeight = '600';
        th.style.fontSize = '9px';
        th.style.whiteSpace = 'nowrap';
        addCellBorder(th);
        detailHeaderTr.appendChild(th);
    });
    detailTable.appendChild(detailHeaderTr);

    // Строки задач
    tasks.forEach((task, idx) => {
        const tr = document.createElement('tr');

        let commentsSummary = '';
        if (task.dateComments) {
            const entries = Object.entries(task.dateComments)
                .filter(([, text]) => text && String(text).trim().length > 0)
                .sort(([d1], [d2]) => (d1 < d2 ? -1 : d1 > d2 ? 1 : 0))
                .map(([date, text]) => `${date}: ${String(text).trim()}`);
            commentsSummary = entries.join('; ');
        }

        const cells = [
            idx + 1,
            task.stage || '',
            task.control || '',
            task.task || '',
            task.days != null ? String(task.days) : '',
            task.responsible || '',
            task.startDate ? task.startDate.toLocaleDateString('ru-RU') : '',
            task.endDate ? task.endDate.toLocaleDateString('ru-RU') : '',
            commentsSummary
        ];

        cells.forEach((val, cellIdx) => {
            const td = document.createElement('td');
            td.textContent = val;
            td.style.fontSize = '9px';
            if (cellIdx === 3 || cellIdx === 8) {
                td.style.whiteSpace = 'normal';
            } else {
                td.style.whiteSpace = 'nowrap';
            }
            addCellBorder(td);
            tr.appendChild(td);
        });

        detailTable.appendChild(tr);
    });

    exportWrapper.appendChild(detailTable);

    // --- Генерация PDF ---
    
    // Показываем индикатор загрузки
    const loadingIndicator = document.createElement('div');
    loadingIndicator.textContent = 'Генерация PDF...';
    loadingIndicator.style.position = 'fixed';
    loadingIndicator.style.top = '50%';
    loadingIndicator.style.left = '50%';
    loadingIndicator.style.transform = 'translate(-50%, -50%)';
    loadingIndicator.style.padding = '20px 40px';
    loadingIndicator.style.background = 'rgba(0, 0, 0, 0.8)';
    loadingIndicator.style.color = '#fff';
    loadingIndicator.style.borderRadius = '8px';
    loadingIndicator.style.zIndex = '999999';
    loadingIndicator.style.fontSize = '16px';
    loadingIndicator.style.fontWeight = '600';
    document.body.appendChild(loadingIndicator);
    
    document.body.appendChild(exportWrapper);

    const opt = {
        margin: 10,
        filename: 'График_внедрения_ICONA.pdf',
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
            scale: 2,
            useCORS: true,
            logging: false
        },
        jsPDF: { 
            orientation: 'landscape', 
            unit: 'mm', 
            format: 'a3'
        }
    };

    html2pdf()
        .set(opt)
        .from(exportWrapper)
        .save()
        .then(() => {
            document.body.removeChild(exportWrapper);
            loadingIndicator.textContent = 'PDF готов!';
            setTimeout(() => {
                if (loadingIndicator.parentNode) {
                    document.body.removeChild(loadingIndicator);
                }
            }, 3000); // 3 секунды
        })
        .catch((err) => {
            console.error('Ошибка генерации PDF:', err);
            document.body.removeChild(exportWrapper);
            if (loadingIndicator.parentNode) {
                document.body.removeChild(loadingIndicator);
            }
            alert('Произошла ошибка при генерации PDF');
        });
}

        // Построение временной шкалы для экспорта в Excel (дни/недели/месяцы/годы)
        function buildExportTimeline(scaleMode) {
            if (!tasks.length) return [];

            const projectFirstDate = new Date(tasks[0].startDate);
            const realLastTaskDate = new Date(tasks[tasks.length - 1].endDate);
            const msInDay = 24 * 60 * 60 * 1000;

            const units = [];

            if (scaleMode === 'day') {
                let currentDate = new Date(projectFirstDate);
                while (currentDate <= realLastTaskDate) {
                    units.push({
                        type: 'day',
                        start: new Date(currentDate),
                        end: new Date(currentDate),
                        label: currentDate.toLocaleDateString('ru-RU')
                    });
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            } else if (scaleMode === 'week') {
                let weekStart = new Date(projectFirstDate);
                while (weekStart.getDay() !== 1) { // к ближайшему понедельнику назад
                    weekStart.setDate(weekStart.getDate() - 1);
                }
                while (weekStart <= realLastTaskDate) {
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekEnd.getDate() + 6);
                    const label = `${weekStart.toLocaleDateString('ru-RU')} — ${weekEnd.toLocaleDateString('ru-RU')}`;
                    units.push({
                        type: 'week',
                        start: new Date(weekStart),
                        end: new Date(weekEnd),
                        label
                    });
                    weekStart.setDate(weekStart.getDate() + 7);
                }
            } else if (scaleMode === 'month') {
                let current = new Date(projectFirstDate.getFullYear(), projectFirstDate.getMonth(), 1);
                while (current <= realLastTaskDate) {
                    const y = current.getFullYear();
                    const m = current.getMonth();
                    const monthStart = new Date(y, m, 1);
                    const monthEnd = new Date(y, m + 1, 0);
                    const label = current.toLocaleDateString('ru-RU', { month: 'long', year: 'numeric' });
                    units.push({
                        type: 'month',
                        start: monthStart,
                        end: monthEnd,
                        label
                    });
                    current.setMonth(current.getMonth() + 1);
                }
            } else if (scaleMode === 'year') {
                let currentYear = projectFirstDate.getFullYear();
                const lastYear = realLastTaskDate.getFullYear();
                while (currentYear <= lastYear) {
                    const yearStart = new Date(currentYear, 0, 1);
                    const yearEnd = new Date(currentYear, 11, 31);
                    units.push({
                        type: 'year',
                        start: yearStart,
                        end: yearEnd,
                        label: String(currentYear)
                    });
                    currentYear++;
                }
            }

            return units;
        }

        function getExportScaleLabel(scaleMode) {
            switch (scaleMode) {
                case 'day': return 'Гант (дни)';
                case 'week': return 'Гант (недели)';
                case 'month': return 'Гант (месяцы)';
                case 'year': return 'Гант (годы)';
                default: return 'Гант';
            }
        }

        // Подбор ширины столбцов под содержимое (приближённый авто‑подбор)
        function buildAutoColumnWidths(aoa) {
            if (!Array.isArray(aoa) || !aoa.length) return [];

            const colCount = aoa.reduce((max, row) => Math.max(max, row.length), 0);
            const maxLens = new Array(colCount).fill(0);

            aoa.forEach(row => {
                row.forEach((cell, colIdx) => {
                    if (cell === null || cell === undefined) return;
                    const text = String(cell);
                    if (text.length > maxLens[colIdx]) {
                        maxLens[colIdx] = text.length;
                    }
                });
            });

            return maxLens.map((len, idx) => {
                // Базовая ширина: первая колонка шире (задачи), остальные чуть уже
                const base = idx === 0 ? 20 : 8;
                const wch = Math.min(60, Math.max(base, len + 2));
                return { wch };
            });
        }

        // Экспорт в Excel
        function exportExcel() {
            // Показываем индикатор загрузки
            const loadingIndicator = document.createElement('div');
            loadingIndicator.textContent = 'Генерация Excel...';
            loadingIndicator.style.position = 'fixed';
            loadingIndicator.style.top = '50%';
            loadingIndicator.style.left = '50%';
            loadingIndicator.style.transform = 'translate(-50%, -50%)';
            loadingIndicator.style.padding = '20px 40px';
            loadingIndicator.style.background = 'rgba(0, 0, 0, 0.8)';
            loadingIndicator.style.color = '#fff';
            loadingIndicator.style.borderRadius = '8px';
            loadingIndicator.style.zIndex = '999999';
            loadingIndicator.style.fontSize = '16px';
            loadingIndicator.style.fontWeight = '600';
            document.body.appendChild(loadingIndicator);
            
            // Используем setTimeout чтобы индикатор успел отобразиться
            setTimeout(() => {
                try {
                    _exportExcelInternal(loadingIndicator);
                } catch (error) {
                    console.error('Ошибка экспорта Excel:', error);
                    if (loadingIndicator.parentNode) {
                        document.body.removeChild(loadingIndicator);
                    }
                    alert('Произошла ошибка при экспорте в Excel');
                }
            }, 100);
        }
        
        // Внутренняя функция экспорта
        function _exportExcelInternal(loadingIndicator) {
            // Если библиотека XLSX не загрузилась (например, нет интернета к CDN),
            // делаем простой экспорт в CSV, который Excel спокойно открывает.
            if (typeof XLSX === 'undefined') {
                try {
                    const selectEl = document.getElementById('excelScaleMode');
                    const rawMode = selectEl ? String(selectEl.value || '').toLowerCase() : 'day';
                    let scaleMode = 'day';
                    if (rawMode.startsWith('week') || rawMode.startsWith('нед')) scaleMode = 'week';
                    else if (rawMode.startsWith('month') || rawMode.startsWith('мес')) scaleMode = 'month';
                    else if (rawMode.startsWith('year') || rawMode.startsWith('год')) scaleMode = 'year';

                    const timelineUnits = buildExportTimeline(scaleMode);

                    let csv = '\uFEFF';

                    // Блок 1: Гант
                    if (timelineUnits.length) {
                        csv += '"' + getExportScaleLabel(scaleMode).replace(/"/g, '""') + '"\n';

                        const ganttHeader = ['Задача', 'Дата начала', 'Дата окончания', 'Рабочих дней'];
                        timelineUnits.forEach(unit => {
                            ganttHeader.push(unit.label);
                        });
                        csv += '"' + ganttHeader.map(v => String(v).replace(/"/g, '""')).join('";"') + '"\n';

                        tasks.forEach(task => {
                            const rowBase = [
                                task.task,
                                task.startDate ? task.startDate.toLocaleDateString('ru-RU') : '',
                                task.endDate ? task.endDate.toLocaleDateString('ru-RU') : '',
                                task.days
                            ];

                            const row = rowBase.map(v => String(v).replace(/"/g, '""'));

                            timelineUnits.forEach(unit => {
                                if (!task.startDate || !task.endDate || !Array.isArray(task.dates)) {
                                    row.push('');
                                    return;
                                }

                                const unitStart = unit.start.getTime();
                                const unitEnd = unit.end.getTime();
                                const hasWorkdayInUnit = task.dates.some(d => {
                                    const t = d.getTime();
                                    return t >= unitStart && t <= unitEnd;
                                });

                                row.push(hasWorkdayInUnit ? '■' : '');
                            });

                            csv += '"' + row.join('";"') + '"\n';
                        });

                        csv += '\n\n';
                    }

                    // Блок 2: Таблица задач как есть
                    csv += '"Таблица задач"\n';
                    csv += '"№ п/п";"Этап";"Вид контроля";"Мероприятие";"Рабочих дней";"Ответственный";"Дата начала";"Дата окончания"\n';
                    tasks.forEach((task, index) => {
                        const row = [
                            index + 1,
                            task.stage,
                            task.control,
                            task.task,
                            task.days,
                            task.responsible || '',
                            task.startDate.toLocaleDateString('ru-RU'),
                            task.endDate.toLocaleDateString('ru-RU')
                        ].map(value => String(value).replace(/"/g, '""'));
                        csv += '"' + row.join('";"') + '"\n';
                    });

                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'График_внедрения_ICONA.csv';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Закрываем индикатор
                    loadingIndicator.textContent = 'CSV готов!';
                    setTimeout(() => {
                        if (loadingIndicator.parentNode) {
                            document.body.removeChild(loadingIndicator);
                        }
                    }, 3000); // 3 секунды
                } catch (e) {
                    if (loadingIndicator.parentNode) {
                        document.body.removeChild(loadingIndicator);
                    }
                    alert('Не удалось выгрузить файл. Попробуйте ещё раз или откройте страницу с интернетом для полноценного Excel-экспорта.');
                }
                return;
            }

            const wb = XLSX.utils.book_new();

            const selectEl = document.getElementById('excelScaleMode');
            const rawMode = selectEl ? String(selectEl.value || '').toLowerCase() : 'day';
            let scaleMode = 'day';
            if (rawMode.startsWith('week') || rawMode.startsWith('нед')) scaleMode = 'week';
            else if (rawMode.startsWith('month') || rawMode.startsWith('мес')) scaleMode = 'month';
            else if (rawMode.startsWith('year') || rawMode.startsWith('год')) scaleMode = 'year';

            const timelineUnits = buildExportTimeline(scaleMode);

            // Лист 1: Гант в выбранном масштабе
            if (timelineUnits.length) {
                const ganttSheetName = getExportScaleLabel(scaleMode);
                const ganttData = [];

                const headerRow = ['Задача', 'Дата начала', 'Дата окончания', 'Рабочих дней'];
                timelineUnits.forEach(unit => {
                    headerRow.push(unit.label);
                });
                ganttData.push(headerRow);

                tasks.forEach(task => {
                    const row = [
                        task.task,
                        task.startDate ? task.startDate.toLocaleDateString('ru-RU') : '',
                        task.endDate ? task.endDate.toLocaleDateString('ru-RU') : '',
                        task.days
                    ];

                    timelineUnits.forEach(unit => {
                        if (!task.startDate || !task.endDate || !Array.isArray(task.dates)) {
                            row.push('');
                            return;
                        }

                        const unitStart = unit.start.getTime();
                        const unitEnd = unit.end.getTime();
                        const hasWorkdayInUnit = task.dates.some(d => {
                            const t = d.getTime();
                            return t >= unitStart && t <= unitEnd;
                        });

                        row.push(hasWorkdayInUnit ? '■' : '');
                    });

                    ganttData.push(row);
                });

                const ganttWs = XLSX.utils.aoa_to_sheet(ganttData);
                // Авто‑подбор ширины столбцов под содержимое
                const ganttCols = buildAutoColumnWidths(ganttData);
                // Столбцы с датами начала и окончания (индексы 1 и 2) фиксируем в ширину 10
                if (ganttCols[1]) ganttCols[1].wch = 10;
                if (ganttCols[2]) ganttCols[2].wch = 10;
                ganttWs['!cols'] = ganttCols;

                // Закрашиваем ячейки интервалов Ганта цветом в зависимости от статуса задачи.
                // Колонки интервалов начинаются с индекса 4 (0-based) — после базовых полей.
                const ganttStartCol = 4;

                // Цвета, соответствующие цветам на странице:
                // синий (план), оранжевый (в работе), зелёный (завершено),
                // розовый (ручной выходной), жёлтый (ручной праздник).
                const fillStyles = {
                    pending: {
                        patternType: 'solid',
                        fgColor: { rgb: 'FF1E88E5' },
                        bgColor: { rgb: 'FF1E88E5' }
                    },
                    'in-progress': {
                        patternType: 'solid',
                        fgColor: { rgb: 'FFFF9800' },
                        bgColor: { rgb: 'FFFF9800' }
                    },
                    completed: {
                        patternType: 'solid',
                        fgColor: { rgb: 'FF4CAF50' },
                        bgColor: { rgb: 'FF4CAF50' }
                    },
                    'weekend-manual': {
                        patternType: 'solid',
                        fgColor: { rgb: 'FFFFE0E0' },
                        bgColor: { rgb: 'FFFFE0E0' }
                    },
                    'holiday-manual': {
                        patternType: 'solid',
                        fgColor: { rgb: 'FFFFF9C4' },
                        bgColor: { rgb: 'FFFFF9C4' }
                    }
                };

                tasks.forEach((task, taskIdx) => {
                    // В ganttData первая строка (r=0) — заголовок,
                    // далее идут строки задач (r=1 + taskIdx)
                    const excelRow = 1 + taskIdx;
                    timelineUnits.forEach((unit, unitIdx) => {
                        const col = ganttStartCol + unitIdx;
                        const addr = XLSX.utils.encode_cell({ c: col, r: excelRow });
                        const cell = ganttWs[addr];
                        if (!cell || !cell.v) return; // пропускаем пустые ячейки

                        // Определяем статус для данного интервала времени.
                        // Если масштаб = "дни" — строго по конкретным дням, как на Ганте:
                        // берём первый рабочий день интервала и его статус в dateStatuses
                        // (или "pending", если статуса нет). Общий статус задачи не используем.
                        let intervalStatus = 'pending';
                        const unitStart = unit.start.getTime();
                        const unitEnd = unit.end.getTime();

                        if (scaleMode === 'day') {
                            if (Array.isArray(task.dates) && task.dates.length) {
                                const day = task.dates.find(d => {
                                    const t = d.getTime();
                                    return t >= unitStart && t <= unitEnd;
                                });
                                if (day) {
                                    const key = formatDateKey(day);
                                    if (task.dateStatuses && task.dateStatuses[key]) {
                                        intervalStatus = task.dateStatuses[key];
                                    } else {
                                        intervalStatus = 'pending';
                                    }
                                }
                            }
                        } else if (task.dateStatuses) {
                            // Для недель/месяцев/годов агрегируем статусы в интервале
                            const statusesInUnit = new Set();
                            task.dates.forEach(d => {
                                const t = d.getTime();
                                if (t < unitStart || t > unitEnd) return;
                                const key = formatDateKey(d);
                                const s = task.dateStatuses[key];
                                if (s) statusesInUnit.add(s);
                            });

                            // Приоритет: завершено > в работе > выходной > праздник > план
                            if (statusesInUnit.has('completed')) intervalStatus = 'completed';
                            else if (statusesInUnit.has('in-progress')) intervalStatus = 'in-progress';
                            else if (statusesInUnit.has('weekend-manual')) intervalStatus = 'weekend-manual';
                            else if (statusesInUnit.has('holiday-manual')) intervalStatus = 'holiday-manual';
                            else if (task.status) intervalStatus = task.status;
                            else intervalStatus = 'pending';
                        } else if (task.status) {
                            intervalStatus = task.status;
                        }

                        // Собираем комментарии по датам внутри текущего интервала времени
                        let commentsLines = [];
                        if (task.dateComments) {
                            task.dates.forEach(d => {
                                const t = d.getTime();
                                if (t < unitStart || t > unitEnd) return;
                                const key = formatDateKey(d);
                                const comment = task.dateComments[key];
                                if (comment && comment.trim().length > 0) {
                                    commentsLines.push(`${key}: ${comment.trim()}`);
                                }
                            });
                        }

                        const fill = fillStyles[intervalStatus] || fillStyles.pending;
                        cell.s = cell.s || {};
                        cell.s.fill = fill;
                        cell.s.alignment = cell.s.alignment || { horizontal: 'center', vertical: 'center' };

                        // Если есть комментарии по датам для этого интервала — добавляем их
                        // как комментарий Excel (note), чтобы были видны при наведении в Excel.
                        if (commentsLines.length > 0) {
                            const noteText = commentsLines.join('\n');
                            cell.c = cell.c || [];
                            cell.c.push({ t: noteText });
                        }
                    });
                });

                XLSX.utils.book_append_sheet(wb, ganttWs, ganttSheetName);
            }

            // Лист 2: таблица задач как есть
            const wsData = [
                ['График внедрения и обучения системы ICONA'],
                [],
                ['№ п/п', 'Этап', 'Вид контроля', 'Мероприятие', 'Рабочих дней', 'Ответственный', 'Дата начала', 'Дата окончания', 'Комментарии по датам']
            ];

            tasks.forEach((task, index) => {
                let commentsSummary = '';
                if (task.dateComments) {
                    const entries = Object.entries(task.dateComments)
                        .filter(([, text]) => text && String(text).trim().length > 0)
                        .sort(([d1], [d2]) => (d1 < d2 ? -1 : d1 > d2 ? 1 : 0))
                        .map(([date, text]) => `${date}: ${String(text).trim()}`);
                    commentsSummary = entries.join('; ');
                }

                wsData.push([
                    index + 1,
                    task.stage,
                    task.control,
                    task.task,
                    task.days,
                    task.responsible || '',
                    task.startDate.toLocaleDateString('ru-RU'),
                    task.endDate.toLocaleDateString('ru-RU'),
                    commentsSummary
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(wsData);
            // Авто‑подбор ширины столбцов для табличного листа
            const wsCols = buildAutoColumnWidths(wsData);
            // Столбцы "Дата начала" и "Дата окончания" (индексы 6 и 7) фиксируем в ширину 10
            if (wsCols[6]) wsCols[6].wch = 10;
            if (wsCols[7]) wsCols[7].wch = 10;
            ws['!cols'] = wsCols;

            XLSX.utils.book_append_sheet(wb, ws, 'Задачи');

            // Лист со статистикой
            XLSX.writeFile(wb, 'График_внедрения_ICONA.xlsx');
            
            // Закрываем индикатор
            loadingIndicator.textContent = 'Excel готов!';
            setTimeout(() => {
                if (loadingIndicator.parentNode) {
                    document.body.removeChild(loadingIndicator);
                }
            }, 3000); // 3 секунды
        }

        function openExcelExportModal() {
            const modal = document.getElementById('excelExportModal');
            if (modal) {
                modal.style.display = 'block';
                
                // На мобильных устройствах и планшетах позиционируем модальное окно рядом с кнопкой
                const isMobile = window.innerWidth <= 1024;
                if (isMobile) {
                    // Используем requestAnimationFrame для применения стилей после рендера
                    requestAnimationFrame(() => {
                        // Находим кнопку "Выгрузить в Excel"
                        const buttons = document.querySelectorAll('.btn');
                        let excelButton = null;
                        for (let btn of buttons) {
                            if (btn.textContent && btn.textContent.includes('Выгрузить в Excel')) {
                                excelButton = btn;
                                break;
                            }
                        }
                        
                        if (excelButton) {
                            const modalContent = modal.querySelector('.modal-content');
                            if (modalContent) {
                                const buttonRect = excelButton.getBoundingClientRect();
                                
                                // Позиционируем модальное окно так, чтобы оно было видно рядом с кнопкой
                                // Вычисляем позицию: если кнопка в нижней половине экрана - показываем над ней, иначе - под ней
                                const viewportHeight = window.innerHeight;
                                const buttonBottom = buttonRect.bottom;
                                const spaceBelow = viewportHeight - buttonBottom;
                                const spaceAbove = buttonRect.top;
                                
                                // Вычисляем позицию относительно viewport (так как modal имеет position: fixed)
                                let topPosition;
                                if (spaceBelow < 300 && spaceAbove > spaceBelow) {
                                    // Показываем над кнопкой
                                    topPosition = buttonRect.top - 350; // высота модального окна примерно 350px
                                } else {
                                    // Показываем под кнопкой
                                    topPosition = buttonRect.bottom + 20; // небольшой отступ
                                }
                                
                                // Убеждаемся, что окно не выходит за пределы экрана
                                const minTop = 20;
                                const maxTop = viewportHeight - 400;
                                topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                                
                                // Применяем стили с !important через setProperty для переопределения CSS
                                modalContent.style.setProperty('position', 'absolute', 'important');
                                modalContent.style.setProperty('top', topPosition + 'px', 'important');
                                modalContent.style.setProperty('left', '50%', 'important');
                                modalContent.style.setProperty('transform', 'translateX(-50%)', 'important');
                                modalContent.style.setProperty('margin', '0', 'important');
                                modalContent.style.setProperty('width', 'calc(100% - 40px)', 'important');
                                modalContent.style.setProperty('max-width', '500px', 'important');
                            }
                        }
                    });
                } else {
                    // На десктопе сбрасываем стили (используется стандартное центрирование через CSS)
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.position = '';
                        modalContent.style.top = '';
                        modalContent.style.left = '';
                        modalContent.style.transform = '';
                        modalContent.style.margin = '';
                        modalContent.style.width = '';
                        modalContent.style.maxWidth = '';
                    }
                }
            }
        }

        function closeExcelExportModal() {
            const modal = document.getElementById('excelExportModal');
            if (modal) {
                modal.style.display = 'none';
                // Сбрасываем стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
        }

        function confirmExcelExport() {
            closeExcelExportModal();
            exportExcel();
        }

        function openPDFExportModal() {
            const modal = document.getElementById('pdfExportModal');
            if (modal) {
                modal.style.display = 'block';
                
                // На мобильных устройствах и планшетах позиционируем модальное окно рядом с кнопкой
                const isMobile = window.innerWidth <= 1024;
                if (isMobile) {
                    // Используем requestAnimationFrame для применения стилей после рендера
                    requestAnimationFrame(() => {
                        // Находим кнопку "Выгрузить в PDF"
                        const buttons = document.querySelectorAll('.btn');
                        let pdfButton = null;
                        for (let btn of buttons) {
                            if (btn.textContent && btn.textContent.includes('Выгрузить в PDF')) {
                                pdfButton = btn;
                                break;
                            }
                        }
                        
                        if (pdfButton) {
                            const modalContent = modal.querySelector('.modal-content');
                            if (modalContent) {
                                const buttonRect = pdfButton.getBoundingClientRect();
                                
                                // Позиционируем модальное окно так, чтобы оно было видно рядом с кнопкой
                                // Вычисляем позицию: если кнопка в нижней половине экрана - показываем над ней, иначе - под ней
                                const viewportHeight = window.innerHeight;
                                const buttonBottom = buttonRect.bottom;
                                const spaceBelow = viewportHeight - buttonBottom;
                                const spaceAbove = buttonRect.top;
                                
                                // Вычисляем позицию относительно viewport (так как modal имеет position: fixed)
                                let topPosition;
                                if (spaceBelow < 300 && spaceAbove > spaceBelow) {
                                    // Показываем над кнопкой
                                    topPosition = buttonRect.top - 350; // высота модального окна примерно 350px
                                } else {
                                    // Показываем под кнопкой
                                    topPosition = buttonRect.bottom + 20; // небольшой отступ
                                }
                                
                                // Убеждаемся, что окно не выходит за пределы экрана
                                const minTop = 20;
                                const maxTop = viewportHeight - 400;
                                topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                                
                                // Применяем стили с !important через setProperty для переопределения CSS
                                modalContent.style.setProperty('position', 'absolute', 'important');
                                modalContent.style.setProperty('top', topPosition + 'px', 'important');
                                modalContent.style.setProperty('left', '50%', 'important');
                                modalContent.style.setProperty('transform', 'translateX(-50%)', 'important');
                                modalContent.style.setProperty('margin', '0', 'important');
                                modalContent.style.setProperty('width', 'calc(100% - 40px)', 'important');
                                modalContent.style.setProperty('max-width', '500px', 'important');
                            }
                        }
                    });
                } else {
                    // На десктопе сбрасываем стили (используется стандартное центрирование через CSS)
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.position = '';
                        modalContent.style.top = '';
                        modalContent.style.left = '';
                        modalContent.style.transform = '';
                        modalContent.style.margin = '';
                        modalContent.style.width = '';
                        modalContent.style.maxWidth = '';
                    }
                }
            }
        }

        function closePDFExportModal() {
            const modal = document.getElementById('pdfExportModal');
            if (modal) {
                modal.style.display = 'none';
                // Сбрасываем стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
        }

        function confirmPDFExport() {
            const selectEl = document.getElementById('pdfScaleMode');
            const rawMode = selectEl ? String(selectEl.value || '').toLowerCase() : 'day';
            let scaleMode = 'day';
            if (rawMode.startsWith('week') || rawMode.startsWith('нед')) scaleMode = 'week';
            else if (rawMode.startsWith('month') || rawMode.startsWith('мес')) scaleMode = 'month';
            closePDFExportModal();
            exportPDF(scaleMode);
        }

        // Изменение даты начала
        function editStartDate() {
            const modal = document.getElementById('editModal');
            const input = document.getElementById('startDateInput');
            input.value = formatDateForInput(startDate);
            modal.style.display = 'block';
        }

        function updateStartDate() {
            const input = document.getElementById('startDateInput');
            const newDate = parseDateFromInput(input.value);
            
            if (isWorkday(newDate)) {
                startDate = newDate;
                initializeTasks();
                closeModal();
            } else {
                alert('Пожалуйста, выберите рабочий день');
            }
        }

        function closeModal() {
            document.getElementById('editModal').style.display = 'none';
        }

        // Открыть модальное окно подтверждения сброса плана
        function resetSchedule() {
            if (!canEdit()) {
                return; // Блокируем сброс плана в режиме просмотра
            }
            const modal = document.getElementById('resetPlanConfirmModal');
            if (modal) {
                modal.style.display = 'block';
                
                // На мобильных устройствах и планшетах позиционируем модальное окно рядом с кнопкой
                const isMobile = window.innerWidth <= 1024;
                if (isMobile) {
                    // Используем requestAnimationFrame для применения стилей после рендера
                    requestAnimationFrame(() => {
                        // Находим кнопку "Сбросить план"
                        const resetButton = document.querySelector('.reset-plan-btn');
                        
                        if (resetButton) {
                            const modalContent = modal.querySelector('.modal-content');
                            if (modalContent) {
                                const buttonRect = resetButton.getBoundingClientRect();
                                
                                // Позиционируем модальное окно так, чтобы оно было видно рядом с кнопкой
                                // Вычисляем позицию: если кнопка в нижней половине экрана - показываем над ней, иначе - под ней
                                const viewportHeight = window.innerHeight;
                                const buttonBottom = buttonRect.bottom;
                                const spaceBelow = viewportHeight - buttonBottom;
                                const spaceAbove = buttonRect.top;
                                
                                // Вычисляем позицию относительно viewport (так как modal имеет position: fixed)
                                let topPosition;
                                if (spaceBelow < 300 && spaceAbove > spaceBelow) {
                                    // Показываем над кнопкой
                                    topPosition = buttonRect.top - 250; // высота модального окна примерно 250px
                                } else {
                                    // Показываем под кнопкой
                                    topPosition = buttonRect.bottom + 20; // небольшой отступ
                                }
                                
                                // Убеждаемся, что окно не выходит за пределы экрана
                                const minTop = 20;
                                const maxTop = viewportHeight - 300;
                                topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                                
                                // Применяем стили с !important через setProperty для переопределения CSS
                                modalContent.style.setProperty('position', 'absolute', 'important');
                                modalContent.style.setProperty('top', topPosition + 'px', 'important');
                                modalContent.style.setProperty('left', '50%', 'important');
                                modalContent.style.setProperty('transform', 'translateX(-50%)', 'important');
                                modalContent.style.setProperty('margin', '0', 'important');
                                modalContent.style.setProperty('width', 'calc(100% - 40px)', 'important');
                                modalContent.style.setProperty('max-width', '500px', 'important');
                            }
                        }
                    });
                } else {
                    // На десктопе сбрасываем стили (используется стандартное центрирование через CSS)
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.position = '';
                        modalContent.style.top = '';
                        modalContent.style.left = '';
                        modalContent.style.transform = '';
                        modalContent.style.margin = '';
                        modalContent.style.width = '';
                        modalContent.style.maxWidth = '';
                    }
                }
            }
        }

        // Закрыть модальное окно подтверждения сброса плана
        function cancelResetPlan() {
            const modal = document.getElementById('resetPlanConfirmModal');
            if (modal) {
                modal.style.display = 'none';
                // Сбрасываем стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
        }

        // Подтвердить сброс плана к дефолтному состоянию
        function confirmResetPlan() {
            if (!canEdit()) {
                return; // Блокируем сброс плана в режиме просмотра
            }
            startDate = new Date(INITIAL_START_DATE);
            initializeTasks();
            renderGantt();
            renderTable();
            updateStatistics();
            autoSaveGanttState(); // Автоматическое сохранение после сброса
            cancelResetPlan(); // Закрываем модальное окно
        }

        function toggleView() {
            currentView = currentView === 'gantt' ? 'table' : 'gantt';
            updateViewToggleUI();
            updateViewPanelsUI();
        }

        // Переключение режима отображения баров в Ганте: точки по дням / слитные полосы
        function toggleResponsibleColumn() {
            showResponsible = !showResponsible;

            const btn = document.getElementById('responsibleToggleBtn');
            if (btn) {
                if (showResponsible) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }

            // Управляем классом на body для отображения/скрытия колонки в таблице
            if (showResponsible) {
                document.body.classList.add('show-responsible');
            } else {
                document.body.classList.remove('show-responsible');
            }

            renderGantt();
            renderTable();
        }

        function toggleGanttBarStyle() {
            ganttBarStyle = ganttBarStyle === 'dots' ? 'segments' : 'dots';

            const btn = document.getElementById('ganttStyleToggleBtn');
            if (btn) {
                const labelSpan = btn.querySelector('span');
                if (ganttBarStyle === 'segments') {
                    // Активирован общий вид (сплошные полосы)
                    btn.classList.add('active');
                    if (labelSpan) labelSpan.textContent = 'Общий вид';
                } else {
                    // Детальный вид по дням — неактивное состояние кнопки
                    btn.classList.remove('active');
                    if (labelSpan) labelSpan.textContent = 'Детальный вид';
                }
            }

            // Переключаем класс на body, чтобы применились специальные стили для полос.
            // Не используем второй аргумент у classList.toggle для совместимости с более старыми браузерами.
            if (ganttBarStyle === 'segments') {
                document.body.classList.add('gantt-style-segments');
            } else {
                document.body.classList.remove('gantt-style-segments');
            }

            renderGantt();
        }

        function updateViewToggleUI() {
            const ganttPart = document.querySelector('.view-toggle-gantt');
            const tablePart = document.querySelector('.view-toggle-table');
            if (!ganttPart || !tablePart) return;

            if (currentView === 'gantt') {
                ganttPart.classList.add('active');
                tablePart.classList.remove('active');
            } else {
                ganttPart.classList.remove('active');
                tablePart.classList.add('active');
            }
        }

        function updateViewPanelsUI() {
            const chartContainer = document.querySelector('.chart-container');
            const tableSection = document.querySelector('.table-section');
            if (!chartContainer || !tableSection) return;

            if (currentView === 'gantt') {
                // Сначала показываем Гант сразу, чтобы не было моргания
                chartContainer.classList.remove('view-hidden');
                chartContainer.classList.add('view-active');
                
                // Затем скрываем таблицу
                tableSection.classList.remove('view-active');
                tableSection.classList.add('view-hidden');
            } else {
                // Сначала показываем таблицу сразу, чтобы не было моргания
                tableSection.classList.remove('view-hidden');
                tableSection.classList.add('view-active');
                
                // Затем скрываем Гант
                chartContainer.classList.remove('view-active');
                chartContainer.classList.add('view-hidden');
            }
        }

        // --- Настройка этапов ---

        function openStageSettingsModal() {
            buildStageSettingsList();
            const modal = document.getElementById('stageSettingsModal');
            if (modal) {
                modal.style.display = 'block';
            }
        }

        function closeStageSettingsModal() {
            const modal = document.getElementById('stageSettingsModal');
            if (modal) {
                modal.style.display = 'none';
            }

            // При выходе из режима редактирования этапов всегда включаем "Все этапы"
            currentStageFilter = 'all';
            renderStageTabs();
            renderGantt();
            renderTable();
            applySelectionHighlight();
        }

        function openStageDeleteModal(shortName) {
            pendingStageToDelete = shortName;
            const modal = document.getElementById('stageDeleteModal');
            const text = document.getElementById('stageDeleteText');
            if (text && shortName) {
                text.textContent = `Вы действительно хотите удалить этап "${shortName}" со всеми его задачами?`;
            }
            if (modal) {
                modal.style.display = 'block';
            }
        }

        function openStatusCommentModal() {
            const modal = document.getElementById('statusCommentModal');
            const input = document.getElementById('statusCommentInput');
            if (!modal || !input || !pendingStatusForComment) return;
            // Прячем меню, но не сбрасываем currentStatusTarget,
            // чтобы после ввода комментария статус применился к нужным датам.
            const menu = document.getElementById('statusMenu');
            if (menu) {
                menu.style.display = 'none';
            }
            // Сохраняем текущую цель статуса в отдельный снапшот,
            // чтобы применить её даже если currentStatusTarget где-то обнулится.
            window.__statusCommentTargetSnapshot = currentStatusTarget ? {
                taskId: currentStatusTarget.taskId,
                dateStrs: Array.isArray(currentStatusTarget.dateStrs)
                    ? [...currentStatusTarget.dateStrs]
                    : [currentStatusTarget.dateStrs]
            } : null;
            input.value = '';
            modal.style.display = 'block';
            
            // На мобильных устройствах позиционируем модальное окно рядом с точкой клика
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    const x = lastClickCoordinates.x;
                    const y = lastClickCoordinates.y;
                    
                    // Вычисляем позицию: если точка в нижней половине экрана - показываем над ней, иначе - под ней
                    const viewportHeight = window.innerHeight;
                    const viewportWidth = window.innerWidth;
                    const modalRect = modalContent.getBoundingClientRect();
                    const spaceBelow = viewportHeight - y;
                    const spaceAbove = y;
                    
                    let topPosition;
                    if (spaceBelow < 300 && spaceAbove > spaceBelow) {
                        // Показываем над точкой клика
                        topPosition = y - modalRect.height - 20;
                    } else {
                        // Показываем под точкой клика
                        topPosition = y + 20;
                    }
                    
                    // Убеждаемся, что окно не выходит за пределы экрана
                    const minTop = 20;
                    const maxTop = viewportHeight - modalRect.height - 20;
                    topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                    
                    // Центрируем по горизонтали или позиционируем относительно точки клика
                    let leftPosition = (viewportWidth - modalRect.width) / 2;
                    if (x + modalRect.width / 2 > viewportWidth) {
                        leftPosition = viewportWidth - modalRect.width - 20;
                    } else if (x - modalRect.width / 2 < 0) {
                        leftPosition = 20;
                    } else {
                        leftPosition = x - modalRect.width / 2;
                    }
                    
                    modalContent.style.position = 'absolute';
                    modalContent.style.top = topPosition + 'px';
                    modalContent.style.left = leftPosition + 'px';
                    modalContent.style.transform = 'none';
                    modalContent.style.margin = '0';
                    modalContent.style.width = 'calc(100% - 40px)';
                    modalContent.style.maxWidth = '500px';
                }
            } else {
                // На десктопе сбрасываем стили (используется стандартное центрирование через CSS)
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
            
            setTimeout(() => input.focus(), 0);
        }

        function confirmStatusComment() {
            const modal = document.getElementById('statusCommentModal');
            const input = document.getElementById('statusCommentInput');
            if (!modal || !input || !pendingStatusForComment) return;
            const text = input.value || '';
            const status = pendingStatusForComment;
            pendingStatusForComment = null;
            modal.style.display = 'none';
            const targetSnapshot = window.__statusCommentTargetSnapshot || null;
            applyStatusToSelection(status, text, targetSnapshot);
        }

        function cancelStatusComment() {
            const modal = document.getElementById('statusCommentModal');
            if (modal) {
                modal.style.display = 'none';
                // Сбрасываем стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
            pendingStatusForComment = null;
        }

        function cancelDeleteStage() {
            const modal = document.getElementById('stageDeleteModal');
            if (modal) {
                modal.style.display = 'none';
            }
            pendingStageToDelete = null;
        }

        function confirmDeleteStage() {
            if (!canEdit()) {
                return; // Блокируем удаление этапов в режиме просмотра
            }
            if (pendingStageToDelete) {
                deleteStage(pendingStageToDelete);
            }
            cancelDeleteStage();
        }

        function buildStageSettingsList() {
            const list = document.getElementById('stageSettingsList');
            if (!list) return;
            list.innerHTML = '';

            stageConfig.forEach((shortName, index) => {
                const item = document.createElement('div');
                item.className = 'stage-settings-item';
                item.draggable = canEdit(); // Блокируем drag&drop этапов в режиме просмотра
                item.dataset.index = String(index);

                item.addEventListener('dragstart', () => {
                    if (!canEdit()) {
                        return;
                    }
                    draggedStageIndex = index;
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', () => {
                    draggedStageIndex = null;
                    item.classList.remove('dragging');
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                item.addEventListener('drop', (e) => {
                    if (!canEdit()) {
                        e.preventDefault();
                        return;
                    }
                    e.preventDefault();
                    if (draggedStageIndex === null) return;
                    const targetIndex = parseInt(item.dataset.index, 10);
                    if (targetIndex === draggedStageIndex) return;

                    const [moved] = stageConfig.splice(draggedStageIndex, 1);
                    stageConfig.splice(targetIndex, 0, moved);
                    draggedStageIndex = null;

                    buildStageSettingsList();
                    renderStageTabs();
                });

                const left = document.createElement('div');
                left.className = 'stage-settings-left';

                const handle = document.createElement('div');
                handle.className = 'stage-settings-handle';
                handle.textContent = '≡';

                const nameEl = document.createElement('div');
                nameEl.className = 'stage-settings-name';
                nameEl.textContent = shortName;
                nameEl.title = 'Двойной клик, чтобы переименовать';

                nameEl.addEventListener('dblclick', () => {
                    const newName = prompt('Новое название этапа:', shortName);
                    if (!newName) return;
                    const trimmed = newName.trim();
                    if (!trimmed || trimmed === shortName) return;
                    renameStage(shortName, trimmed);
                });

                left.appendChild(handle);
                left.appendChild(nameEl);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'stage-settings-delete-btn';
                deleteBtn.type = 'button';
                deleteBtn.innerHTML = '<span>✕</span><span>Удалить</span>';
                deleteBtn.addEventListener('click', () => {
                    if (!canEdit()) {
                        return; // Блокируем удаление этапов в режиме просмотра
                    }
                    openStageDeleteModal(shortName);
                });

                item.appendChild(left);
                item.appendChild(deleteBtn);

                list.appendChild(item);
            });
        }

        function deleteStage(shortName) {
            stageConfig = stageConfig.filter(name => name !== shortName);
            projectData = projectData.filter(item => !item.stage || !item.stage.startsWith(shortName));

            if (currentStageFilter === shortName) {
                currentStageFilter = 'all';
            }

            initializeTasks();
            renderStageTabs();
            buildStageSettingsList();
        }

        function addNewStage() {
            let maxNumber = 0;
            stageConfig.forEach(name => {
                const match = name.match(/^Этап\s+(\d+)/);
                if (match) {
                    const num = parseInt(match[1], 10);
                    if (num > maxNumber) maxNumber = num;
                }
            });

            const newNumber = maxNumber + 1 || 1;
            const shortName = `Этап ${newNumber}`;
            stageConfig.push(shortName);

            // Добавляем одну пустую задачу для нового этапа
            projectData.push({
                stage: `${shortName}. Новый этап`,
                control: '',
                task: '',
                days: 1,
                substage: ''
            });

            currentStageFilter = shortName;
            initializeTasks();
            renderStageTabs();
            buildStageSettingsList();
        }

        function renameStage(oldShortName, newShortName) {
            stageConfig = stageConfig.map(name => name === oldShortName ? newShortName : name);

            projectData.forEach(item => {
                if (!item.stage) return;
                if (item.stage.startsWith(oldShortName)) {
                    item.stage = newShortName + item.stage.slice(oldShortName.length);
                }
            });

            if (currentStageFilter === oldShortName) {
                currentStageFilter = newShortName;
            }

            initializeTasks();
            renderStageTabs();
            buildStageSettingsList();
        }

        // Управление масштабом по горизонтали
        function setZoom(level) {
            // clamp от 0.4 до 2.0
            zoomLevel = Math.max(0.4, Math.min(2, level));
            const range = document.getElementById('zoomRange');
            if (range) {
                range.value = Math.round(zoomLevel * 100);
            }

            // Если сильно отдаляемся и ранее был выбран конкретный месяц,
            // сбрасываем "локальный" диапазон и показываем весь проект
            if (zoomLevel <= 1.0 && (viewStartDate || viewEndDate)) {
                viewStartDate = null;
                viewEndDate = null;
            }

            // Перерисовываем только диаграмму Ганта
            if (currentView === 'gantt') {
                renderGantt();
            }
        }

        function onZoomChange(value) {
            const numeric = Number(value) || 100;
            setZoom(numeric / 100);
        }

        function increaseZoom() {
            // более крупный шаг, чтобы режимы масштаба переключались заметнее
            setZoom(zoomLevel + 0.25);
        }

        function decreaseZoom() {
            // более крупный шаг, чтобы режимы масштаба переключались заметнее
            setZoom(zoomLevel - 0.25);
        }

        // Режим "z + колесо" для зума по диаграмме
        let isZoomKeyPressed = false;

        // Перетаскивание задач (drag & drop)
        let draggingTaskId = null;

        // Открытие/закрытие меню статуса
        function openStatusMenu(x, y, taskId, dateStrs) {
            // dateStrs может быть массивом дат (для недель/месяцев) или одной датой (для дней)
            const dateArray = Array.isArray(dateStrs) ? dateStrs : [dateStrs];
            currentStatusTarget = { taskId, dateStrs: dateArray };
            
            // Сохраняем координаты для позиционирования модального окна комментария на мобильных
            lastClickCoordinates.x = x;
            lastClickCoordinates.y = y;
            
            const menu = document.getElementById('statusMenu');
            if (!menu) return;
            
            const isMobile = window.innerWidth <= 768;
            
            // Сначала показываем меню, чтобы получить правильные размеры
            menu.style.display = 'block';
            menu.style.position = 'fixed';
            
            // Получаем размеры меню и позиционируем его
            requestAnimationFrame(() => {
                const menuRect = menu.getBoundingClientRect();
                let left = x;
                let top = y;
                
                console.log('📍 Клик на позиции:', { 
                    clickX: x, 
                    clickY: y, 
                    isMobile, 
                    menuWidth: menuRect.width, 
                    menuHeight: menuRect.height,
                    viewport: { width: window.innerWidth, height: window.innerHeight }
                });
                
                if (isMobile) {
                    // На мобильных ОБЯЗАТЕЛЬНО показываем меню рядом с точкой тапа
                    const offset = 15; // чуть больше отступ, чтобы палец не закрывал
                    
                    // Проверяем, влезает ли меню справа от точки клика
                    if (x + menuRect.width + offset > window.innerWidth) {
                        // Показываем слева от точки клика
                        left = Math.max(10, x - menuRect.width - offset);
                    } else {
                        left = x + offset;
                    }
                    
                    // Проверяем, влезает ли меню снизу от точки клика
                    if (y + menuRect.height + offset > window.innerHeight) {
                        // Показываем над точкой клика
                        top = Math.max(10, y - menuRect.height - offset);
                    } else {
                        top = y + offset;
                    }
                    
                    console.log('📱 Мобильная позиция меню:', { left, top });
                } else {
                    // На десктопе
                    const offset = 5;
                    
                    if (x + menuRect.width + offset > window.innerWidth) {
                        left = Math.max(10, x - menuRect.width - offset);
                    } else {
                        left = x + offset;
                    }
                    
                    if (y + menuRect.height + offset > window.innerHeight) {
                        top = Math.max(10, y - menuRect.height - offset);
                    } else {
                        top = y + offset;
                    }
                }

                menu.style.left = `${left}px`;
                menu.style.top = `${top}px`;
                
                console.log('✅ Финальная позиция меню:', { left, top });
            });
        }

        function closeStatusMenu() {
            const menu = document.getElementById('statusMenu');
            if (menu) {
                menu.style.display = 'none';
            }
            currentStatusTarget = null;
        }

        function applyStatusToSelection(status, commentText, targetOverride) {
            const target = targetOverride || currentStatusTarget;
            if (!target) return;

            const { taskId, dateStrs } = target;
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            const task = tasks[taskIndex];
            if (!task) return;

            // Убеждаемся, что у задачи есть объект для комментариев по датам
            if (!task.dateComments) {
                task.dateComments = {};
            }

            // Парсим все даты из массива
            const targetDates = dateStrs.map(ds => {
                const parsed = parseDateFromInput(ds);
                return parsed;
            }).filter(d => d !== null);

            if (targetDates.length === 0) return;

            // Для "завершено" берём последнюю дату из массива (самую позднюю)
            const targetDate = status === 'completed' ? targetDates[targetDates.length - 1] : targetDates[0];

            if (status === 'completed') {
                // 1) Обрезаем задачу по выбранной дате (все позже — выкидываем)
                const newDates = task.dates.filter(d => d <= targetDate);
                if (newDates.length > 0) {
                    task.dates = newDates;
                    task.startDate = newDates[0];
                    task.endDate = newDates[newDates.length - 1];
                    task.days = newDates.length;
                } else {
                    // На всякий случай: если по каким-то причинам ничего не попало —
                    // ставим единственный день завершения
                    task.dates = [targetDate];
                    task.startDate = targetDate;
                    task.endDate = targetDate;
                    task.days = 1;
                }

                // 2) Отмечаем все оставшиеся дни задачи как завершённые
                task.status = 'completed';
                task.dateStatuses = {};
                task.dates.forEach(d => {
                    const ds = formatDateKey(d);
                    task.dateStatuses[ds] = 'completed';
                });

                // 3) Новый комментарий, если введён, привязываем только к целевой дате завершения,
                // не затирая существующие комментарии по другим дням.
                if (commentText && commentText.trim().length > 0) {
                    const completionKey = formatDateKey(targetDate);
                    task.dateComments[completionKey] = commentText.trim();
                }

                // 4) Жёсткая последовательность: подтягиваем все последующие задачи
                recalculateFollowingTasks(taskIndex);
            } else if (status === 'in-progress') {
                task.status = 'in-progress';
                // Применяем статус ко всем датам периода
                targetDates.forEach(d => {
                    const key = formatDateKey(d);
                    task.dateStatuses[key] = 'in-progress';
                    if (commentText && commentText.trim().length > 0) {
                        task.dateComments[key] = commentText.trim();
                    }
                });
            } else if (status === 'pending') {
                // Возврат к статусу "Запланировано"
                // Удаляем статусы "в работе" и "завершено" для выбранных дат
                targetDates.forEach(d => {
                    const key = formatDateKey(d);
                    if (task.dateStatuses[key] === 'in-progress' || task.dateStatuses[key] === 'completed') {
                        delete task.dateStatuses[key];
                    }
                });
                
                // Если все даты задачи вернулись к "запланировано", меняем общий статус задачи
                const hasInProgressOrCompleted = task.dates.some(d => {
                    const key = formatDateKey(d);
                    return task.dateStatuses[key] === 'in-progress' || task.dateStatuses[key] === 'completed';
                });
                
                if (!hasInProgressOrCompleted) {
                    task.status = 'pending';
                }
            } else if (status === 'weekend-manual') {
                // Применяем статус ко всем датам периода
                targetDates.forEach(d => {
                    const key = formatDateKey(d);
                    task.dateStatuses[key] = 'weekend-manual';
                });
            } else if (status === 'holiday-manual') {
                // Применяем статус ко всем датам периода
                targetDates.forEach(d => {
                    const key = formatDateKey(d);
                    task.dateStatuses[key] = 'holiday-manual';
                });
            }

            closeStatusMenu();
            updateStatistics();
            if (currentView === 'gantt') {
                renderGantt();
            }
            renderTable();
            
            // Немедленное сохранение для критических операций (статусы и комментарии)
            console.log('💾 Критическое изменение: статус/комментарий, сохраняем немедленно');
            saveFullGanttState(); // Сохраняем сразу, без задержки
        }

        // Обработчики кликов по пунктам меню статуса
        document.addEventListener('DOMContentLoaded', function() {
            const menu = document.getElementById('statusMenu');
            if (menu) {
                menu.querySelectorAll('.status-menu-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const status = item.getAttribute('data-status');
                        if (status === 'in-progress' || status === 'completed') {
                            pendingStatusForComment = status;
                            openStatusCommentModal();
                        } else {
                            applyStatusToSelection(status);
                        }
                    });
                });
            }
        });

        // Закрытие модальных окон, меню статуса
        // и сброс выделения при клике вне основных областей
        window.onclick = function(event) {
            const target = event.target;

            const modal = document.getElementById('editModal');
            if (target === modal) {
                modal.style.display = 'none';
            }

            const menu = document.getElementById('statusMenu');
            if (menu && !menu.contains(target)) {
                closeStatusMenu();
            }

            const deleteModal = document.getElementById('deleteConfirmModal');
            if (target === deleteModal) {
                cancelDeleteTask();
            }

            const resetPlanModal = document.getElementById('resetPlanConfirmModal');
            if (target === resetPlanModal) {
                cancelResetPlan();
            }

            const profileModal = document.getElementById('profileModal');
            if (target === profileModal) {
                closeProfileModal();
            }

            const gantt = document.querySelector('.chart-container');
            const table = document.querySelector('.table-section');

            const insideGantt = gantt && gantt.contains(target);
            const insideTable = table && table.contains(target);
            const insideMenu = menu && menu.contains(target);
            const insideDeleteModal = deleteModal && deleteModal.contains(target);
            const insideResetPlanModal = resetPlanModal && resetPlanModal.contains(target);

            // Клик по пустому месту вне диаграммы/таблицы/меню/модалок
            // снимает выделение задач
            if (!insideGantt && !insideTable && !insideMenu && !insideDeleteModal && !insideResetPlanModal) {
                clearSelection();
            }
        }

        // ========== РЕДАКТИРОВАНИЕ ПРОФИЛЯ ==========
        let currentUser = null;

        // Загрузить данные текущего пользователя
        function loadCurrentUser() {
            const userStr = localStorage.getItem('gantt-user');
            if (userStr) {
                try {
                    currentUser = JSON.parse(userStr);
                    // Показываем кнопки профиля, выбора компаний и выхода только для авторизованных пользователей
                    showAuthButtons();
                    
                    // Дополнительная проверка через небольшую задержку
                    setTimeout(() => {
                        const companiesBottomBtn = document.getElementById('companiesBottomBtn');
                        if (companiesBottomBtn) {
                            companiesBottomBtn.style.display = 'flex';
                            companiesBottomBtn.style.visibility = 'visible';
                            companiesBottomBtn.style.opacity = '1';
                            console.log('Нижняя кнопка компаний принудительно показана через loadCurrentUser', {
                                display: companiesBottomBtn.style.display,
                                visibility: companiesBottomBtn.style.visibility,
                                computedDisplay: window.getComputedStyle(companiesBottomBtn).display
                            });
                        } else {
                            console.error('Нижняя кнопка компаний НЕ НАЙДЕНА в loadCurrentUser!');
                        }
                    }, 200);
                } catch (e) {
                    console.error('Ошибка загрузки данных пользователя:', e);
                }
            }
        }


        // Переход на страницу выбора компаний
        function goToCompanies() {
            window.location.href = 'companies.html';
        }

        // Выход из системы
        function logout() {
            // Очищаем данные авторизации из localStorage
            localStorage.removeItem('gantt-user');
            localStorage.removeItem('gantt-mode');
            localStorage.removeItem('gantt-company');
            
            // Перенаправляем на страницу авторизации
            window.location.href = 'auth.html';
        }

        // Перетаскивание модального окна
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let initialPosition = { x: 0, y: 0 };

        function initProfileModalDrag() {
            const modal = document.getElementById('profileModal');
            const modalContent = modal?.querySelector('.profile-modal-content');
            const modalHeader = modal?.querySelector('.profile-modal-header');
            
            if (!modalContent || !modalHeader) return;

            modalHeader.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('profile-modal-close')) {
                    return; // Не перетаскиваем при клике на кнопку закрытия
                }
                
                isDragging = true;
                const rect = modalContent.getBoundingClientRect();
                
                // Вычисляем смещение от точки клика до левого верхнего угла окна
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                // Сохраняем начальную позицию окна
                initialPosition.x = rect.left;
                initialPosition.y = rect.top;
                
                // Переключаем на fixed позиционирование для корректного перетаскивания
                modalContent.style.position = 'fixed';
                modalContent.style.left = rect.left + 'px';
                modalContent.style.top = rect.top + 'px';
                modalContent.style.margin = '0';
                modalContent.style.transition = 'none';
                
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const modalContent = document.querySelector('.profile-modal-content');
                if (!modalContent) return;

                // Вычисляем новую позицию так, чтобы точка клика оставалась под курсором
                let newX = e.clientX - dragOffset.x;
                let newY = e.clientY - dragOffset.y;
                
                // Ограничиваем перемещение границами экрана
                const maxX = window.innerWidth - modalContent.offsetWidth;
                const maxY = window.innerHeight - modalContent.offsetHeight;
                
                newX = Math.max(0, Math.min(newX, maxX));
                newY = Math.max(0, Math.min(newY, maxY));
                
                modalContent.style.left = newX + 'px';
                modalContent.style.top = newY + 'px';
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    const modalContent = document.querySelector('.profile-modal-content');
                    if (modalContent) {
                        // Возвращаем transition для плавных анимаций
                        modalContent.style.transition = '';
                        // Оставляем position: fixed, чтобы окно осталось на месте
                    }
                }
            });
        }

        // Открыть модальное окно профиля
        function openProfileModal() {
            const modal = document.getElementById('profileModal');
            const modalContent = modal?.querySelector('.profile-modal-content');
            const loginInput = document.getElementById('profileLogin');
            if (modal && currentUser && loginInput) {
                loginInput.value = currentUser.login || '';
                document.getElementById('profilePassword').value = '';
                document.getElementById('profilePasswordConfirm').value = '';
                document.getElementById('profileMessage').classList.remove('show');
                
                // Сбрасываем позицию при открытии
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.left = '';
                    modalContent.style.top = '';
                    modalContent.style.margin = '';
                    modalContent.style.transform = '';
                }
                
                modal.classList.add('show');
            }
        }

        // Закрыть модальное окно профиля
        function closeProfileModal() {
            const modal = document.getElementById('profileModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // Сохранить изменения профиля
        async function saveProfile(event) {
            event.preventDefault();
            
            const loginInput = document.getElementById('profileLogin');
            const passwordInput = document.getElementById('profilePassword');
            const passwordConfirmInput = document.getElementById('profilePasswordConfirm');
            const messageEl = document.getElementById('profileMessage');
            
            const newLogin = loginInput.value.trim();
            const newPassword = passwordInput.value;
            const passwordConfirm = passwordConfirmInput.value;

            // Проверка паролей
            if (newPassword && newPassword !== passwordConfirm) {
                messageEl.textContent = 'Пароли не совпадают';
                messageEl.className = 'profile-message error show';
                return;
            }

            if (newPassword && newPassword.length < 6) {
                messageEl.textContent = 'Пароль должен содержать минимум 6 символов';
                messageEl.className = 'profile-message error show';
                return;
            }

            if (!newLogin) {
                messageEl.textContent = 'Логин не может быть пустым';
                messageEl.className = 'profile-message error show';
                return;
            }

            try {
                const updateData = {
                    oldLogin: currentUser.login,
                    newLogin: newLogin,
                    password: newPassword || null
                };

                const response = await fetch('/api/users/update', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });

                const result = await response.json();

                if (result.ok) {
                    // Обновляем данные пользователя в localStorage
                    currentUser.login = newLogin;
                    localStorage.setItem('gantt-user', JSON.stringify(currentUser));
                    
                    messageEl.textContent = 'Профиль успешно обновлён';
                    messageEl.className = 'profile-message success show';
                    
                    setTimeout(() => {
                        closeProfileModal();
                    }, 1500);
                } else {
                    messageEl.textContent = result.error || 'Ошибка обновления профиля';
                    messageEl.className = 'profile-message error show';
                }
            } catch (error) {
                console.error('Ошибка обновления профиля:', error);
                messageEl.textContent = 'Ошибка подключения к серверу';
                messageEl.className = 'profile-message error show';
            }
        }

        // Проверка доступа пользователя к компании
        async function checkCompanyAccess() {
            if (!currentCompany) {
                // Если компания не указана, разрешаем доступ (для обратной совместимости)
                return true;
            }

            const userStr = localStorage.getItem('gantt-user');
            if (!userStr) {
                // Если пользователь не авторизован, разрешаем доступ (режим просмотра)
                return true;
            }

            try {
                const user = JSON.parse(userStr);
                // Админы имеют доступ ко всем компаниям
                if (user.role === 'admin') {
                    return true;
                }
                // Проверяем, есть ли у пользователя доступ к компании
                const userCompanies = user.companies || [];
                return userCompanies.includes(currentCompany);
            } catch (e) {
                console.error('Ошибка проверки доступа:', e);
                return true; // В случае ошибки разрешаем доступ
            }
        }

        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', async function() {
            // Проверяем доступ к компании перед загрузкой данных
            const hasAccess = await checkCompanyAccess();
            if (!hasAccess && currentCompany) {
                alert('У вас нет доступа к этой компании. Вы будете перенаправлены на страницу авторизации.');
                window.location.href = `auth.html?company=${currentCompany}`;
                return;
            }

            // Пытаемся загрузить полное состояние графика
            const fullStateLoaded = await loadFullGanttState();
            if (!fullStateLoaded) {
                // Если полное состояние не загружено, инициализируем задачи по умолчанию
                initializeTasks();
                // Загружаем baseline для обратной совместимости
                await loadBaselineFromServer();
            }
            // Убеждаемся, что график отрисован
            if (tasks.length > 0) {
                renderGantt();
                renderTable();
                renderStageTabs();
            }
            // Обновляем состояние кнопки "Директивный план"
            updateBaselineToggleButton();
            await loadCompanyInfo();
            loadCurrentUser();
            
            // ПРИНУДИТЕЛЬНО показываем кнопки авторизации после загрузки страницы
            const forceShowAuthButtons = () => {
                const userStr = localStorage.getItem('gantt-user');
                if (userStr) {
                    const profileBtn = document.getElementById('profileBtn');
                    const companiesBottomBtn = document.getElementById('companiesBottomBtn');
                    const logoutBtn = document.getElementById('logoutBtn');
                    
                    console.log('🔍 forceShowAuthButtons:', { 
                        profileBtn: !!profileBtn, 
                        companiesBottomBtn: !!companiesBottomBtn, 
                        logoutBtn: !!logoutBtn 
                    });
                    
                    if (profileBtn) {
                        profileBtn.style.display = 'flex';
                        profileBtn.style.visibility = 'visible';
                        profileBtn.style.opacity = '1';
                    }
                    if (companiesBottomBtn) {
                        companiesBottomBtn.style.display = 'flex';
                        companiesBottomBtn.style.visibility = 'visible';
                        companiesBottomBtn.style.opacity = '1';
                        console.log('✅ Нижняя кнопка компаний ПРИНУДИТЕЛЬНО показана!', {
                            display: companiesBottomBtn.style.display,
                            visibility: companiesBottomBtn.style.visibility,
                            opacity: companiesBottomBtn.style.opacity,
                            computedDisplay: window.getComputedStyle(companiesBottomBtn).display,
                            computedVisibility: window.getComputedStyle(companiesBottomBtn).visibility,
                            position: companiesBottomBtn.getBoundingClientRect()
                        });
                    } else {
                        console.error('❌ Нижняя кнопка компаний НЕ НАЙДЕНА в DOM!');
                    }
                    if (logoutBtn) {
                        logoutBtn.style.display = 'flex';
                        logoutBtn.style.visibility = 'visible';
                        logoutBtn.style.opacity = '1';
                    }
                } else {
                    console.warn('⚠️ Пользователь не авторизован (нет gantt-user в localStorage)');
                }
            };
            
            // Множественные попытки показать кнопки с разными задержками
            forceShowAuthButtons();
            setTimeout(forceShowAuthButtons, 100);
            setTimeout(forceShowAuthButtons, 300);
            setTimeout(forceShowAuthButtons, 500);
            setTimeout(forceShowAuthButtons, 1000);
            setTimeout(forceShowAuthButtons, 2000);
            
            // Обработчики для профиля
            const profileBtn = document.getElementById('profileBtn');
            if (profileBtn) {
                profileBtn.addEventListener('click', openProfileModal);
            }
            
            const profileForm = document.getElementById('profileForm');
            if (profileForm) {
                profileForm.addEventListener('submit', saveProfile);
            }

            // Инициализация перетаскивания модального окна
            initProfileModalDrag();

            // Закрытие модального окна при клике вне его
            const profileModal = document.getElementById('profileModal');
            if (profileModal) {
                profileModal.addEventListener('click', function(e) {
                    if (e.target === profileModal && !isDragging) {
                        closeProfileModal();
                    }
                });
            }

            const chartContainer = document.querySelector('.chart-container');
            const tableSection = document.querySelector('.table-section');
            const stageButtons = document.querySelectorAll('.stage-tab-btn');
            const companyNameDisplay = document.getElementById('companyNameDisplay');
            const companyLogoInput = document.getElementById('companyLogoInput');
            const companyLogoWrapper = document.getElementById('companyLogoWrapper');

            if (companyNameDisplay) {
                // Убираем возможность редактирования названия компании на странице графика
                // Редактирование доступно только через админ-панель или страницу выбора компаний
                companyNameDisplay.contentEditable = 'false';
                companyNameDisplay.style.cursor = 'default';
            }

            // Убираем возможность загрузки логотипа на странице графика
            // Загрузка доступна только через админ-панель или страницу выбора компаний
            if (companyLogoInput) {
                companyLogoInput.style.display = 'none';
            }
            
            if (companyLogoWrapper) {
                companyLogoWrapper.style.cursor = 'default';
            }

            // Инициализируем вкладки этапов на основе текущей конфигурации
            renderStageTabs();

            // Инициализируем подсветку переключателя "Гант / Таблица" и активной панели
            updateViewToggleUI();
            updateViewPanelsUI();
            
            // Блокируем кнопку "Сбросить план" в режиме просмотра
            if (isViewMode) {
                const resetBtn = document.querySelector('.reset-plan-btn');
                if (resetBtn) {
                    resetBtn.classList.add('view-mode-disabled');
                }
            }

            // Отслеживаем нажатие/отжатие клавиши Z (или той же физической клавиши в русской раскладке)
            window.addEventListener('keydown', (event) => {
                // Используем event.code, чтобы сочетание работало и в русской раскладке (KeyZ = Z/Я)
                if (event.code === 'KeyZ') {
                    isZoomKeyPressed = true;
                }

                // Вставка новой задачи под выделенной по клавише Insert
                if (event.key === 'Insert') {
                    if (!canEdit()) {
                        return; // Блокируем Insert в режиме просмотра
                    }
                    const target = event.target;
                    // Не перехватываем нажатие, если фокус в инпуте/селекте/редактируемом элементе
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }
                    event.preventDefault();
                    insertTaskBelowSelected();
                    return;
                }

                // Удаление выбранной задачи по клавише Delete (с подтверждением)
                if (event.key === 'Delete') {
                    if (!canEdit()) {
                        return; // Блокируем Delete в режиме просмотра
                    }
                    const target = event.target;
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }
                    event.preventDefault();
                    openDeleteConfirm();
                    return;
                }

                // Сохранение директивного (baseline) плана по F2
                if (event.key === 'F2') {
                    const target = event.target;
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }
                    event.preventDefault();

                    const newSnapshot = buildBaselineSnapshot();
                    const hasExistingBaseline =
                        baselineSnapshot &&
                        Array.isArray(baselineSnapshot.tasks) &&
                        baselineSnapshot.tasks.some(t => Array.isArray(t.baselineDates) && t.baselineDates.length > 0);

                    console.log('F2 pressed. hasExistingBaseline:', hasExistingBaseline, 'baselineSnapshot:', baselineSnapshot);

                    if (hasExistingBaseline) {
                        openBaselineConfirmModal(newSnapshot);
                    } else {
                        try {
                            baselineSnapshot = newSnapshot;
                            applyBaselineToTasks();
                            saveBaselineToServer(baselineSnapshot);
                            console.log('Calling showBaselineToast for first time');
                            // Показываем сообщение сразу
                            showBaselineToast('Вы задали базовый план. Нажмите "Директивный план" или F3 для отображения.');
                            // Обновляем состояние кнопки
                            updateBaselineToggleButton();
                        } catch (error) {
                            console.error('Ошибка при сохранении базового плана:', error);
                            // Показываем сообщение даже при ошибке
                            showBaselineToast('Вы задали базовый план. Нажмите "Директивный план" или F3 для отображения.');
                            updateBaselineToggleButton();
                        }
                    }
                    return;
                }

                // Переключение отображения baseline-полосы по F3
                if (event.key === 'F3') {
                    const target = event.target;
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }
                    event.preventDefault();

                    const hasBaseline =
                        baselineSnapshot &&
                        Array.isArray(baselineSnapshot.tasks) &&
                        baselineSnapshot.tasks.some(t => Array.isArray(t.baselineDates) && t.baselineDates.length > 0);

                    if (!hasBaseline) {
                        showBaselineToast('Базовый план не задан. Нажмите "Задать базовый план" или F2, чтобы сохранить текущий график как директивный.');
                        return;
                    }

                    showBaseline = !showBaseline;
                    updateBaselineToggleButton();
                    renderGantt();
                    return;
                }

                // Если открыто модальное окно профиля — закрываем по Escape
                const profileModal = document.getElementById('profileModal');
                if (profileModal && profileModal.classList.contains('show')) {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        closeProfileModal();
                        return;
                    }
                }

                // Если открыто окно подтверждения удаления — обрабатываем только его
                if (isDeleteConfirmOpen) {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        cancelDeleteTask();
                        return;
                    }
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        confirmDeleteTask();
                        return;
                    }
                }

                // Если открыто окно подтверждения сброса плана — обрабатываем только его
                const resetPlanModal = document.getElementById('resetPlanConfirmModal');
                if (resetPlanModal && resetPlanModal.style.display === 'block') {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        cancelResetPlan();
                        return;
                    }
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        confirmResetPlan();
                        return;
                    }
                }

                // Клавиатурная навигация по задачам (ArrowUp / ArrowDown)
                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    const target = event.target;
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }

                    if (!tasks.length) return;

                    event.preventDefault();

                    let currentIndex = -1;
                    const primaryId = getPrimarySelectedTaskId();
                    if (primaryId !== null) {
                        currentIndex = tasks.findIndex(t => t.id === primaryId);
                    }

                    if (currentIndex === -1) {
                        // Если ничего не выбрано — начинаем с первой/последней
                        currentIndex = event.key === 'ArrowDown' ? 0 : tasks.length - 1;
                    } else {
                        if (event.key === 'ArrowDown' && currentIndex < tasks.length - 1) {
                            currentIndex += 1;
                        } else if (event.key === 'ArrowUp' && currentIndex > 0) {
                            currentIndex -= 1;
                        }
                    }

                    const newTask = tasks[currentIndex];
                    if (!newTask) return;

                    // Стрелками всегда выбираем одну задачу (сброс диапазона)
                    selectTask(newTask.id, { range: false });

                    // Скроллим Гант к выбранной строке
                    const row = document.querySelector(`.gantt-row[data-task-id="${newTask.id}"]`);
                    if (row && row.scrollIntoView) {
                        row.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    }
                    return;
                }
            });

            window.addEventListener('keyup', (event) => {
                if (event.code === 'KeyZ') {
                    isZoomKeyPressed = false;
                }
            });

            // Колесо мыши над диаграммой: при зажатой Z — зум, иначе обычный скролл
            if (chartContainer) {
                chartContainer.addEventListener('wheel', (event) => {
                    if (!isZoomKeyPressed) {
                        return; // обычный скролл страницы
                    }

                    event.preventDefault();

                    const direction = event.deltaY > 0 ? -1 : 1; // вниз = отдаление, вверх = приближение
                    const step = 0.1 * direction;
                    setZoom(zoomLevel + step);
                }, { passive: false });
            }
        });
    </script>
</body>
</html>
