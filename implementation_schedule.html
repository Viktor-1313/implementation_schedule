<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>График внедрения и обучения системы ICONA</title>
    <link rel="icon" type="image/png" href="favicon.png">
    
    <!-- Open Graph метатеги для превью ссылок -->
    <meta property="og:title" content="График внедрения и обучения системы ICONA">
    <meta property="og:description" content="Интерактивная диаграмма Ганта для планирования внедрения и обучения системе ICONA">
    <meta property="og:image" content="logo.png">
    <meta property="og:type" content="website">
    <meta property="og:url" content="">
    <!-- html2pdf.js загружается асинхронно только при необходимости (при экспорте в PDF) -->
    <!-- Локальная копия XLSX для корпоративной сети (без зависимости от CDN).
         Файл xlsx.min.js должен лежать рядом с implementation_schedule.html или в указанной папке. -->
    <script src="xlsx.min.js"></script>
    <style>
        :root {
            --color-primary: #1e88e5;
            --color-primary-hover: #1565c0;
            --color-bg: #f5f5f5;
            --color-surface: #ffffff;
            --color-text: #1a1a1a;
            --color-text-secondary: #666666;
            --color-border: #e0e0e0;
            --color-success: #4caf50;
            --color-warning: #ff9800;
            --color-error: #f44336;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
            opacity: 0;
            animation: fadeInFromFog 1.5s ease-out forwards;
        }

        /* Анимация появления из тумана */
        @keyframes fadeInFromFog {
            0% {
                opacity: 0;
                filter: blur(30px);
                transform: scale(0.95);
            }
            50% {
                opacity: 0.3;
                filter: blur(15px);
                transform: scale(0.98);
            }
            100% {
                opacity: 1;
                filter: blur(0px);
                transform: scale(1);
            }
        }

        /* Эффект тумана при появлении */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 50% 50%, rgba(200, 230, 255, 0.4) 0%, transparent 60%),
                radial-gradient(circle at 30% 30%, rgba(173, 216, 230, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(135, 206, 250, 0.3) 0%, transparent 50%);
            animation: fogDissolve 1.5s ease-out forwards;
            z-index: 9999;
            pointer-events: none;
        }

        @keyframes fogDissolve {
            0% {
                opacity: 1;
                transform: scale(1.2);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
            100% {
                opacity: 0;
                transform: scale(1);
            }
        }

        .container {
            /* Было 1400px — увеличили примерно на 400px по вашей просьбе */
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            animation: containerAppear 1.5s ease-out 0.3s both;
        }

        @keyframes containerAppear {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        header {
            position: relative; /* Для правильного позиционирования кнопок */
            background: var(--color-surface);
            padding: 30px 20px;
            border-bottom: 2px solid var(--color-primary);
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            position: relative;
        }

        /* Кнопка профиля в правом верхнем углу */
        .profile-btn {
            position: absolute !important;
            top: 30px !important;
            right: 30px !important;
            left: auto !important;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            border: 2px solid #2c2c2c;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            z-index: 1000;
            overflow: visible;
        }

        /* Анимация вращения золотой точки по кругу по часовой стрелке */
        @keyframes rotateDot {
            0% {
                transform: translateX(-50%) rotate(0deg) translateY(20px) rotate(0deg);
            }
            100% {
                transform: translateX(-50%) rotate(360deg) translateY(20px) rotate(-360deg);
            }
        }

        /* Золотая точка, вращающаяся по кругу при наведении */
        .profile-btn::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            opacity: 0;
            z-index: 1001;
            transition: opacity 0.3s ease;
        }

        /* При наведении показываем золотую точку и запускаем анимацию */
        .profile-btn:hover::after {
            opacity: 1;
            animation: rotateDot 2s linear infinite;
        }

        .profile-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(66, 165, 245, 0.4);
        }

        /* Иконка профиля (голова) */
        .profile-btn .profile-icon-head {
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 8px;
            z-index: 1002;
        }

        /* Глаза профиля */
        .profile-btn .profile-icon-head::before,
        .profile-btn .profile-icon-head::after {
            content: '';
            position: absolute;
            width: 2.5px;
            height: 2.5px;
            background: #42a5f5;
            border-radius: 50%;
            top: 5.5px;
        }

        .profile-btn .profile-icon-head::before {
            left: 4.5px;
        }

        .profile-btn .profile-icon-head::after {
            right: 4.5px;
        }

        /* Рот профиля */
        .profile-icon-mouth {
            position: absolute;
            width: 7px;
            height: 3.5px;
            border: 2px solid #42a5f5;
            border-top: none;
            border-radius: 0 0 7px 7px;
            top: 17px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1003;
            background: transparent;
        }

        /* Иконка профиля (плечи) */
        .profile-btn .profile-icon-shoulders {
            position: absolute;
            width: 22px;
            height: 12px;
            background: white;
            border-radius: 12px 12px 0 0;
            bottom: 6px;
            z-index: 1002;
        }

        /* Подсказка для кнопки профиля */
        .profile-btn[data-tooltip] {
            position: relative;
        }

        .profile-btn[data-tooltip]:hover .profile-tooltip {
            opacity: 1;
            transition-delay: 1s;
        }

        .profile-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: #000000 !important;
            color: white !important;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.75rem;
            white-space: normal;
            min-width: max-content;
            max-width: 200px;
            word-wrap: break-word;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10001;
            width: auto;
            height: auto;
        }

        /* Кнопка выхода к выбору компаний (скрыта, используется новая кнопка ниже) */
        .companies-btn {
            display: none !important;
        }

        /* Золотая точка, вращающаяся по кругу для кнопки компаний при наведении */
        .companies-btn::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            opacity: 0;
            z-index: 1001;
            transition: opacity 0.3s ease;
        }

        /* При наведении показываем золотую точку и запускаем анимацию */
        .companies-btn:hover::after {
            opacity: 1;
            animation: rotateDot 2s linear infinite;
        }

        .companies-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        /* Иконка квадрата с точкой для кнопки компаний */
        .companies-btn .companies-icon {
            width: 18px;
            height: 18px;
            border: 2px solid white;
            border-radius: 4px;
            position: absolute;
            z-index: 1002;
        }

        /* Точка внутри квадрата для кнопки компаний */
        .companies-btn .companies-icon::before {
            content: '';
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 4px;
            left: 4px;
        }

        /* Подсказка для кнопки компаний */
        .companies-btn {
            position: relative;
        }
        
        .companies-btn:hover .companies-tooltip {
            opacity: 1 !important;
            visibility: visible !important;
            transition-delay: 1s;
        }

        .companies-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            border-radius: 8px;
            background: #000000;
            color: #ffffff;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 10001;
        }

        /* Точка внутри квадрата */
        .companies-btn > span {
            content: '';
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 4px;
            left: 4px;
            z-index: 2;
        }

        /* Кнопка выхода */
        .logout-btn {
            position: absolute;
            top: 80px;
            right: 30px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            border: 2px solid #2c2c2c;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            z-index: 1000;
            overflow: visible;
        }

        /* Золотая точка, вращающаяся по кругу для кнопки выхода при наведении */
        .logout-btn::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            opacity: 0;
            z-index: 1001;
            transition: opacity 0.3s ease;
        }

        /* При наведении показываем золотую точку и запускаем анимацию */
        .logout-btn:hover::after {
            opacity: 1;
            animation: rotateDot 2s linear infinite;
        }

        .logout-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
        }

        /* Иконка выхода (стрелка влево) */
        .logout-btn .logout-icon {
            width: 12px;
            height: 12px;
            border-left: 3px solid white;
            border-top: 3px solid white;
            transform: rotate(-45deg) translateX(2px);
            z-index: 1002;
            position: absolute;
        }

        /* Подсказка для кнопки выхода */
        .logout-btn[data-tooltip]:hover .logout-tooltip {
            opacity: 1;
            transform: translate(-6px, -50%);
            transition-delay: 1s;
        }

        .logout-tooltip {
            content: attr(data-tooltip);
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translate(0, -50%);
            padding: 8px 12px;
            border-radius: 8px;
            background: #000000 !important;
            color: #fff !important;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: right center;
            margin-right: 8px;
            z-index: 10001;
        }

        /* Новая кнопка компаний под кнопкой выхода */
        .companies-bottom-btn {
            position: absolute;
            top: 130px;
            right: 30px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%);
            border: 2px solid #2c2c2c;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            z-index: 1000;
            overflow: visible;
        }

        /* Золотая точка, вращающаяся по кругу для нижней кнопки компаний */
        .companies-bottom-btn::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffd700;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -20px);
            opacity: 0;
            z-index: 1001;
            transition: opacity 0.3s ease;
        }

        .companies-bottom-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .companies-bottom-btn:hover::after {
            opacity: 1;
            animation: rotateDot 2s linear infinite;
        }

        /* Иконка зданий для кнопки компаний */
        .companies-bottom-icon {
            width: 18px;
            height: 18px;
            position: relative;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }

        /* Три здания разной высоты */
        .companies-bottom-icon::before,
        .companies-bottom-icon::after {
            content: '';
            background: white;
            border-radius: 2px 2px 0 0;
            position: absolute;
            bottom: 0;
        }

        /* Левое здание (низкое) */
        .companies-bottom-icon::before {
            width: 4px;
            height: 10px;
            left: 2px;
        }

        /* Среднее здание (высокое) */
        .companies-bottom-icon::after {
            width: 4px;
            height: 16px;
            left: 7px;
        }

        /* Правое здание (среднее) */
        .companies-bottom-icon .building-right {
            position: absolute;
            width: 4px;
            height: 13px;
            background: white;
            border-radius: 2px 2px 0 0;
            right: 2px;
            bottom: 0;
        }

        /* Подсказка для новой кнопки компаний */
        .companies-bottom-btn:hover .companies-bottom-tooltip {
            opacity: 1 !important;
            visibility: visible !important;
            transition-delay: 1s;
        }

        .companies-bottom-tooltip {
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            border-radius: 8px;
            background: #000000;
            color: #ffffff;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 10001;
        }

        /* Модальное окно редактирования профиля */
        .profile-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease;
        }

        .profile-modal.show {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 10vh; /* Поднимаем окно выше */
        }

        @media (max-width: 768px) {
            .profile-modal.show {
                padding-top: 5vh;
                align-items: center;
            }
        }

        @media (max-width: 480px) {
            .profile-modal.show {
                padding-top: 2vh;
                padding-left: 5px;
                padding-right: 5px;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .profile-modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
            position: relative;
            margin-top: 10vh; /* Поднимаем окно выше */
            cursor: default;
        }

        .profile-modal-header {
            cursor: move;
            user-select: none;
        }

        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .profile-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .profile-modal-header h2 {
            color: #1565c0;
            font-size: 1.8rem;
            font-weight: 700;
        }

        .profile-modal-close {
            background: none;
            border: none;
            font-size: 2rem;
            color: #999;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .profile-modal-close:hover {
            background: #f5f5f5;
            color: #333;
        }

        .profile-form-group {
            margin-bottom: 25px;
        }

        .profile-form-group label {
            display: block;
            color: #1565c0;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .profile-form-group input {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid rgba(100, 181, 246, 0.3);
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
            color: #1565c0;
        }

        .profile-form-group input:focus {
            outline: none;
            border-color: #42a5f5;
            box-shadow: 0 0 0 4px rgba(66, 165, 245, 0.15);
            background: white;
        }

        .profile-form-group input::placeholder {
            color: #90caf9;
        }

        .profile-form-actions {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .profile-btn-save {
            flex: 1;
            padding: 14px 24px;
            background: linear-gradient(135deg, #42a5f5 0%, #2196f3 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.3);
        }

        .profile-btn-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(33, 150, 243, 0.4);
        }

        .profile-btn-cancel {
            flex: 1;
            padding: 14px 24px;
            background: #e0e0e0;
            color: #666;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .profile-btn-cancel:hover {
            background: #d0d0d0;
        }

        .profile-message {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            font-size: 0.9rem;
        }

        .profile-message.success {
            background: rgba(129, 199, 132, 0.2);
            color: #2e7d32;
            border: 1px solid rgba(129, 199, 132, 0.5);
        }

        .profile-message.error {
            background: rgba(239, 83, 80, 0.2);
            color: #c62828;
            border: 1px solid rgba(239, 83, 80, 0.5);
        }

        .profile-message.show {
            display: block;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            color: var(--color-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-subtitle {
            color: var(--color-text-secondary);
            font-size: 14px;
        }

        .header-icon {
            width: 26px;
            height: 26px;
            border-radius: 6px;
            background: radial-gradient(circle at 20% 20%, #ffffff 0, #ffffff 10%, #bbdefb 30%, #1e88e5 80%);
            box-shadow: 0 0 0 2px rgba(30, 136, 229, 0.3), 0 4px 8px rgba(0, 0, 0, 0.18);
            position: relative;
        }

        .header-icon::before {
            content: '';
            position: absolute;
            inset: 6px;
            border-radius: 4px;
            border: 2px solid #ffffff;
            box-shadow: inset 0 0 0 1px rgba(21, 101, 192, 0.6);
        }

        .header-icon::after {
            content: '';
            position: absolute;
            left: 6px;
            right: 6px;
            bottom: 7px;
            height: 2px;
            background: rgba(255, 255, 255, 0.9);
        }

        .company-info {
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .company-logo-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            position: relative;
        }

        .company-logo-preview {
            width: 192px;
            height: 192px;
            border-radius: 8px;
            border: 1px solid var(--color-border);
            object-fit: contain;
            background: #fafafa;
            padding: 4px;
        }

        .company-logo-hint {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: var(--color-text-secondary);
            pointer-events: none;
            text-align: center;
        }

        .company-name-block {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .company-name-label {
            font-size: 11px;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        .company-name-display {
            font-size: 40px;
            color: #9e9e9e;
            font-style: italic;
            min-height: 32px;
            outline: none;
            cursor: default;
            user-select: none;
        }

        .company-object-name-display {
            color: #64b5f6;
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 4px;
            line-height: 1.4;
        }

        .company-name-display.has-value {
            font-size: 64px;
            font-weight: 700;
            background: linear-gradient(135deg, #f44336 0%, #5b0001 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-style: normal;
        }

        .controls {
            background: var(--color-surface);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-sm);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            border-bottom: 3px solid var(--color-primary);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
        }

        .zoom-controls .btn {
            min-width: auto !important;
            width: auto !important;
            justify-content: center;
            padding: 6px 8px !important;
            flex-shrink: 0;
        }

        .zoom-label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .zoom-range {
            width: 120px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-icon {
            width: 18px;
            height: 18px;
            display: inline-block;
            position: relative;
        }

        /* Единый стиль основных кнопок управления (PDF, Excel, Гант/Таблица, Сбросить план) */
        .controls .btn-primary,
        .controls .btn-secondary {
            background: var(--color-primary);
            color: #ffffff;
            border-radius: 6px;
            border: 1px solid var(--color-primary-hover);
            width: 180px;
            justify-content: flex-start;
            height: 40px;
            padding-left: 16px;
        }

        /* Исключаем кнопки масштаба из фиксированной ширины */
        .zoom-controls .btn-primary,
        .zoom-controls .btn-secondary {
            width: auto;
        }

        .controls .btn-primary:hover,
        .controls .btn-secondary:hover {
            background: var(--color-primary-hover);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .btn-primary .btn-icon {
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));
        }

        .btn-secondary .btn-icon {
            filter: drop-shadow(0 1px 1px rgba(0,0,0,0.15));
        }

        /* Иконка PDF: стилизованный лист с уголком */
        .btn-icon-pdf::before {
            content: '';
            position: absolute;
            inset: 1px 3px 3px 3px;
            border-radius: 3px;
            border: 2px solid currentColor;
        }

        .btn-icon-pdf::after {
            content: '';
            position: absolute;
            top: 1px;
            right: 3px;
            width: 7px;
            height: 7px;
            border-top: 2px solid currentColor;
            border-right: 2px solid currentColor;
            border-radius: 0 3px 0 0;
        }

        /* Иконка Excel: таблица */
        .btn-icon-excel::before {
            content: '';
            position: absolute;
            inset: 2px;
            border-radius: 3px;
            border: 2px solid currentColor;
        }

        .btn-icon-excel::after {
            content: '';
            position: absolute;
            inset: 5px 3px;
            border-top: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            box-shadow: inset 0 0 0 1px transparent;
        }

        .btn-icon-excel {
            --col: currentColor;
        }

        .btn-icon-excel::before,
        .btn-icon-excel::after {
            color: inherit;
        }

        /* Иконка переключения вида: два прямоугольника */
        .btn-icon-toggle::before,
        .btn-icon-toggle::after {
            content: '';
            position: absolute;
            width: 7px;
            height: 10px;
            border-radius: 2px;
            border: 2px solid currentColor;
        }

        .btn-icon-toggle::before {
            left: 1px;
            top: 3px;
        }

        .btn-icon-toggle::after {
            right: 1px;
            top: 3px;
        }

        /* Иконка сброса: скрыта по умолчанию, появляется при наведении как ядерная кнопка */
        .btn-icon-reset {
            position: relative;
            width: 20px;
            height: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        /* Круг ядерной кнопки */
        .btn-icon-reset::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 16px;
            height: 16px;
            border: 2px solid currentColor;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        /* Треугольник внутри круга (символ ядерной кнопки) */
        .btn-icon-reset::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid currentColor;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }
        
        /* Показываем иконку при наведении с эффектом "без права на ошибку" */
        .reset-plan-btn:hover .btn-icon-reset {
            opacity: 1;
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.8));
        }
        
        .reset-plan-btn:hover .btn-icon-reset::before {
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
            animation: pulse-nuclear 1.5s ease-in-out infinite;
        }
        
        .reset-plan-btn:hover .btn-icon-reset::after {
            animation: pulse-nuclear-icon 1.5s ease-in-out infinite;
        }
        
        /* Анимация пульсации для эффекта "без права на ошибку" */
        @keyframes pulse-nuclear {
            0%, 100% {
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
            }
            50% {
                box-shadow: 0 0 12px rgba(255, 255, 255, 0.9);
            }
        }
        
        /* Пульсация иконки */
        @keyframes pulse-nuclear-icon {
            0%, 100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.1);
            }
        }

        /* Иконка таблицы для заголовка "Детальная таблица задач" */
        .btn-icon-table::before,
        .btn-icon-table::after {
            content: '';
            position: absolute;
        }

        .btn-icon-table::before {
            inset: 2px;
            border-radius: 3px;
            border: 2px solid currentColor;
        }

        .btn-icon-table::after {
            inset: 5px 3px;
            border-top: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
        }

        .btn-primary {
            background: var(--color-primary);
            color: white;
        }

        /* Стили для кнопки сохранения */
        #saveButton {
            background: #4caf50 !important;
            border-color: #4caf50 !important;
            font-weight: 600 !important;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3) !important;
            position: relative;
            display: none !important; /* Скрыта, так как работает автоматическое сохранение */
        }

        #saveButton:hover {
            background: #45a049 !important;
            border-color: #45a049 !important;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4) !important;
            transform: translateY(-2px);
        }

        #saveButton.saving-success {
            background: #4caf50 !important;
            border-color: #4caf50 !important;
        }

        #saveButton.saving-error {
            background: #f44336 !important;
            border-color: #f44336 !important;
        }

        #saveButton:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Скрыть кнопку сохранения в режиме просмотра */
        body.view-mode #saveButton {
            display: none !important;
        }

        .btn-primary:hover {
            background: var(--color-primary-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }

        .btn-secondary:hover {
            background: #e8e8e8;
        }

        /* Переключатель "Гант / Таблица" с подсветкой активного режима */
        .view-toggle-label {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            font-size: 13px;
            height: 100%;
        }

        .view-toggle-part {
            display: inline-flex;
            align-items: center;
            line-height: 1.2;
            padding: 2px 10px;
            border-radius: 999px;
            transition: background-color 0.4s ease, color 0.4s ease,
                        transform 0.4s ease, box-shadow 0.4s ease;
        }

        .view-toggle-part.active {
            background: #e3f2fd;
            color: var(--color-primary);
            font-weight: 600;
            box-shadow: 0 0 0 1px rgba(30,136,229,0.5);
        }

        .view-toggle-part:not(.active) {
            opacity: 0.75;
        }

        /* Кнопка переключателя Гант / Таблица — центрируем содержимое */
        .view-toggle-btn {
            justify-content: center !important;
            padding-left: 16px;
            padding-right: 16px;
        }

        /* Лёгкая подсветка активного блока (Гант / Таблица)
           Оставляем анимацию только по opacity/transform (GPU),
           чтобы не фризило из-за анимации высоты и отступов */
        .chart-container,
        .table-section {
            transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                        box-shadow 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        background-color 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        /* Начальное состояние - элемент скрыт и снизу */
        .chart-container:not(.view-active),
        .table-section:not(.view-active) {
            opacity: 0;
            transform: translateY(20px);
            max-height: 0;
            overflow: hidden;
            margin-bottom: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        /* Активный элемент - видим и на месте */
        .chart-container.view-active,
        .table-section.view-active {
            box-shadow: 0 0 0 2px #bbdefb, var(--shadow-md);
            background-color: #f9fcff;
            opacity: 1;
            transform: translateY(0);
            max-height: 2000px;
        }

        /* Скрытый элемент - уезжает вниз */
        .view-hidden {
            max-height: 0;
            opacity: 0;
            transform: translateY(20px);
            overflow: hidden;
            pointer-events: none;
            margin-bottom: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            transition: max-height 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                        box-shadow 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        background-color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                        margin-bottom 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-top 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-bottom 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Подсказка для кнопки "Сбросить план" в стиле редакции этапов */
        .reset-plan-btn {
            position: relative;
            width: 40px !important;
            height: 40px !important;
            min-width: 40px !important;
            border-radius: 50% !important;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%) !important;
            border: 2px solid #2c2c2c !important;
            color: #ffffff !important;
            box-shadow: 0 2px 8px rgba(238, 90, 82, 0.3);
            transition: all 0.3s ease;
            padding: 0 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            overflow: visible;
        }
        
        .reset-plan-btn:hover {
            background: linear-gradient(135deg, #ff5252 0%, #d63031 100%) !important;
            box-shadow: 0 4px 12px rgba(238, 90, 82, 0.5);
            transform: translateY(-2px) scale(1.05);
        }
        
        .reset-plan-btn:active {
            transform: translateY(0) scale(1);
            box-shadow: 0 2px 6px rgba(238, 90, 82, 0.4);
        }
        
        .reset-plan-btn .btn-icon {
            margin: 0 !important;
        }
        
        /* Блокировка кнопки "Сбросить план" в режиме просмотра (только визуальная, кнопка видна) */
        .reset-plan-btn.view-mode-disabled {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: auto; /* Разрешаем клики, но функция canEdit() заблокирует действие */
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%) !important;
            border: 1px solid #636e72 !important;
        }
        
        .reset-plan-btn.view-mode-disabled:hover {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%) !important;
            transform: none;
            box-shadow: 0 2px 8px rgba(238, 90, 82, 0.3);
        }

        .reset-plan-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translate(-50%, 0);
            padding: 4px 8px;
            border-radius: 6px;
            background: #000000;
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom center;
            z-index: 1001;
        }

        .reset-plan-btn:hover::after {
            opacity: 1;
            transform: translate(-50%, -6px);
            transition-delay: 1s;
        }

        /* Подсказка для длинного списка ответственных в таблице (чёрный фон, как у остальных) */
        .table-col-responsible[data-tooltip] {
            position: relative;
        }

        .table-col-responsible[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, 4px);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top center;
            z-index: 9999;
        }

        .table-col-responsible[data-tooltip]:hover::after {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        /* Подсказка для столбцов таблицы (этап, вид контроля, мероприятие) - чёрный фон, как у редакции этапов */
        .tasks-table td[data-tooltip] {
            position: relative;
        }

        .tasks-table td[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translate(-50%, 0);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.8) !important;
            color: #fff !important;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom center;
            z-index: 9999;
        }

        .tasks-table td[data-tooltip]:hover::after {
            opacity: 1 !important;
            transform: translate(-50%, -6px);
            transition-delay: 1s;
        }

        /* Подсказка для select "Связь" в таблице (чёрный фон, как у редакции этапов) */
        .tasks-table .link-select[data-tooltip] {
            position: relative;
        }

        .tasks-table .link-select[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translate(-50%, 0);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.8) !important;
            color: #fff !important;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom center;
            z-index: 9999;
        }

        .tasks-table .link-select[data-tooltip]:hover::after {
            opacity: 1 !important;
            transform: translate(-50%, -6px);
            transition-delay: 1s;
        }

        /* Подсказка для длинного списка ответственных в Ганте (чёрный фон, как у остальных) */
        .gantt-details-cell[data-tooltip] {
            position: relative;
        }

        .gantt-details-cell[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, 4px);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top center;
            z-index: 9999;
        }

        .gantt-details-cell[data-tooltip]:hover::after {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        /* Подсказка для select "Связь" в диаграмме Ганта (чёрный фон, как у редакции этапов) */
        .gantt-details-cell .link-select[data-tooltip] {
            position: relative;
        }

        .gantt-details-cell .link-select[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, 4px);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top center;
            z-index: 9999;
        }

        .gantt-details-cell .link-select[data-tooltip]:hover::after {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        /* Подсказка для столбца "Задача" в диаграмме Ганта (чёрный фон, как у остальных) */
        .gantt-label[data-tooltip] {
            position: relative;
            overflow: visible !important;
            clip-path: none !important; /* разрешаем подсказке выходить за пределы label */
        }

        /* При наведении поднимаем весь label выше заголовка */
        .gantt-label[data-tooltip]:hover {
            z-index: 100 !important; /* Выше заголовка (z-index: 11) */
        }

        .gantt-label[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 6px);
            left: 0;
            transform: translateY(0);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85) !important;
            color: #fff !important;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom left;
            z-index: 100000 !important; /* Очень высокий z-index для подсказки */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .gantt-label[data-tooltip]:hover::after {
            opacity: 1 !important;
            transform: translateY(-6px);
            transition-delay: 1s;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-group label {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text-secondary);
        }

        .form-group input {
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-size: 14px;
        }

        .pdf-content-toggle {
            gap: 10px;
        }

        .pdf-toggle-options {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .pdf-toggle-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            font-weight: 500;
            color: var(--color-text-primary);
        }

        .pdf-toggle-option input[type="radio"] {
            width: auto;
            accent-color: var(--color-primary);
        }

        .chart-container {
            background: var(--color-surface);
            padding: 20px 20px 20px 70px; /* Отступ слева 70px (20px padding + 50px для меток) */
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            overflow-x: auto;
            overflow-y: auto;
            max-height: 480px;
            margin-bottom: 20px;
            border-bottom: 3px solid var(--color-primary);
            position: relative; /* Для позиционирования меток этапов */
        }

        .gantt-chart {
            display: flex;
            flex-direction: column;
            min-width: 100%;
            font-size: 12px;
            position: relative;
            /* Убираем padding-left, так как он теперь в .chart-container */
            overflow-x: auto;
            overflow-y: visible;
            -webkit-overflow-scrolling: touch;
            /* Убеждаемся, что скроллбар всегда виден при переполнении */
            scrollbar-width: thin; /* Для Firefox */
            scrollbar-color: #90caf9 #e3f2fd; /* Для Firefox */
        }
        
        /* Стили скроллбара для десктопа */
        .gantt-chart::-webkit-scrollbar {
            height: 8px;
        }
        
        .gantt-chart::-webkit-scrollbar-thumb {
            background: #90caf9;
            border-radius: 4px;
        }
        
        .gantt-chart::-webkit-scrollbar-track {
            background: #e3f2fd;
        }

        /* Для планшетов и мобильных убираем contain, чтобы не блокировать прокрутку */
        @media (max-width: 1024px) {
            .gantt-chart {
                contain: none; /* Убираем contain для корректной прокрутки */
            }
        }

        .gantt-header {
            display: flex;
            margin-bottom: 2px;
            background: var(--color-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .gantt-header-first-row {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--color-bg);
        }

        .gantt-header-label {
            min-width: 180px;
            max-width: 180px;
            padding: 10px 10px;
            border-right: 2px solid var(--color-border);
            background: var(--color-bg);
            position: sticky;
            left: 0;
            z-index: 11;
            text-align: center;
            font-size: 16px;
            font-weight: 700;
            box-sizing: border-box;
            /* Ограничиваем область sticky, чтобы не выходила за пределы контейнера */
            clip-path: inset(0);
        }

        .gantt-details-header {
            display: flex;
        }

        .gantt-details-row {
            display: flex;
        }

        .gantt-details-cell {
            padding: 8px 6px;
            border-right: 1px solid var(--color-border);
            background: var(--color-bg);
            text-align: center;
            font-size: 11px;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        /* Анимация для колонки "Ответственный" в Ганте */
        .gantt-details-cell.link-cell {
            flex-basis: 0 !important;
            width: 0 !important;
            min-width: 0 !important;
            max-width: 0 !important;
            opacity: 0;
            overflow: hidden;
            padding-left: 0;
            padding-right: 0;
            margin-right: 0;
            border-right: none;
            flex-shrink: 0;
            flex-grow: 0;
            transition: flex-basis 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        max-width 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        min-width 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        width 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        padding-left 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-right 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        margin-right 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        border-right 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body.show-link .gantt-details-cell.link-cell {
            flex-basis: 70px !important;
            width: 70px !important;
            min-width: 50px !important;
            max-width: 70px !important;
            opacity: 1;
            padding-left: 4px;
            padding-right: 4px;
            margin-right: 0;
            border-right: 1px solid var(--color-border);
        }

        .gantt-details-cell.responsible-cell {
            flex-basis: 0 !important;
            width: 0 !important;
            min-width: 0 !important;
            max-width: 0 !important;
            opacity: 0;
            overflow: hidden;
            padding-left: 0;
            padding-right: 0;
            margin-right: 0;
            border-right: none;
            flex-shrink: 0;
            flex-grow: 0;
            transition: flex-basis 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        max-width 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        min-width 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        width 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        padding-left 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-right 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        margin-right 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        border-right 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body.show-responsible .gantt-details-cell.responsible-cell {
            flex-basis: 200px !important;
            width: 200px !important;
            min-width: 150px !important;
            max-width: 200px !important;
            opacity: 1;
            padding-left: 6px;
            padding-right: 6px;
            margin-right: 0;
            border-right: 1px solid var(--color-border);
        }

        .gantt-details-input {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            box-sizing: border-box;
        }

        /* Заблокированные поля в режиме просмотра */
        body.view-mode .gantt-details-input[readonly],
        body.view-mode .gantt-details-input[data-field="startDate"],
        body.view-mode .gantt-details-input[data-field="endDate"],
        body.view-mode .gantt-details-input[data-field="days"],
        body.view-mode .gantt-details-input[disabled] {
            background-color: #f5f5f5;
            color: #666;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .gantt-resizable {
            position: relative;
        }

        .gantt-resizer {
            position: absolute;
            top: 0;
            right: -2px;
            width: 4px;
            height: 100%;
            cursor: col-resize;
            z-index: 20;
        }

        .gantt-header-dates-row {
            display: flex;
            flex: 1;
        }

        .gantt-header-month-row {
            display: flex;
            background: var(--color-bg);
            font-weight: 600;
            margin-bottom: 2px;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .gantt-header-month-label {
            flex: 1;
            text-align: center;
            padding: 8px 0;
            font-size: 14px;
            border-bottom: 2px solid var(--color-border);
            background: #f9f9f9;
        }

        .gantt-header-month-spacer {
            min-width: 300px;
        }

        .gantt-header-cell {
            min-width: 60px;
            padding: 10px 5px;
            text-align: center;
            border-right: 1px solid var(--color-border);
            border-bottom: 2px solid var(--color-border);
            background: var(--color-primary);
            color: white;
            line-height: 1.1;
        }

        .gantt-header-week-days {
            display: block;
        }

        .gantt-header-week-month {
            display: block;
            margin-top: 2px;
            font-size: 11px;
        }

        /* Контейнер для меток этапов - позиционируется слева от таблицы */
        .gantt-stage-labels {
            position: absolute;
            left: 0; /* Слева от контейнера (с учетом padding) */
            top: 0;
            width: 50px;
            z-index: 15;
            pointer-events: none; /* Контейнер не блокирует события, но метки этапов будут кликабельны */
            background: transparent;
            /* Временный фон для отладки - можно убрать после проверки */
            /* background: rgba(255, 0, 0, 0.1); */
        }

        /* Кнопки управления сворачиванием всех этапов */
        .gantt-stage-controls {
            position: absolute;
            left: 0;
            top: 0;
            width: 50px;
            height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            z-index: 30;
            pointer-events: auto;
            background: rgba(30, 136, 229, 0.1);
            border-right: 2px solid var(--color-primary);
            border-bottom: 1px solid rgba(30, 136, 229, 0.3);
        }

        .gantt-stage-control-btn {
            width: 32px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
            user-select: none;
        }

        .gantt-stage-control-btn:hover {
            background: rgba(30, 136, 229, 0.9);
            transform: scale(1.05);
        }

        .gantt-stage-control-btn:active {
            transform: scale(0.95);
        }

        /* Метка этапа */
        .gantt-stage-label {
            position: absolute;
            left: 0;
            width: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(30, 136, 229, 0.1);
            border-right: 2px solid var(--color-primary);
            color: var(--color-primary);
            font-weight: 600;
            font-size: 0.75rem;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg); /* Вертикальное положение (12 часов) */
            white-space: nowrap;
            padding: 8px 4px;
            box-sizing: border-box;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.3s ease, writing-mode 0.3s ease, width 0.3s ease, height 0.3s ease, background 0.2s ease;
            z-index: 20;
            user-select: none;
            pointer-events: auto; /* Метки этапов кликабельны */
        }

        /* Hover эффект для метки этапа */
        .gantt-stage-label:hover {
            background: rgba(30, 136, 229, 0.25);
            border-right-color: rgba(30, 136, 229, 0.8);
        }

        /* Свернутое состояние метки этапа (горизонтальное) */
        .gantt-stage-label.collapsed {
            writing-mode: horizontal-tb;
            text-orientation: unset;
            transform: rotate(270deg); /* Поворот на 90 градусов по часовой стрелке (с 12 на 3 часа) */
            width: auto;
            min-width: 100px;
            height: 35px;
            padding: 8px 12px;
            position: absolute;
            left: 0;
            z-index: 25;
            pointer-events: auto; /* Свернутые метки также кликабельны */
        }

        /* Анимация для скрытия строк задач */
        .gantt-row.collapsing {
            animation: collapseRow 0.3s ease forwards;
            overflow: hidden;
        }

        .gantt-row.expanding {
            animation: expandRow 0.3s ease forwards;
            overflow: hidden;
        }

        @keyframes collapseRow {
            from {
                max-height: 35px;
                opacity: 1;
                margin-bottom: 0;
            }
            to {
                max-height: 0;
                opacity: 0;
                margin-bottom: 0;
                padding-top: 0;
                padding-bottom: 0;
            }
        }

        @keyframes expandRow {
            from {
                max-height: 0;
                opacity: 0;
                margin-bottom: 0;
                padding-top: 0;
                padding-bottom: 0;
            }
            to {
                max-height: 35px;
                opacity: 1;
                margin-bottom: 0;
            }
        }

        /* Скрытые строки задач */
        .gantt-row.stage-collapsed {
            display: none;
        }

        /* Анимация для скрытия строк в таблице задач */
        #tasksTableBody tr.collapsing {
            animation: collapseRow 0.3s ease forwards;
            overflow: hidden;
        }

        #tasksTableBody tr.expanding {
            animation: expandRow 0.3s ease forwards;
            overflow: hidden;
        }

        #tasksTableBody tr.stage-collapsed {
            display: none;
        }

        /* Строка этапа (свернутое состояние) */
        .gantt-row.stage-row-collapsed,
        #tasksTableBody tr.stage-row-collapsed {
            background: rgba(30, 136, 229, 0.05);
            cursor: pointer;
            height: 35px;
            min-height: 35px;
            max-height: 35px;
        }

        .gantt-row.stage-row-collapsed:hover,
        #tasksTableBody tr.stage-row-collapsed:hover {
            background: rgba(30, 136, 229, 0.15);
        }

        .gantt-row.stage-row-collapsed .gantt-label span,
        #tasksTableBody tr.stage-row-collapsed td span {
            font-weight: 600;
            color: var(--color-primary);
        }

        /* Разделительная полоса между этапами - позиционируется слева от таблицы */
        .gantt-stage-divider {
            position: absolute;
            left: 0; /* Слева от контейнера (с учетом padding) */
            width: 50px;
            height: 2px;
            background: var(--color-primary);
            z-index: 12;
            pointer-events: none;
            opacity: 0.6;
        }

        .gantt-row {
            display: flex;
            border-bottom: 1px solid var(--color-border);
            min-height: 35px;
            align-items: center;
            transition: background 0.15s ease, box-shadow 0.15s ease, max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease, padding 0.3s ease;
            overflow: visible; /* Разрешаем подсказкам выходить за пределы строки */
        }

        .gantt-row:hover {
            background: #f9f9f9;
        }

        .gantt-row.selected {
            background: #bbdefb;
            box-shadow: inset 0 0 0 1px #64b5f6;
        }

        /* При выделении задачи подсвечиваем и название, и три колонки с датами/днями,
           чтобы визуально вся строка в Ганте вела себя так же, как строка в таблице */
        .gantt-row.selected .gantt-label,
        .gantt-row.selected .gantt-details-cell {
            background: #bbdefb;
        }

        .gantt-row.dragging {
            opacity: 0.6;
        }

        .gantt-row-drop-target {
            background: #e3f2fd;
            box-shadow: inset 0 3px 0 var(--color-primary);
        }

        .gantt-label {
            min-width: 180px;
            padding: 8px 10px;
            border-right: 2px solid var(--color-border);
            background: var(--color-bg);
            font-weight: 500;
            font-size: 11px;
            position: sticky;
            left: 0;
            z-index: 5;
            box-sizing: border-box;
            /* Ограничиваем область sticky, чтобы не выходила за пределы контейнера */
            clip-path: inset(0);
            overflow: visible;
            white-space: nowrap;
        }

        .gantt-label span {
            display: inline-block;
            max-width: 100%;
            overflow: visible;
            white-space: nowrap;
        }

        .gantt-task-input {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--color-primary);
            box-sizing: border-box;
        }

        .gantt-cell {
            min-width: 60px;
            height: 100%;
            border-right: 1px solid var(--color-border);
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Жёлтая полоска директивного плана (baseline) под основным баром */
        .baseline-bar {
            position: absolute;
            left: 3px;
            right: 3px;
            height: 4px;
            bottom: 2px;
            background: #ffd54f;
            border-radius: 2px;
            pointer-events: none; /* не мешает кликам по основному бару */
            opacity: 0.9;
        }

        .gantt-bar {
            height: 24px;
            background: linear-gradient(135deg, var(--color-primary) 0%, #0b5ed7 100%);
            border-radius: 3px;
            border: 1px solid var(--color-primary-hover);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            width: 100%;
        }

        .gantt-bar:hover {
            transform: scaleY(1.2);
            box-shadow: var(--shadow-md);
            background: linear-gradient(135deg, var(--color-primary-hover) 0%, #073a3d 100%);
        }

        /* Выделение ячеек для мультивыбора */
        .gantt-bar.cell-selected {
            box-shadow: 0 0 0 2px #2196f3, 0 0 8px rgba(33, 150, 243, 0.6);
            outline: 2px solid #2196f3;
            outline-offset: -2px;
            z-index: 10;
        }

        .gantt-bar.completed {
            background: linear-gradient(135deg, var(--color-success) 0%, #388e3c 100%);
            border-color: #2e7d32;
        }

        .gantt-bar.in-progress {
            background: linear-gradient(135deg, var(--color-warning) 0%, #f57c00 100%);
            border-color: #e65100;
        }

        /* В режиме сплошных полос убираем зазоры между днями, бары выглядят как единая линия */
        body.gantt-style-segments .gantt-cell {
            padding: 0;
            border-right: none;
        }

        body.gantt-style-segments .gantt-bar {
            border-radius: 0;
            width: 100%;
            /* Однородные цвета без градиента, чтобы визуально получалась сплошная полоса */
            background: var(--color-primary);
            border-color: var(--color-primary-hover);
        }

        body.gantt-style-segments .gantt-bar.in-progress {
            background: var(--color-warning);
            border-color: #e65100;
        }

        body.gantt-style-segments .gantt-bar.completed {
            background: var(--color-success);
            border-color: #2e7d32;
        }

        /* В режиме полос сглаживаем середину и оставляем скругление только на краях непрерывного отрезка */
        body.gantt-style-segments .gantt-bar.segment-middle {
            border-radius: 0;
            border-left: none;
            border-right: none;
        }

        body.gantt-style-segments .gantt-bar.segment-start {
            border-radius: 12px 0 0 12px;
            border-right: none;
        }

        body.gantt-style-segments .gantt-bar.segment-end {
            border-radius: 0 12px 12px 0;
            border-left: none;
        }

        /* Одиночный сегмент (задача не тянется на соседние интервалы)
           — скругляем оба края, чтобы не было «острых» концов. */
        body.gantt-style-segments .gantt-bar.segment-single {
            border-radius: 12px;
        }

        body.gantt-style-segments .gantt-bar:hover {
            transform: scaleY(1.05);
            box-shadow: var(--shadow-md);
        }

        .gantt-weekend {
            background: #ffe0e0;
        }

        .gantt-holiday {
            background: #fff9c4;
        }

        /* Ячейки будущего периода (после конца плана) */
        .gantt-future-header {
            background: #d4d4d4;
            color: #555555;
        }

        .gantt-future-cell {
            background: #f1f1f1;
        }

        /* Колонка "Ответственный" в таблице задач — управляем видимостью через класс на body */
        .table-col-responsible {
            display: table-cell;
            width: 0 !important;
            min-width: 0 !important;
            max-width: 0 !important;
            opacity: 0;
            overflow: hidden;
            padding-left: 0;
            padding-right: 0;
            border-left: none;
            border-right: none;
            white-space: nowrap;
            transition: width 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        max-width 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        min-width 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        opacity 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                        padding-left 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-right 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        border-left 0.7s cubic-bezier(0.4, 0, 0.2, 1), 
                        border-right 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .table-col-link {
            display: none;
        }

        body.show-link .table-col-link {
            display: table-cell;
            width: 70px !important;
            min-width: 50px !important;
            max-width: 70px !important;
        }

        body.show-responsible .table-col-responsible {
            width: 200px !important;
            min-width: 150px !important;
            max-width: 300px !important;
            opacity: 1;
            padding-left: 12px;
            padding-right: 12px;
            border-left: 1px solid var(--color-border);
            border-right: 1px solid var(--color-border);
        }

        /* Подсказка-комментарий для ячеек Ганта */
        .gantt-bar[data-tooltip] {
            position: relative;
            z-index: 5; /* поднимаем ячейку над шкалой дат */
        }

        .gantt-bar[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translate(-50%, 4px);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            white-space: pre-line;
            width: 300px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            text-align: left;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top center;
            z-index: 9999; /* всегда поверх дат и других элементов Ганта */
        }

        .gantt-bar[data-tooltip]:hover::after {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        .status-comment-input {
            width: 100%;
            resize: vertical;
            min-height: 70px;
            padding: 6px 8px;
            font-size: 13px;
            border-radius: 6px;
            border: 1px solid var(--color-border);
        }

        /* Меню статуса задачи по дате */
        .status-menu {
            position: fixed;
            z-index: 200;
            background: var(--color-surface);
            border-radius: 6px;
            box-shadow: var(--shadow-md);
            padding: 8px 0;
            min-width: 180px;
            border: 1px solid var(--color-border);
            display: none;
        }

        @media (max-width: 480px) {
            .status-menu {
                min-width: 160px;
                padding: 6px 0;
            }
        }

        .status-menu-item {
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-menu-item:hover {
            background: #f5f5f5;
        }

        .status-color-box {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid #999;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding: 15px;
            background: var(--color-bg);
            border-radius: 6px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .legend {
                gap: 15px;
                padding: 12px;
                margin-top: 15px;
            }
        }

        @media (max-width: 480px) {
            .legend {
                gap: 10px;
                padding: 10px;
                margin-top: 12px;
            }
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        @media (max-width: 480px) {
            .legend-item {
                font-size: 0.7rem;
                gap: 6px;
            }

            .status-color-box {
                width: 12px;
                height: 12px;
            }
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #999;
        }

        .stats {
            background: var(--color-surface);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-sm);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            border-bottom: 3px solid var(--color-primary);
        }

        .stat-card {
            padding: 15px;
            background: var(--color-bg);
            border-left: 4px solid var(--color-primary);
            border-radius: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--color-primary);
        }

        .table-section {
            background: var(--color-surface);
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            margin-bottom: 20px;
            margin-top: 0;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 600px;
            border-bottom: 3px solid var(--color-primary);
        }

        .table-section h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: var(--color-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        th {
            background: var(--color-primary);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border: 1px solid var(--color-primary-hover);
        }

        /* Шапка таблицы задач: делаем подписи крупнее и по центру */
        #tasksTable thead th {
            font-size: 13px;
            text-align: center;
            vertical-align: middle;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        td {
            padding: 10px 12px;
            border: 1px solid var(--color-border);
            /* Разрешаем перенос текста в ячейках для корректного отображения длинного текста */
            white-space: normal;
        }

        .tasks-table-input {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            /* Убираем обрезку текста - при расширении столбца текст будет виден полностью */
            overflow: visible !important;
            text-overflow: clip !important;
            white-space: normal !important;
            word-wrap: break-word;
        }
        
        /* Дополнительная специфичность для input полей в таблице */
        .tasks-table td .tasks-table-input {
            overflow: visible !important;
            text-overflow: clip !important;
            white-space: normal !important;
        }

        .tasks-table-input[type="number"] {
            text-align: center;
        }

        /* Заблокированные поля в режиме просмотра */
        body.view-mode .tasks-table-input[readonly],
        body.view-mode .tasks-table-input[data-field="startDate"],
        body.view-mode .tasks-table-input[data-field="endDate"],
        body.view-mode .tasks-table-input[data-field="days"],
        body.view-mode .tasks-table-input[data-field="stageSuffix"],
        body.view-mode .tasks-table-input[data-field="control"],
        body.view-mode .tasks-table-input[data-field="taskTitle"] {
            background-color: #f5f5f5;
            color: #666;
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Заблокированные select в режиме просмотра */
        body.view-mode .tasks-table-input-select[disabled] {
            background-color: #f5f5f5;
            color: #666;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .tasks-table-input-select {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            background: #fff;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        tr:hover {
            background: #f0f0f0;
        }

        tr.selected {
            background: #bbdefb !important;
        }

        /* Подсветка/затемнение задач при фильтрации по этапам */
        .gantt-row.stage-active {
            background: #e3f2fd;
        }

        .gantt-row.inactive {
            opacity: 0.25;
            filter: grayscale(0.4);
            pointer-events: none;
        }

        tr.stage-active {
            background: #e3f2fd;
        }

        tr.inactive {
            opacity: 0.4;
            color: #aaaaaa;
            pointer-events: none;
        }

        tr.dragging {
            opacity: 0.6;
        }

        tr.table-row-drop-target {
            background: #e3f2fd;
            box-shadow: inset 0 3px 0 var(--color-primary);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.75);
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
        }

        .modal[style*="display: block"],
        .modal[style*="display: flex"],
        .modal.show {
            display: flex !important;
        }

        .baseline-toast {
            position: fixed;
            left: 50%;
            top: 50%;
            max-width: 320px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 13px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, calc(-50% + 10px));
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 10000;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .baseline-toast {
                max-width: calc(100% - 30px);
                font-size: 11px;
                padding: 10px 14px;
            }
        }

        @media (max-width: 480px) {
            .baseline-toast {
                max-width: calc(100% - 20px);
                font-size: 10px;
                padding: 8px 12px;
            }
        }

        .baseline-toast.visible {
            opacity: 1;
            transform: translate(-50%, -50%);
        }

        /* Окно удаления этапа всегда поверх окна настроек этапов */
        #stageDeleteModal {
            z-index: 10001;
        }

        /* Окно переименования этапа всегда поверх окна настроек этапов */
        #renameStageModal {
            z-index: 10001;
        }

        /* Модальное окно предупреждения о масштабе - всегда поверх всего */
        #scaleWarningModal {
            z-index: 10002 !important;
        }

        .modal-content {
            background-color: var(--color-surface);
            margin: auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: calc(100vh - 40px);
            box-shadow: var(--shadow-md);
            position: relative;
            align-self: center;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 10001;
        }

        /* Обеспечиваем кликабельность кнопок в модальных окнах */
        .modal-content .btn {
            pointer-events: auto !important;
            position: relative;
            z-index: 10002;
        }
        

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .modal-header h2 {
            font-size: 18px;
            color: var(--color-primary);
        }

        /* Стили для модального окна ввода текста */
        .text-input-modal-textarea {
            width: 100%;
            padding: 12px;
            font-size: 14px;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-family: inherit;
            resize: vertical;
            min-height: 120px;
            box-sizing: border-box;
        }

        .text-input-modal-textarea:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }

        @media (max-width: 768px) {
            .text-input-modal-textarea {
                font-size: 16px; /* Предотвращает зум на iOS */
                min-height: 100px;
            }
        }

        .stage-settings-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .stage-settings-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px dashed var(--color-border);
            background: #fafafa;
            cursor: grab;
        }

        .stage-settings-item.dragging {
            opacity: 0.7;
            background: #e3f2fd;
        }

        .stage-settings-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stage-settings-handle {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: var(--color-muted);
        }

        .stage-settings-name {
            font-size: 14px;
            font-weight: 500;
            cursor: default;
        }

        .stage-settings-name.editable {
            border-bottom: 1px dashed var(--color-border);
        }

        .stage-settings-delete-btn {
            border: none;
            background: transparent;
            color: #d32f2f;
            cursor: pointer;
            font-size: 13px;
            padding: 4px 8px;
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .stage-settings-delete-btn:hover {
            background: #ffebee;
        }

        .stage-settings-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 16px;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--color-text-secondary);
        }

        .close:hover {
            color: var(--color-text);
        }

        .hidden {
            display: none;
        }

        .stage-tabs-container {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
        }

        .stage-tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            flex: 1;
        }

        .stage-tabs-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            overflow: visible;
            position: relative;
        }

        .undo-btn {
            padding: 10px 14px;
            border-radius: 20px;
            border: 2px solid #1976d2;
            background: #2196f3 !important;
            color: #ffffff !important;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 3px 10px rgba(33, 150, 243, 0.4);
            width: 44px;
            height: 44px;
            text-align: center;
            display: inline-flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 100;
            white-space: nowrap;
            margin-right: 0;
            flex-shrink: 0;
        }
        
        /* Подсказка для кнопки отмены (чёрный фон, как у редакции этапов) */
        .undo-btn[data-tooltip] {
            position: relative;
        }
        
        .undo-btn[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85) !important;
            color: #fff !important;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom center;
            z-index: 9999;
        }
        
        .undo-btn[data-tooltip]:hover::after {
            opacity: 1 !important;
            transform: translateX(-50%) translateY(-6px);
            transition-delay: 1s;
        }

        .undo-btn:hover:not(.disabled) {
            background: #1976d2 !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
            border-color: #1565c0;
        }

        .undo-btn.disabled {
            background: #f5f5f5;
            border-color: #e0e0e0;
            color: #bdbdbd;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .undo-btn::before {
            content: '';
        }

        .stage-tab-btn {
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--color-primary);
            background: #e3f2fd;
            color: var(--color-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
            min-width: 120px;
            text-align: center;
        }

        .stage-tab-btn:hover {
            background: #bbdefb;
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .stage-tab-btn.active {
            background: var(--color-primary);
            color: #fff;
            box-shadow: var(--shadow-md);
        }

        /* Кнопка "Ответственный" — по размеру и форме как переключатель вида,
           но с цветами, как у табов этапов. */
        .responsible-toggle-btn {
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        /* Кнопка "Задать базовый план" — такой же стиль как "Ответственный" и "Детальный вид" */
        .baseline-set-btn {
            padding: 6px 14px !important;
            border-radius: 999px !important;
            font-size: 12px !important;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        /* Кнопка "Связь" — такой же стиль как кнопка "Директивный план" */
        .link-toggle-btn {
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid var(--color-primary);
            background: #e3f2fd;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            color: var(--color-primary);
            box-shadow: var(--shadow-sm);
            transition:
                background 0.25s ease,
                color 0.25s ease,
                box-shadow 0.25s ease,
                transform 0.25s ease;
        }

        .link-toggle-btn.active {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-hover) 100%);
            color: #ffffff;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .link-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        /* Кнопка "Директивный план" — такой же стиль как остальные кнопки */
        .baseline-toggle-btn {
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid var(--color-primary);
            background: #e3f2fd;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            color: var(--color-primary);
            box-shadow: var(--shadow-sm);
            transition:
                background 0.25s ease,
                color 0.25s ease,
                box-shadow 0.25s ease,
                transform 0.25s ease;
        }

        .baseline-toggle-btn.active {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-hover) 100%);
            color: #ffffff;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .baseline-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        /* Кнопка переключения стиля баров в Ганте (детальный / общий вид).
           В неактивном состоянии соответствует «Детальному виду» и выглядит как таб этапов
           (голубой фон, синий бордер). В активном состоянии показывает «Общий вид» и
           становится синей «пилюлей». */
        .gantt-style-toggle-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid var(--color-primary);
            background: #e3f2fd;
            font-size: 12px;
            cursor: pointer;
            color: var(--color-primary);
            box-shadow: var(--shadow-sm);
            transition:
                background 0.25s ease,
                color 0.25s ease,
                box-shadow 0.25s ease,
                transform 0.25s ease;
        }

        .gantt-style-toggle-btn span {
            white-space: nowrap;
        }

        .gantt-style-toggle-btn.active {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-hover) 100%);
            color: #ffffff;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .gantt-style-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .stage-settings-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 32px;
            border-radius: 10px;
            border: 1px solid var(--color-primary);
            background: #e3f2fd;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: background 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
            position: relative;
        }

        .stage-settings-btn:hover {
            background: #bbdefb;
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        /* Скрываем кнопку редактирования этапов в режиме просмотра */
        body.view-mode .stage-settings-btn {
            display: none;
        }

        /* Подсказки для кнопок с двумя строками (data-tooltip-line1 и data-tooltip-line2) */
        .stage-settings-btn[data-tooltip-line1]::after,
        .gantt-style-toggle-btn[data-tooltip-line1]::after,
        .baseline-toggle-btn[data-tooltip-line1]::after {
            content: attr(data-tooltip-line1) "\A" attr(data-tooltip-line2);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translate(-50%, 0);
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 11px;
            white-space: pre;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom center;
            text-align: left;
            line-height: 1.4;
            min-width: 200px;
        }

        /* Подсказки для кнопок с одной строкой (data-tooltip) */
        .stage-settings-btn[data-tooltip]:not([data-tooltip-line1])::after,
        .gantt-style-toggle-btn[data-tooltip]:not([data-tooltip-line1])::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translate(-50%, 0);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom center;
            z-index: 9999;
        }

        .baseline-set-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translate(-50%, 0);
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom center;
        }

        .stage-settings-btn:hover::after,
        .gantt-style-toggle-btn:hover::after,
        .baseline-toggle-btn:hover::after {
            opacity: 1;
            transform: translate(-50%, -6px);
            transition-delay: 1s;
        }

        /* Hover для подсказок с одной строкой */
        .stage-settings-btn[data-tooltip]:not([data-tooltip-line1]):hover::after,
        .gantt-style-toggle-btn[data-tooltip]:not([data-tooltip-line1]):hover::after {
            opacity: 1 !important;
            transform: translate(-50%, -6px);
            transition-delay: 1s;
        }

        .baseline-set-btn:hover::after {
            opacity: 1;
            transform: translate(-50%, -6px);
            transition-delay: 1s;
        }

        .stage-settings-icon {
            position: relative;
            width: 18px;
            height: 16px;
        }

        .stage-settings-bar {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--color-primary);
            border-radius: 999px;
        }

        .stage-settings-bar-1 {
            top: 2px;
        }

        .stage-settings-bar-2 {
            top: 7px;
        }

        .stage-settings-bar-3 {
            top: 12px;
        }

        .stage-settings-knob {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            border: 2px solid var(--color-primary);
            background: #fff;
        }

        .stage-settings-knob-1 {
            top: -1px;
            left: 2px;
        }

        .stage-settings-knob-2 {
            top: 4px;
            right: 2px;
        }

        .stage-settings-knob-3 {
            top: 9px;
            left: 6px;
        }

        /* Адаптивность для планшетов и мобильных */
        @media (max-width: 1024px) {
            .container {
                max-width: 100%;
                padding: 15px;
            }

            header {
                padding: 25px 15px;
            }

            header h1 {
                font-size: 1.4rem;
            }

            .header-subtitle {
                font-size: 0.9rem;
            }

            .company-info {
                flex-direction: column;
                gap: 20px;
                align-items: center;
            }

            .company-logo-display {
                width: 100%;
                max-width: 300px;
                justify-content: center;
                margin: 0 auto;
            }
            
            .company-logo-preview {
                margin: 0 auto;
            }

            .company-name-block {
                width: 100%;
                text-align: center;
            }

            .controls {
                flex-wrap: wrap;
                gap: 10px;
            }

            .btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }

            /* Для планшетов включаем прокрутку графика */
            .chart-container {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                touch-action: pan-x pan-y pinch-zoom; /* Разрешаем pinch-to-zoom */
            }

            .gantt-chart {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                touch-action: pan-x pan-y pinch-zoom; /* Разрешаем pinch-to-zoom */
                min-width: 100%;
            }

            .gantt-label {
                min-width: 120px;
                font-size: 0.75rem;
            }

            .gantt-header-cell {
                min-width: 35px;
                font-size: 0.7rem;
            }

            /* Кнопки управления на планшетах - вертикальное выравнивание с одинаковыми отступами */
            .profile-btn,
            .companies-btn,
            .companies-bottom-btn,
            .logout-btn {
                width: 40px;
                height: 40px;
                right: 25px !important;
            }

            .profile-btn {
                top: 25px;
            }

            .companies-bottom-btn {
                top: 77px; /* 25px (top первой) + 40px (высота первой) + 12px (отступ) = 77px */
            }

            .logout-btn {
                top: 129px; /* 77px (top второй) + 40px (высота второй) + 12px (отступ) = 129px */
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            header {
                padding: 20px 15px;
                margin-bottom: 20px;
            }

            header h1 {
                font-size: 1.2rem;
                line-height: 1.3;
            }

            .header-subtitle {
                font-size: 0.85rem;
                margin-top: 8px;
            }

            .company-info {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
                align-items: center;
            }

            .company-logo-display {
                width: 100%;
                max-width: 250px;
                justify-content: center;
                margin: 0 auto;
            }

            .company-logo-preview {
                max-width: 200px;
                max-height: 150px;
                margin: 0 auto;
                display: block;
            }

            .company-name-display {
                font-size: 1.2rem;
                padding: 10px;
            }

            .controls {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .controls-left,
            .controls-right {
                width: 100%;
                flex-direction: column;
                gap: 10px;
            }

            .btn {
                width: 100%;
                padding: 12px;
                font-size: 0.9rem;
                justify-content: center;
                min-height: 44px; /* Минимальный размер для touch на iOS */
                touch-action: manipulation; /* Улучшает отзывчивость на touch */
            }

            .btn-icon {
                margin-right: 8px;
            }

            /* Кнопки управления на мобильных - вертикальное выравнивание с одинаковыми отступами */
            .profile-btn,
            .companies-btn,
            .companies-bottom-btn,
            .logout-btn {
                width: 38px;
                height: 38px;
                right: 15px !important;
            }

            .profile-btn {
                top: 15px;
            }

            .companies-bottom-btn {
                top: 65px; /* 15px (top первой) + 38px (высота первой) + 12px (отступ) = 65px */
            }

            .logout-btn {
                top: 115px; /* 65px (top второй) + 38px (высота второй) + 12px (отступ) = 115px */
            }

            .profile-btn::before {
                width: 18px;
                height: 18px;
                border-width: 2.5px;
            }

            .companies-btn::before {
                width: 16px;
                height: 16px;
                border-width: 1.5px;
            }

            .logout-btn::before {
                border-right-width: 10px;
                border-top-width: 7px;
                border-bottom-width: 7px;
            }

            /* График Ганта на мобильных */
            .chart-container {
                isolation: isolate;
                contain: layout style;
                position: relative;
                z-index: 1;
                max-width: 100%;
                overflow: hidden;
            }

            .gantt-chart {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                position: relative;
                max-width: 100%;
                box-sizing: border-box;
                z-index: 1;
                touch-action: pan-x pan-y pinch-zoom; /* Разрешаем прокрутку и pinch-to-zoom на планшетах и мобильных */
                /* Убеждаемся, что скроллбар всегда виден при переполнении */
                scrollbar-width: thin; /* Для Firefox */
                scrollbar-color: #90caf9 #e3f2fd; /* Для Firefox */
            }

            /* На мобильных отключаем sticky для колонки названий, чтобы она не перекрывала график */
            .gantt-header-label,
            .gantt-label {
                position: static !important; /* Отключаем sticky на мобильных */
                max-width: 100%;
                width: 100%;
                min-width: auto;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                z-index: auto;
            }

            /* Ячейки графика */
            .gantt-row .gantt-cell {
                position: relative;
                z-index: 1;
                background: var(--color-bg);
            }

            .gantt-chart::-webkit-scrollbar {
                height: 8px;
            }

            .gantt-chart::-webkit-scrollbar-thumb {
                background: #90caf9;
                border-radius: 4px;
            }

            .gantt-chart::-webkit-scrollbar-track {
                background: #e3f2fd;
            }

            .gantt-label {
                min-width: 120px;
                max-width: 120px;
                width: 120px;
                font-size: 0.7rem;
                padding: 8px 6px;
                z-index: auto;
                position: static !important; /* Отключаем sticky на мобильных */
            }

            .gantt-header-label {
                min-width: 120px;
                max-width: 120px;
                width: 120px;
                z-index: auto;
                position: static !important; /* Отключаем sticky на мобильных */
            }

            /* Убеждаемся, что график не перекрывается */
            .gantt-cell,
            .gantt-header-cell {
                position: relative;
                z-index: 1;
            }

            .gantt-header-cell {
                min-width: 30px;
                font-size: 0.65rem;
                padding: 6px 4px;
            }

            .gantt-cell {
                min-width: 30px;
            }

            .gantt-bar {
                min-width: 20px;
            }

            /* Таблица задач на мобильных */
            .table-section {
                position: relative;
                z-index: 1;
                max-width: 100%;
                overflow-x: auto;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Отключаем sticky для шапки таблицы на мобильных, чтобы не блокировать прокрутку */
            #tasksTable thead th {
                position: static !important;
            }

            .tasks-table-wrapper {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                position: relative;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                touch-action: pan-x pan-y pinch-zoom; /* Разрешаем прокрутку и pinch-to-zoom на мобильных */
            }

            .tasks-table-wrapper::-webkit-scrollbar {
                height: 8px;
            }

            .tasks-table-wrapper::-webkit-scrollbar-thumb {
                background: #90caf9;
                border-radius: 4px;
            }

            .tasks-table-wrapper::-webkit-scrollbar-track {
                background: #e3f2fd;
            }

            .tasks-table {
                width: 100%;
                font-size: 0.85rem;
                min-width: 800px; /* Минимальная ширина для читаемости */
            }

            .tasks-table th,
            .tasks-table td {
                padding: 8px 6px;
                font-size: 0.8rem;
            }

            .tasks-table-input {
                padding: 6px 8px;
                font-size: 0.8rem;
            }

            /* Статистика */
            .statistics {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }

            .stat-item {
                width: 100%;
                padding: 12px;
            }

            /* Этапы */
            .stage-tabs {
                flex-wrap: wrap;
                gap: 8px;
                padding: 10px;
                flex-direction: column;
            }

            .stage-tabs-buttons {
                width: 100%;
                display: flex;
                flex-direction: column; /* Вертикальное расположение на планшетах */
                gap: 8px;
            }

            .stage-tab-btn {
                width: 100%; /* Все кнопки одинаковой ширины */
                padding: 10px 12px;
                font-size: 0.85rem;
                min-height: 44px;
            }

            /* Контейнер с дополнительными кнопками тоже вертикально на планшетах */
            .stage-controls-buttons {
                flex-direction: column !important;
                width: 100%;
                gap: 8px !important;
            }

            /* Одинаковый размер всех кнопок на планшетах - одинаковой ширины */
            .responsible-toggle-btn,
            .gantt-style-toggle-btn,
            .baseline-set-btn,
            .baseline-toggle-btn,
            .stage-settings-btn {
                width: 100%; /* Все кнопки одинаковой ширины */
                padding: 10px 12px;
                font-size: 0.8rem;
                min-height: 44px;
                justify-content: center;
            }

            /* Уменьшаем размер текста кнопок на планшетах */
            .link-toggle-btn {
                font-size: 0.75rem;
            }
            .baseline-toggle-btn {
                font-size: 0.75rem;
            }

            /* Убираем min-width для кнопки "Ответственный" на планшетах */
            .stage-tab-btn.responsible-toggle-btn {
                min-width: auto;
                flex: 0 0 auto;
            }

            .stage-tab {
                padding: 8px 12px;
                font-size: 0.85rem;
            }

            /* Модальные окна */
            .modal-content {
                width: 95%;
                max-width: 95%;
                padding: 20px 15px;
                margin: 10% auto;
            }

            .modal-header h2 {
                font-size: 1.3rem;
            }

            .profile-modal-content {
                width: 95%;
                max-width: 95%;
                padding: 20px 15px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 8px;
            }

            header {
                padding: 15px 12px;
                margin-bottom: 15px;
            }

            header h1 {
                font-size: 1rem;
                line-height: 1.2;
            }

            .header-subtitle {
                font-size: 0.75rem;
                margin-top: 6px;
            }

            .company-info {
                padding: 12px;
                align-items: center;
            }
            
            .company-logo-display {
                justify-content: center;
                margin: 0 auto;
            }

            .company-logo-preview {
                max-width: 150px;
                max-height: 120px;
                margin: 0 auto;
                display: block;
            }

            .company-name-display {
                font-size: 1rem;
                padding: 8px;
            }

            .controls {
                padding: 12px;
            }

            .btn {
                padding: 10px;
                font-size: 0.85rem;
                min-height: 44px; /* Минимальный размер для touch на iOS */
                touch-action: manipulation; /* Улучшает отзывчивость на touch */
            }

            /* Кнопки управления на маленьких экранах - вертикальное выравнивание с одинаковыми отступами */
            .profile-btn,
            .companies-btn,
            .companies-bottom-btn,
            .logout-btn {
                width: 35px;
                height: 35px;
                right: 12px !important;
            }

            .profile-btn {
                top: 12px;
            }

            .companies-bottom-btn {
                top: 59px; /* 12px (top первой) + 35px (высота первой) + 12px (отступ) = 59px */
            }

            .logout-btn {
                top: 106px; /* 59px (top второй) + 35px (высота второй) + 12px (отступ) = 106px */
            }

            .gantt-label {
                min-width: 80px;
                max-width: 80px;
                font-size: 0.65rem;
                padding: 6px 4px;
                word-break: break-word;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .gantt-header-cell {
                min-width: 25px;
                font-size: 0.6rem;
                padding: 4px 2px;
            }

            .gantt-cell {
                min-width: 25px;
            }

            /* Улучшенный скролл для мобильных */
            .gantt-chart {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                scrollbar-color: #90caf9 #e3f2fd;
            }

            .tasks-table {
                font-size: 0.75rem;
            }

            .tasks-table th,
            .tasks-table td {
                padding: 6px 4px;
                font-size: 0.7rem;
                /* Убираем nowrap для ячеек, чтобы текст в input полях мог переноситься */
                white-space: normal;
            }

            .tasks-table-input {
                padding: 4px 6px;
                font-size: 0.7rem;
                width: 100%;
                min-width: 60px;
                /* Убираем обрезку текста - при расширении столбца текст будет виден полностью */
                overflow: visible !important;
                text-overflow: clip !important;
                white-space: normal !important;
                word-wrap: break-word;
            }

            /* Улучшенный скролл для таблицы на мобильных */
            .tasks-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                scrollbar-color: #90caf9 #e3f2fd;
            }

            .statistics {
                padding: 12px;
            }

            .stat-item {
                padding: 10px;
            }

            .stat-value {
                font-size: 1.5rem;
            }

            .stat-label {
                font-size: 0.75rem;
            }

            .stage-tabs {
                padding: 8px;
                flex-direction: column;
            }

            .stage-tabs-buttons {
                width: 100%;
                display: flex;
                flex-direction: column; /* Вертикальное расположение на мобильных */
                gap: 8px;
            }

            .stage-tab-btn {
                width: 100%; /* Все кнопки одинаковой ширины */
                min-height: 44px; /* Минимальный размер для touch на iOS */
                padding: 10px 12px;
                font-size: 0.875rem;
                touch-action: manipulation; /* Улучшает отзывчивость на touch */
            }

            /* Контейнер с дополнительными кнопками тоже вертикально на мобильных */
            .stage-controls-buttons {
                flex-direction: column !important;
                width: 100%;
                gap: 8px !important;
            }

            /* Одинаковый размер всех кнопок на мобильных - одинаковой ширины */
            .link-toggle-btn,
            .responsible-toggle-btn,
            .gantt-style-toggle-btn,
            .baseline-set-btn,
            .baseline-toggle-btn,
            .stage-settings-btn {
                width: 100% !important; /* Все кнопки одинаковой ширины */
                padding: 10px 12px;
                font-size: 0.75rem;
                min-height: 44px; /* Минимальный размер для touch на iOS */
                touch-action: manipulation;
                justify-content: center;
                display: flex !important;
                align-items: center;
            }

            /* Уменьшаем размер текста кнопки "Директивный план" на мобильных */
            .baseline-toggle-btn {
                font-size: 0.7rem;
                white-space: nowrap;
            }

            /* Кнопка "Редакция этапов" на мобильных - полная ширина с текстом */
            .stage-settings-btn {
                height: auto !important;
            }

            /* Убираем min-width для кнопки "Ответственный" на мобильных, чтобы она была такого же размера */
            .stage-tab-btn.responsible-toggle-btn {
                min-width: auto;
                flex: 0 0 auto;
            }

            /* Кнопка "отмена" на мобильных - под кнопками редактирования этапов */
            .stage-tabs-container {
                flex-direction: column;
                align-items: stretch;
            }

            .stage-tabs {
                order: 1;
                width: 100%;
            }

            .undo-btn {
                order: 2;
                width: 100%;
                margin-top: 8px;
            }

            .stage-tab {
                padding: 6px 10px;
                font-size: 0.75rem;
            }

            .modal-content {
                width: 98%;
                max-width: 98%;
                padding: 15px 12px;
                margin: 5% auto;
            }

            .modal-header h2 {
                font-size: 1.1rem;
            }

            .profile-modal-content {
                width: 98%;
                max-width: 98%;
                padding: 15px 12px;
            }

            .profile-modal-header h2 {
                font-size: 1.1rem;
            }

            .profile-form-group input {
                padding: 10px;
                font-size: 16px; /* Предотвращает зум на iOS */
            }
        }

        /* Landscape ориентация для мобильных */
        @media (max-width: 768px) and (orientation: landscape) {
            .container {
                padding: 8px;
            }

            header {
                padding: 15px 12px;
                margin-bottom: 10px;
            }

            header h1 {
                font-size: 1.1rem;
            }

            .controls {
                padding: 10px;
                gap: 8px;
            }

            .btn {
                padding: 8px 12px;
                font-size: 0.85rem;
            }

            .gantt-chart {
                max-height: 50vh;
            }

            .tasks-table-wrapper {
                max-height: 40vh;
            }
        }

        @media (max-width: 360px) {
            header h1 {
                font-size: 0.9rem;
            }

            .gantt-label {
                min-width: 70px;
                font-size: 0.6rem;
            }

            .gantt-header-cell {
                min-width: 20px;
                font-size: 0.55rem;
            }
        }

        /* Горизонтальная прокрутка для графика на планшетах и мобильных */
        @media (max-width: 1024px) {
            .chart-container {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                touch-action: pan-x pan-y;
            }

            .gantt-chart-wrapper {
                overflow-x: auto;
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                position: relative;
                touch-action: pan-x pan-y;
            }

            .gantt-chart {
                min-width: 800px; /* Минимальная ширина для корректного отображения */
                touch-action: pan-x pan-y;
            }
        }

        @media (max-width: 768px) {
            .tasks-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                touch-action: pan-x pan-y;
            }

            .tasks-table {
                min-width: 600px; /* Минимальная ширина для таблицы */
            }
        }

        @media print {
            .controls {
                display: none;
            }

            .chart-container {
                box-shadow: none;
                border: 1px solid var(--color-border);
            }
        }
        /* Футтер */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--color-surface);
            border-top: 2px solid var(--color-primary);
            padding: 15px 20px;
            text-align: center;
            color: var(--color-text-secondary);
            font-size: 0.85rem;
            z-index: 100;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
        }

        .footer p {
            margin: 0;
        }

        @media (max-width: 768px) {
            .footer {
                font-size: 0.75rem;
                padding: 12px 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <button class="logout-btn" id="logoutBtn" data-tooltip="Выход" style="display: none;" onclick="logout()">
                <span class="logout-icon"></span>
                <span class="logout-tooltip">Выход</span>
            </button>
            <button class="profile-btn" id="profileBtn" data-tooltip="Редактировать профиль" style="display: none;">
                <span class="profile-icon-head"></span>
                <span class="profile-icon-mouth"></span>
                <span class="profile-icon-shoulders"></span>
                <span class="profile-tooltip">Редактировать профиль</span>
            </button>
            <button class="companies-bottom-btn" id="companiesBottomBtn" data-tooltip="Компании" style="display: none;" onclick="goToCompanies()">
                <span class="companies-bottom-icon">
                    <span class="building-right"></span>
                </span>
                <span class="companies-bottom-tooltip">Компании</span>
            </button>
            <h1>
                <span class="header-icon"></span>
                <span>График внедрения и обучения системы ICONA</span>
            </h1>
            <p class="header-subtitle">Интерактивная визуализация плана цифровизации процессов</p>
            <div class="company-info">
                <div class="company-logo-display" id="companyLogoWrapper">
                    <img id="companyLogo" class="company-logo-preview" src="favicon.png" alt="Логотип компании">
                </div>
                <div class="company-name-block">
                    <span class="company-name-label">Название компании</span>
                    <div
                        id="companyNameDisplay"
                        class="company-name-display"
                        data-placeholder="Введите название компании"
                    >Введите название компании</div>
                    <div
                        id="companyObjectNameDisplay"
                        class="company-object-name-display"
                        style="display: none;"
                    ></div>
                </div>
            </div>
        </header>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">Всего этапов</div>
                <div class="stat-value" id="totalStages">4</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Всего задач</div>
                <div class="stat-value" id="totalTasks">51</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Рабочих дней</div>
                <div class="stat-value" id="totalDays">265</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Дата завершения</div>
                <div class="stat-value" id="completionDate">-</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-secondary reset-plan-btn" onclick="resetSchedule()" data-tooltip="Сбросить план">
                <span class="btn-icon btn-icon-reset"></span>
            </button>
            <button class="btn btn-primary" id="saveButton" onclick="manualSaveGantt()" data-tooltip="Принудительно сохранить все изменения">
                <span class="btn-icon">💾</span>
                <span id="saveButtonText">Сохранить</span>
            </button>
            <button class="btn btn-secondary view-toggle-btn" onclick="toggleView()">
                <span class="btn-icon btn-icon-toggle"></span>
                <span class="view-toggle-label">
                    <span class="view-toggle-part view-toggle-gantt">Гант</span>
                    <span class="view-toggle-separator">/</span>
                    <span class="view-toggle-part view-toggle-table">Таблица</span>
                </span>
            </button>
            <button class="btn btn-primary" onclick="openPDFExportModal()">
                <span class="btn-icon btn-icon-pdf"></span>
                <span>Выгрузить в PDF</span>
            </button>
            <button class="btn btn-primary" onclick="openExcelExportModal()">
                <span class="btn-icon btn-icon-excel"></span>
                <span>Выгрузить в Excel</span>
            </button>

            <div class="zoom-controls">
                <span class="zoom-label">Масштаб по времени:</span>
                <button class="btn btn-secondary" onclick="decreaseZoom()">−</button>
                <input type="range" id="zoomRange" class="zoom-range" min="40" max="200" value="120" step="5" onchange="onZoomChange(this.value)">
                <button class="btn btn-secondary" onclick="increaseZoom()">+</button>
                <span class="zoom-label" style="margin-left: 8px;">Для зумирования зажмите Z+колесо мыши</span>
            </div>
        </div>

        <div class="stage-tabs-container" style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px; flex-wrap: wrap;">
            <button 
                class="undo-btn" 
                id="undoBtn"
                onclick="undoLastAction()"
                data-tooltip="Отменить"
            >↶</button>
            <div class="stage-tabs">
                <div class="stage-tabs-buttons">
                    <button class="stage-tab-btn active">Все этапы</button>
                    <button class="stage-tab-btn">Этап 1</button>
                    <button class="stage-tab-btn">Этап 2</button>
                    <button class="stage-tab-btn">Этап 3</button>
                    <button class="stage-tab-btn">Этап 4</button>
                </div>
                <div class="stage-controls-buttons" style="display: flex; align-items: center; gap: 8px;">
                <button
                    class="link-toggle-btn"
                    id="linkToggleBtn"
                    onclick="toggleLinkColumn()"
                    data-tooltip="Показать/скрыть столбец 'Связь'"
                >
                    Связь
                </button>
                <button
                    class="baseline-toggle-btn"
                    id="baselineToggleBtn"
                    onclick="toggleBaselineDisplay()"
                    data-tooltip-line1="Задать базовый план (F2)"
                    data-tooltip-line2="Скрыть/показать базовый план (F3)"
                >
                    Директивный план
                </button>
                <button
                    class="stage-tab-btn responsible-toggle-btn"
                    id="responsibleToggleBtn"
                    onclick="toggleResponsibleColumn()"
                    data-tooltip="Показать/скрыть столбец 'Ответственный'"
                >
                    Ответственный
                </button>
                <button
                    class="gantt-style-toggle-btn"
                    id="ganttStyleToggleBtn"
                    onclick="toggleGanttBarStyle()"
                    data-tooltip="Отображение дней в диаграмме Ганта"
                >
                    <span>Детальный вид</span>
                </button>
                <button class="stage-settings-btn" onclick="openStageSettingsModal(event)" data-tooltip="Редакция этапов">
                    <span class="stage-settings-icon">
                        <span class="stage-settings-bar stage-settings-bar-1"></span>
                        <span class="stage-settings-bar stage-settings-bar-2"></span>
                        <span class="stage-settings-bar stage-settings-bar-3"></span>
                        <span class="stage-settings-knob stage-settings-knob-1"></span>
                        <span class="stage-settings-knob stage-settings-knob-2"></span>
                        <span class="stage-settings-knob stage-settings-knob-3"></span>
                    </span>
                </button>
                </div>
            </div>
        </div>

        <div class="chart-container view-active">
            <div id="ganttChart" class="gantt-chart"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, #1e88e5 0%, #0b5ed7 100%);"></div>
                    <span>Запланированные работы</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);"></div>
                    <span>В процессе выполнения</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);"></div>
                    <span>Завершено</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffe0e0;"></div>
                    <span>Выходные дни</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fff9c4;"></div>
                    <span>Праздничные дни</span>
                </div>
            </div>
        </div>

        <div class="table-section view-hidden">
            <h2><span class="btn-icon btn-icon-table"></span> Детальная таблица задач</h2>
            <table id="tasksTable" class="tasks-table">
                <thead>
                    <tr>
                        <th>№ п/п</th>
                        <th>Выбор этапа</th>
                        <th>Этап</th>
                        <th>Вид контроля</th>
                        <th>Мероприятие</th>
                        <th>Дата начала</th>
                        <th>Дата окончания</th>
                        <th>Рабочих дней</th>
                        <th class="table-col-responsible">Ответственный</th>
                        <th>Статус</th>
                    </tr>
                </thead>
                <tbody id="tasksTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Меню изменения статуса ячейки/диапазона по дате -->
    <div id="statusMenu" class="status-menu">
        <div class="status-menu-item" data-status="pending">
            <div class="status-color-box" style="background: linear-gradient(135deg, #1e88e5 0%, #0b5ed7 100%);"></div>
            <span>Запланировано</span>
        </div>
        <div class="status-menu-item" data-status="in-progress">
            <div class="status-color-box" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);"></div>
            <span>В работе</span>
        </div>
        <div class="status-menu-item" data-status="completed">
            <div class="status-color-box" style="background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);"></div>
            <span>Завершено (с начала по выбранную дату)</span>
        </div>
        <div class="status-menu-item" data-status="weekend-manual">
            <div class="status-color-box" style="background: #ffe0e0;"></div>
            <span>Выходной</span>
        </div>
    </div>

    <div id="editModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Изменить дату начала проекта</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="form-group">
                <label for="startDateInput">Выберите дату начала (рабочий день):</label>
                <input type="date" id="startDateInput" value="">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-primary" onclick="updateStartDate()">Применить</button>
                <button class="btn btn-secondary" onclick="closeModal()">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Модал для комментария к статусу "В работе"/"Завершено" -->
    <div id="statusCommentModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Комментарий к статусу</h2>
                <span class="close" onclick="cancelStatusComment()">&times;</span>
            </div>
            <div class="form-group">
                <label for="statusCommentInput">Опишите, что было сделано (необязательно):</label>
                <textarea id="statusCommentInput" class="status-comment-input" rows="3"></textarea>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-primary" onclick="confirmStatusComment()">Сохранить</button>
                <button class="btn btn-secondary" onclick="cancelStatusComment()">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для ввода текста в детальной таблице -->
    <div id="textInputModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="textInputModalTitle">Редактирование</h2>
                <span class="close" onclick="closeTextInputModal()">&times;</span>
            </div>
            <div class="form-group">
                <label id="textInputModalLabel" for="textInputModalTextarea">Введите текст:</label>
                <textarea id="textInputModalTextarea" class="text-input-modal-textarea" rows="5" placeholder="Введите текст..."></textarea>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-primary" onclick="saveTextInputModal()">Сохранить</button>
                <button class="btn btn-secondary" onclick="closeTextInputModal()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="pdfExportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Выгрузка в PDF</h2>
                <span class="close" onclick="closePDFExportModal()">&times;</span>
            </div>
            <p style="margin-bottom: 12px;">
                Будет сформирован PDF-файл с диаграммой Ганта в выбранном масштабе и детальной таблицей задач с комментариями.
            </p>
            <div class="form-group" style="margin-bottom: 16px;">
                <label for="pdfScaleMode">Масштаб представления Ганта:</label>
                <select id="pdfScaleMode">
                    <option value="day">Дни</option>
                    <option value="week">Недели</option>
                    <option value="month">Месяцы</option>
                </select>
            </div>
            <div class="form-group pdf-content-toggle" style="margin-bottom: 16px;">
                <label>Содержимое PDF:</label>
                <div class="pdf-toggle-options">
                    <label class="pdf-toggle-option">
                        <input type="radio" name="pdfContentMode" value="full" checked>
                        <span>С диаграммой</span>
                    </label>
                    <label class="pdf-toggle-option">
                        <input type="radio" name="pdfContentMode" value="table">
                        <span>Только таблица</span>
                    </label>
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="btn btn-primary" onclick="confirmPDFExport()">Выгрузить</button>
                <button class="btn btn-secondary" onclick="closePDFExportModal()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="excelExportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Выгрузка в Excel</h2>
                <span class="close" onclick="closeExcelExportModal()">&times;</span>
            </div>
            <p style="margin-bottom: 12px;">
                Будет сформирован файл Excel с двумя листами:
                на первом — диаграмма Ганта в выбранном масштабе, на втором — таблица задач.
            </p>
            <div class="form-group" style="margin-bottom: 16px;">
                <label for="excelScaleMode">Масштаб Ганта:</label>
                <select id="excelScaleMode">
                    <option value="day">Дни</option>
                    <option value="week">Недели</option>
                    <option value="month">Месяцы</option>
                    <option value="year">Годы</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="btn btn-primary" onclick="confirmExcelExport()">Выгрузить</button>
                <button class="btn btn-secondary" onclick="closeExcelExportModal()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="deleteConfirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Удалить задачу?</h2>
                <span class="close" onclick="cancelDeleteTask()">&times;</span>
            </div>
            <p>Вы действительно хотите удалить выбранную задачу из графика?</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmDeleteTask()">Да, удалить</button>
                <button class="btn btn-secondary" onclick="cancelDeleteTask()">Нет</button>
            </div>
        </div>
    </div>

    <div id="stageDeleteModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Удалить этап?</h2>
                <span class="close" onclick="cancelDeleteStage()">&times;</span>
            </div>
            <p id="stageDeleteText">Вы действительно хотите удалить выбранный этап со всеми его задачами?</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmDeleteStage()">Да, удалить</button>
                <button class="btn btn-secondary" onclick="cancelDeleteStage()">Нет</button>
            </div>
        </div>
    </div>

    <div id="resetPlanConfirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Сбросить план?</h2>
                <span class="close" onclick="cancelResetPlan()">&times;</span>
            </div>
            <p>Вы собираетесь сбросить многое, что вы сделали, вы уверены?</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmResetPlan()">Да</button>
                <button class="btn btn-secondary" onclick="cancelResetPlan()">Нет</button>
            </div>
        </div>
    </div>


    <div id="scaleWarningModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Внимание!</h2>
                <span class="close" onclick="cancelScaleWarning()">&times;</span>
            </div>
            <p id="scaleWarningText">Вы собираетесь проставить статус всей неделе. Вы уверены, что хотите это сделать?</p>
            <p style="color: #ff9800; font-weight: 500; margin-top: 10px;">Статус будет применён ко всем дням выбранного периода.</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmScaleWarning()">Да, применить</button>
                <button class="btn btn-secondary" onclick="cancelScaleWarning()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="undoConfirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Отменить действие?</h2>
                <span class="close" onclick="cancelUndo()">&times;</span>
            </div>
            <p>Последнее действие отменит ваши изменения.</p>
            <p style="color: #ff9800; font-weight: 500; margin-top: 10px;">Вы уверены, что хотите откатить?</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmUndo()">Да, отменить</button>
                <button class="btn btn-secondary" onclick="cancelUndo()">Нет</button>
            </div>
        </div>
    </div>

    <div id="stageSettingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Настройка этапов</h2>
                <span class="close" onclick="closeStageSettingsModal()">&times;</span>
            </div>
            <p style="margin-bottom: 12px;">
                Перетащите этапы, чтобы изменить порядок. Дважды кликните по названию, чтобы переименовать.
            </p>
            <div id="stageSettingsList" class="stage-settings-list"></div>
            <div class="stage-settings-footer">
                <button class="btn btn-secondary" onclick="addNewStage()">Добавить этап</button>
                <button class="btn btn-secondary" onclick="closeStageSettingsModal()">Готово</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для переименования этапа -->
    <div id="renameStageModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Переименовать этап</h2>
                <span class="close" onclick="closeRenameStageModal()">&times;</span>
            </div>
            <div class="form-group">
                <label for="renameStageInput">Новое название этапа:</label>
                <input type="text" id="renameStageInput" placeholder="Введите название этапа">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmRenameStage()">Сохранить</button>
                <button class="btn btn-secondary" onclick="closeRenameStageModal()">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно подтверждения перезаписи базового плана -->
    <div id="baselineConfirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Перезаписать базовый план?</h2>
                <span class="close" onclick="cancelBaselineOverwrite()">&times;</span>
            </div>
            <p>Директивный график уже сохранён. Перезаписать его текущим состоянием задач?</p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="confirmBaselineOverwrite()">Да, перезаписать</button>
                <button class="btn btn-secondary" onclick="cancelBaselineOverwrite()">Нет</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для ошибок валидации дат -->
    <div id="dateValidationModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Некорректный интервал дат</h2>
                <span class="close" onclick="closeDateValidationModal()">&times;</span>
            </div>
            <p id="dateValidationMessage">
                Дата окончания не может быть раньше даты начала.
            </p>
            <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: center;">
                <button class="btn btn-primary" onclick="closeDateValidationModal()">Понятно</button>
            </div>
        </div>
    </div>

    <!-- Небольшой toast для сообщений по базовому плану -->
    <div id="baselineToast" class="baseline-toast">    </div>

    <!-- Модальное окно редактирования профиля -->
    <div id="profileModal" class="profile-modal">
        <div class="profile-modal-content">
            <div class="profile-modal-header">
                <h2>Редактирование профиля</h2>
                <button class="profile-modal-close" onclick="closeProfileModal()">&times;</button>
            </div>
            <form id="profileForm">
                <div class="profile-form-group">
                    <label for="profileLogin">Логин:</label>
                    <input type="text" id="profileLogin" required>
                </div>
                <div class="profile-form-group">
                    <label for="profilePassword">Новый пароль (минимум 6 символов):</label>
                    <input type="password" id="profilePassword" minlength="6" placeholder="Оставьте пустым, чтобы не менять">
                </div>
                <div class="profile-form-group">
                    <label for="profilePasswordConfirm">Подтвердите пароль:</label>
                    <input type="password" id="profilePasswordConfirm" minlength="6" placeholder="Оставьте пустым, чтобы не менять">
                </div>
                <div id="profileMessage" class="profile-message"></div>
                <div class="profile-form-actions">
                    <button type="submit" class="btn btn-primary">Сохранить</button>
                    <button type="button" class="btn btn-secondary" onclick="closeProfileModal()">Отмена</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Данные о задачах из Excel файла
        // ========== ПОЛУЧЕНИЕ COMPANY ИЗ URL ==========
        function getCompanyFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('company') || localStorage.getItem('gantt-company') || null;
        }

        let currentCompany = getCompanyFromURL();
        if (currentCompany) {
            localStorage.setItem('gantt-company', currentCompany);
            console.log('🏢 Текущая компания:', currentCompany);
        } else {
            console.warn('⚠️ Компания не определена из URL или localStorage');
        }

        // Функция форматирования текста комментария для подсказки (максимум 80 символов в строке)
        function formatCommentForTooltip(text) {
            if (!text) return '';
            const maxLength = 80;
            const words = text.split(/\s+/);
            const lines = [];
            let currentLine = '';

            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine ? currentLine + ' ' + word : word;

                if (testLine.length <= maxLength) {
                    // Слово помещается в текущую строку
                    currentLine = testLine;
                } else {
                    // Слово не помещается
                    if (currentLine) {
                        // Сохраняем текущую строку и начинаем новую
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        // Слово длиннее maxLength символов - разбиваем его
                        if (word.length > maxLength) {
                            // Если текущая строка не пуста, сохраняем её
                            if (currentLine) {
                                lines.push(currentLine);
                                currentLine = '';
                            }
                            // Разбиваем длинное слово
                            let remainingWord = word;
                            while (remainingWord.length > maxLength) {
                                lines.push(remainingWord.substring(0, maxLength));
                                remainingWord = remainingWord.substring(maxLength);
                            }
                            currentLine = remainingWord;
                        } else {
                            currentLine = word;
                        }
                    }
                }
            }

            // Добавляем последнюю строку
            if (currentLine) {
                lines.push(currentLine);
            }

            return lines.join('\n');
        }

        // Показать кнопки авторизации (определяем раньше, чтобы использовать ниже)
        function showAuthButtons() {
            const ganttMode = localStorage.getItem('gantt-mode') || 'edit';
            const isViewMode = ganttMode === 'view';
            
            // В режиме просмотра не показываем кнопки авторизации
            if (isViewMode) {
                return;
            }
            
            const profileBtn = document.getElementById('profileBtn');
            const companiesBottomBtn = document.getElementById('companiesBottomBtn');
            const logoutBtn = document.getElementById('logoutBtn');
            
            console.log('🔧 showAuthButtons called', { 
                profileBtn: !!profileBtn, 
                companiesBottomBtn: !!companiesBottomBtn,
                logoutBtn: !!logoutBtn 
            });
            
            if (profileBtn) {
                profileBtn.style.display = 'flex';
            }
            if (companiesBottomBtn) {
                companiesBottomBtn.style.display = 'flex';
                console.log('✅ Нижняя кнопка компаний показана через showAuthButtons');
            }
            if (logoutBtn) {
                logoutBtn.style.display = 'flex';
            }
        }

        // Показываем кнопки авторизации сразу, если пользователь авторизован
        (function checkAuthButtons() {
            const userStr = localStorage.getItem('gantt-user');
            const ganttMode = localStorage.getItem('gantt-mode') || 'edit';
            const isViewMode = ganttMode === 'view';
            
            // В режиме просмотра не показываем кнопки авторизации
            if (isViewMode) {
                return;
            }
            
            if (userStr) {
                // Функция для показа кнопок
                const tryShowButtons = () => {
                    const companiesBottomBtn = document.getElementById('companiesBottomBtn');
                    const profileBtn = document.getElementById('profileBtn');
                    const logoutBtn = document.getElementById('logoutBtn');
                    
                    if (companiesBottomBtn) {
                        companiesBottomBtn.style.display = 'flex';
                        companiesBottomBtn.style.visibility = 'visible';
                        companiesBottomBtn.style.opacity = '1';
                    }
                    if (profileBtn) {
                        profileBtn.style.display = 'flex';
                        profileBtn.style.visibility = 'visible';
                    }
                    if (logoutBtn) {
                        logoutBtn.style.display = 'flex';
                        logoutBtn.style.visibility = 'visible';
                    }
                };
                
                // Ждем загрузки DOM
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', function() {
                        tryShowButtons();
                        setTimeout(tryShowButtons, 100);
                        setTimeout(tryShowButtons, 500);
                    });
                } else {
                    tryShowButtons();
                    setTimeout(tryShowButtons, 100);
                    setTimeout(tryShowButtons, 500);
                }
            }
        })();
        
        // Принудительное сохранение при уходе со страницы
        window.addEventListener('beforeunload', function() {
            if (currentCompany && !isViewMode) {
                // Сбрасываем таймер и сохраняем сразу синхронно
                if (saveTimeout) {
                    clearTimeout(saveTimeout);
                    saveTimeout = null;
                }
                
                // Используем navigator.sendBeacon для надежного сохранения при закрытии страницы
                try {
                    // Разблокировано сохранение для всех типов графиков, включая Praktis ID
                    const snapshot = createFullGanttSnapshot();
                    const companyParam = `?company=${currentCompany}`;
                    // sendBeacon требует FormData или Blob, но наш API ожидает JSON
                    // Поэтому используем обычный fetch с keepalive
                    fetch(`/api/gantt-state${companyParam}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(snapshot),
                        keepalive: true // Позволяет запросу завершиться даже после закрытия страницы
                    }).catch(e => console.error('Ошибка сохранения при уходе:', e));
                    console.log('💾 Запрос на сохранение отправлен при уходе');
                } catch (e) {
                    console.error('Ошибка сохранения при уходе:', e);
                }
            }
        });

        // ========== РЕЖИМ ДОСТУПА ==========
        // Проверяем режим из localStorage (edit или view)
        const ganttMode = localStorage.getItem('gantt-mode') || 'edit';
        const isViewMode = ganttMode === 'view';
        
        // Функция проверки возможности редактирования
        function canEdit() {
            if (isViewMode) {
                return false;
            }
            return true;
        }
        
        // Показываем индикатор режима просмотра и скрываем кнопку сохранения
        if (isViewMode) {
            document.body.classList.add('view-mode');
            document.addEventListener('DOMContentLoaded', function() {
                const style = document.createElement('style');
                style.textContent = `
                    body::after {
                        content: 'Режим просмотра';
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: rgba(100, 180, 255, 0.9);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: 600;
                        z-index: 10000;
                        box-shadow: 0 4px 15px rgba(100, 180, 255, 0.3);
                        pointer-events: none;
                    }
                `;
                document.head.appendChild(style);
            });
        }

        let projectData = [
            {
                stage: "Подготовка новой ветки ПО",
                control: "",
                task: "Создание базы данных ПО ICONA (серверная часть)",
                days: 14,
                substage: ""
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание структуры объекта (Excel)",
                days: 3,
                substage: "Подзадача 1"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание схем объекта",
                days: 3,
                substage: "Подзадача 2"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание паспорта объекта, Регистрация пользователей по ролям",
                days: 2,
                substage: "Подзадача 3"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Загрузка структуры и схем в ПО ICONA",
                days: 2,
                substage: "Подзадача 4"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Выполнение заливки локаций на схемах",
                days: 3,
                substage: "Подзадача 5"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание Тактического плана строительства (Классификатор СМР)",
                days: 11,
                substage: "Подзадача 6"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Расчет коэффициентов СТК",
                days: 10,
                substage: "Подзадача 7"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Локализация СТК (привязка СТК к локациям структуры объекта)",
                days: 3,
                substage: "Подзадача 8"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Наполнение базы подрядчиков и привязка подрядчика к цифровой модели",
                days: 3,
                substage: "Подзадача 9"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Создание Директивного и Рабочего ГПР",
                days: 17,
                substage: "Подзадача 10"
            },
            {
                stage: "Этап 1. Формирование цифровой модели",
                control: "ICONA Контроль инженера по строительству",
                task: "Проставление факта в ПО ICONA и использование отчетов (web, desktop и android версии)",
                days: 15,
                substage: "Контроль"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Общая структура статистического контроля по этапам",
                days: 2,
                substage: "Подзадача 1"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Настройка ICONA Статистический контроль (регистрация пользователей, настройка штрафов)",
                days: 2,
                substage: "Подзадача 2"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Создание графиков контроля",
                days: 1,
                substage: "Подзадача 3"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Процедура проведения статистического контроля на площадке (android)",
                days: 2,
                substage: "Подзадача 4"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Настройка и генерация доклада (ICONA автодоклад)",
                days: 3,
                substage: "Подзадача 5"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Подготовка к планерке и проведение планерки",
                days: 2,
                substage: "Подзадача 6"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Проведение конкретного контроля после планерки",
                days: 1,
                substage: "Подзадача 7"
            },
            {
                stage: "Этап 2. Обучение Планерка",
                control: "ICONA Статистический контроль",
                task: "Использование и редакция отчетов",
                days: 6,
                substage: "Подзадача 8"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Общая структура контроля ИСК и настройка прав доступа",
                days: 2,
                substage: "Подзадача 1"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Настройка процедур оценки качества СТК",
                days: 20,
                substage: "Подзадача 2"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Обучение подрядчиков ICONA Вызов технадзора (web интерфейс)",
                days: 10,
                substage: "Подзадача 3"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Процедура контроля ИСК на площадке (android)",
                days: 10,
                substage: "Подзадача 4"
            },
            {
                stage: "Этап 3. Строительный контроль",
                control: "ICONA Контроль инженера по строительному контролю",
                task: "Использование и редакция отчетов",
                days: 9,
                substage: "Подзадача 5"
            },
            {
                stage: "Этап 4. Приемка квартир",
                control: "ICONA Приемка квартир",
                task: "Общая структура приемки квартир и настройка прав доступа",
                days: 5,
                substage: "Подзадача 1"
            },
            {
                stage: "Этап 4. Приемка квартир",
                control: "ICONA Приемка квартир",
                task: "Обучение процедуре выполнения приемки квартир",
                days: 4,
                substage: "Подзадача 2"
            },
            {
                stage: "Этап 4. Приемка квартир",
                control: "ICONA Приемка квартир",
                task: "Использование и редакция отчетов",
                days: 3,
                substage: "Подзадача 3"
            }
        ];

        // Скелет графика для типа "Praktis ID"
        let projectDataPraktis = [
            // Здесь будет структура задач для Praktis ID
            // Пока оставляем пустым, будет загружаться с сервера или заполняться вручную
        ];

        // Российские выходные и праздники
        const holidays = [
            "2025-01-01", "2025-01-02", "2025-01-03", "2025-01-04", "2025-01-05",
            "2025-01-06", "2025-01-07", "2025-01-08", "2025-02-23", "2025-03-08",
            "2025-05-01", "2025-05-09", "2025-06-12", "2025-11-04"
        ];

        const INITIAL_START_DATE = new Date(2025, 0, 9); // 9 января 2025 (дефолт для сброса)
        let startDate = new Date(INITIAL_START_DATE); // текущее начало проекта
        let tasks = [];
        // Счётчик для генерации уникальных id новых задач (поверх исходного массива)
        let nextTaskId = projectData.length;
        let currentView = 'gantt';
        // Стиль отображения баров в Ганте: 'dots' (как сейчас, точки/короткие отрезки)
        // или 'segments' (слитные полосы без покраски по отдельным дням)
        let ganttBarStyle = 'dots';
        // Флаг отображения колонки "Ответственный"
        let showLink = false;
        let showResponsible = false;
        // Ожидающий применения статус, для которого нужен комментарий
        let pendingStatusForComment = null;
        // Текущий масштаб отображения Ганта (day/week/month)
        let currentScaleMode = 'day';
        // Ожидающий применения статус после подтверждения предупреждения о масштабе
        let pendingStatusAfterScaleWarning = null;
        // Ожидающий применения статус из таблицы (индекс задачи и новый статус)
        let pendingStatusFromTable = null;
        let zoomLevel = 1; // 1 = 100%, влияет только на ширину колонок
        let viewStartDate = null; // если задано, используем как левую границу отображения
        let viewEndDate = null;   // если задано, используем как правую границу отображения
        let isExporting = false;  // специальный режим отрисовки для PDF
        let saveTimeout = null; // таймер для отложенного сохранения
        
        // Система истории действий для отмены (undo)
        const MAX_UNDO_HISTORY = 10;
        let undoHistory = [];
        let isUndoing = false; // Флаг, чтобы не сохранять в историю при отмене
        let lastActionWasReset = false; // Флаг, указывающий, что последнее действие было сбросом плана




        // Текущая ячейка, для которой открыто меню статуса
        let currentStatusTarget = null; // { taskId, dateStrs }
        // Флаг, указывающий, что меню было открыто из select (чтобы не закрывать его сразу)
        let statusMenuOpenedFromSelect = false;
        // Координаты последнего клика для позиционирования модальных окон на мобильных
        let lastClickCoordinates = { x: 0, y: 0 };
        
        // Мультивыбор ячеек (Ctrl/Cmd + клик)
        let selectedCells = new Set(); // Set<string> где строка = "taskId:dateStr"
        let isCtrlPressed = false; // Флаг нажатия Ctrl/Cmd

        // Выделение задач (можно выделять несколько строк)
        let selectedTaskIds = new Set(); // множество id выделенных задач
        let lastSelectedTaskId = null;   // последняя "базовая" задача для Shift-выделения
        // Флаг и ссылка на модал удаления
        let isDeleteConfirmOpen = false;
        // Текущий фильтр по этапу: 'all' | 'Этап 1' | 'Этап 2' | ...
        let currentStageFilter = 'all';
        // Отслеживание свернутых этапов (Set с названиями этапов)
        let collapsedStages = new Set();

        // Для модального удаления этапа
        let pendingStageToDelete = null;
        let pendingStageToRename = null;

        // Конфигурация этапов для вкладок и модального окна
        let stageConfig = [];
        let draggedStageIndex = null;

        function initializeStageConfig() {
            const stagesSet = new Set();
            
            // Собираем этапы из реальных задач (tasks)
            tasks.forEach(task => {
                if (!task.stage) return;
                // Извлекаем короткое название этапа (префикс "Этап N" или полное название для пользовательских этапов)
                const match = task.stage.match(/^(Этап\s+\d+)/);
                if (match) {
                    stagesSet.add(match[1]); // Добавляем "Этап 1", "Этап 2" и т.д.
                } else {
                    // Если этап не соответствует формату "Этап N", добавляем его как есть (пользовательский этап)
                    stagesSet.add(task.stage);
                }
            });
            
            // Также добавляем этапы из projectData (скелета) для обратной совместимости
            projectData.forEach(item => {
                if (!item.stage) return;
                const match = item.stage.match(/^(Этап\s+\d+)/);
                if (match) {
                    stagesSet.add(match[1]);
                } else {
                    stagesSet.add(item.stage);
                }
            });
            
            // Преобразуем в массив и сортируем: сначала "Этап N" по номеру, затем остальные
            const stagesArray = Array.from(stagesSet);
            stageConfig = stagesArray.sort((a, b) => {
                const matchA = a.match(/^Этап\s+(\d+)/);
                const matchB = b.match(/^Этап\s+(\d+)/);
                if (matchA && matchB) {
                    return parseInt(matchA[1], 10) - parseInt(matchB[1], 10);
                }
                if (matchA) return -1;
                if (matchB) return 1;
                return a.localeCompare(b);
            });
        }

        initializeStageConfig();

        // Функция для получения списка уникальных этапов из задач
        function getAvailableStages() {
            const stagesSet = new Set();
            
            // Собираем этапы из реальных задач
            tasks.forEach(task => {
                if (!task.stage) return;
                const match = task.stage.match(/^(Этап\s+\d+)/);
                if (match) {
                    // Для стандартных этапов добавляем короткое название "Этап N"
                    stagesSet.add(match[1]);
                } else {
                    // Если этап не соответствует формату "Этап N", добавляем его как есть (полное название пользовательского этапа)
                    stagesSet.add(task.stage);
                }
            });
            
            // Добавляем этапы из stageConfig (включая пользовательские этапы)
            stageConfig.forEach(stage => {
                stagesSet.add(stage);
            });
            
            // Сортируем этапы: сначала "Этап N" по номеру, затем остальные
            const stagesArray = Array.from(stagesSet);
            return stagesArray.sort((a, b) => {
                const matchA = a.match(/^Этап\s+(\d+)/);
                const matchB = b.match(/^Этап\s+(\d+)/);
                if (matchA && matchB) {
                    return parseInt(matchA[1], 10) - parseInt(matchB[1], 10);
                }
                if (matchA) return -1;
                if (matchB) return 1;
                return a.localeCompare(b);
            });
        }

        // Данные о компании (название и логотип)
        let companyName = '';
        let companyObjectName = '';
        let companyLogoData = null; // data URL (base64) или null

        // Текущие ширины колонок в левой части Ганта (в пикселях)
        let ganttColumnWidths = {
            label: 260,
            start: 120,
            end: 120,
            days: 90,
            responsible: 160
        };

        function formatDateForInput(date) {
            // Если date уже строка, возвращаем её как есть
            if (typeof date === 'string') {
                return date;
            }
            // Если date не является объектом Date, пытаемся преобразовать
            if (!(date instanceof Date)) {
                // Если это строка в формате YYYY-MM-DD, возвращаем её
                if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
                    return date;
                }
                // Пытаемся создать Date из строки
                const parsedDate = new Date(date);
                if (isNaN(parsedDate.getTime())) {
                    console.error('Невозможно преобразовать дату:', date);
                    return '';
                }
                date = parsedDate;
            }
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        }

        // Парсинг даты из строки формата YYYY-MM-DD
        function parseDateKey(dateStr) {
            if (!dateStr) return null;
            if (dateStr instanceof Date) return dateStr;
            // Формат: YYYY-MM-DD
            const parts = dateStr.split('-');
            if (parts.length === 3) {
                return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
            }
            // Пробуем стандартный парсинг
            const parsed = new Date(dateStr);
            return isNaN(parsed.getTime()) ? null : parsed;
        }

        function formatDateKey(date) {
            return formatDateForInput(date);
        }

        // --- Блок информации о компании ---

        function applyCompanyInfoToUI() {
            const logoEl = document.getElementById('companyLogo');
            const nameDisplay = document.getElementById('companyNameDisplay');

            if (logoEl) {
                if (companyLogoData) {
                    logoEl.src = companyLogoData;
                } else {
                    logoEl.src = 'favicon.png';
                }
            }

            if (nameDisplay) {
                if (companyName && companyName.trim().length > 0) {
                    // Используем innerText для правильного отображения текста в любой кодировке
                    nameDisplay.innerText = companyName;
                    nameDisplay.classList.add('has-value');
                } else {
                    const placeholder = nameDisplay.getAttribute('data-placeholder') || 'Введите название компании';
                    nameDisplay.innerText = placeholder;
                    nameDisplay.classList.remove('has-value');
                }
            }
            
            // Отображаем название объекта под названием компании
            const objectNameDisplay = document.getElementById('companyObjectNameDisplay');
            if (objectNameDisplay) {
                if (companyObjectName && companyObjectName.trim().length > 0) {
                    objectNameDisplay.innerText = companyObjectName;
                    objectNameDisplay.style.display = 'block';
                } else {
                    objectNameDisplay.style.display = 'none';
                }
            }
        }

        function saveCompanyInfoLocally() {
            try {
                const payload = {
                    name: companyName,
                    objectName: companyObjectName,
                    logoData: companyLogoData
                };
                localStorage.setItem('iconaCompanyInfo', JSON.stringify(payload));
            } catch (e) {
                console.warn('Не удалось сохранить информацию о компании в localStorage:', e);
            }
        }

        async function saveCompanyInfoToServer() {
            try {
                const payload = {
                    name: companyName,
                    logoData: companyLogoData
                };
                const companyParam = currentCompany ? `?company=${currentCompany}` : '';
                await fetch(`/api/company-info${companyParam}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ...payload, company: currentCompany })
                });
            } catch (e) {
                // На локальной машине/без сервера просто игнорируем ошибку
                console.warn('Не удалось сохранить информацию о компании на сервере:', e);
            }
        }

        function handleCompanyNameInput(event) {
            if (!canEdit()) {
                event.preventDefault();
                return; // Блокируем редактирование названия компании в режиме просмотра
            }
            const raw = (event.target.innerText || event.target.textContent) || '';
            const placeholder = event.target.getAttribute('data-placeholder') || 'Введите название компании';

            // Если пользователь стёр всё — считаем, что названия нет и показываем плейсхолдер
            companyName = raw.trim() === '' || raw === placeholder ? '' : raw.trim();

            // Во время ввода не трогаем текст в DOM и каретку, только меняем класс
            if (companyName) {
                event.target.classList.add('has-value');
            } else {
                event.target.classList.remove('has-value');
            }

            saveCompanyInfoLocally();
            saveCompanyInfoToServer();
        }

        function handleCompanyNameFocus(event) {
            const el = event.target;
            const placeholder = el.getAttribute('data-placeholder') || 'Введите название компании';
            if (!el.classList.contains('has-value') && el.textContent === placeholder) {
                el.textContent = '';
            }
        }

        function handleCompanyLogoChange(event) {
            if (!canEdit()) {
                event.target.value = ''; // Сбрасываем выбор файла
                return; // Блокируем загрузку логотипа в режиме просмотра
            }
            const file = event.target.files && event.target.files[0];
            if (!file) return;

            if (file.type !== 'image/png') {
                alert('Пожалуйста, загрузите логотип в формате PNG.');
                return;
            }

            const reader = new FileReader();
            reader.onload = () => {
                companyLogoData = reader.result;
                applyCompanyInfoToUI();
                saveCompanyInfoLocally();
                saveCompanyInfoToServer();
            };
            reader.readAsDataURL(file);
        }

        let companyChartType = 'icona'; // Тип графика компании
        let chartTypeContainerName = 'ICONA'; // Название контейнера для заголовка
        let skeletonColumns = null; // Метаданные столбцов из скелета
        let loadedSkeletonData = null; // Загруженный скелет с сервера для пользовательских типов

        // Загрузить название контейнера по типу графика
        async function loadChartTypeContainerName(chartType) {
            try {
                const response = await fetch('/api/chart-types');
                if (response.ok) {
                    const chartTypes = await response.json();
                    const chartTypeData = chartTypes.find(ct => ct.id === chartType);
                    if (chartTypeData && chartTypeData.containerName) {
                        chartTypeContainerName = chartTypeData.containerName;
                        return chartTypeData.containerName;
                    }
                }
            } catch (error) {
                console.warn('Не удалось загрузить типы графиков:', error);
            }
            
            // Фоллбек на стандартные значения
            if (chartType === 'praktis') {
                chartTypeContainerName = 'Praktis ID';
            } else {
                chartTypeContainerName = 'ICONA';
            }
            return chartTypeContainerName;
        }

        // Обновить заголовок на основе типа графика
        function updatePageTitle() {
            const titleText = `График внедрения и обучения системы ${chartTypeContainerName}`;
            
            // Обновляем заголовок в header (ищем span внутри h1, который не имеет класса header-icon)
            const headerTitle = document.querySelector('h1 span:not(.header-icon)');
            if (headerTitle) {
                headerTitle.textContent = titleText;
            } else {
                // Фоллбек: ищем последний span в h1
                const h1 = document.querySelector('h1');
                if (h1) {
                    const spans = h1.querySelectorAll('span');
                    if (spans.length > 0) {
                        spans[spans.length - 1].textContent = titleText;
                    }
                }
            }
            
            // Обновляем title страницы
            document.title = titleText;
            
            // Обновляем og:title
            const ogTitle = document.querySelector('meta[property="og:title"]');
            if (ogTitle) {
                ogTitle.setAttribute('content', titleText);
            }
        }

        async function loadCompanyInfo() {
            // 1. Пытаемся загрузить с сервера, если он есть
            try {
                const companyParam = currentCompany ? `?company=${currentCompany}` : '';
                const res = await fetch(`/api/company-info${companyParam}`);
                if (res.ok) {
                    const data = await res.json();
                    if (data && (data.name || data.logoData || data.chartType)) {
                        // Убеждаемся, что название компании правильно декодируется
                        companyName = data.name ? String(data.name) : '';
                        companyObjectName = data.objectName ? String(data.objectName) : '';
                        companyLogoData = data.logoData || null;
                        companyChartType = data.chartType || 'icona';
                        
                        // Загружаем название контейнера и обновляем заголовок
                        await loadChartTypeContainerName(companyChartType);
                        updatePageTitle();
                        
                        // Разблокирован функционал для Praktis ID - можно работать с графиком
                        applyCompanyInfoToUI();
                        return;
                    }
                }
            } catch (e) {
                // если сервер недоступен — идём в localStorage
            }

            // 2. Фоллбек на localStorage
            try {
                const raw = localStorage.getItem('iconaCompanyInfo');
                if (raw) {
                    const stored = JSON.parse(raw);
                    // Убеждаемся, что название компании правильно декодируется
                    companyName = stored.name ? String(stored.name) : '';
                    companyObjectName = stored.objectName ? String(stored.objectName) : '';
                    companyLogoData = stored.logoData || null;
                    companyChartType = stored.chartType || 'icona';
                    
                    // Загружаем название контейнера и обновляем заголовок
                    await loadChartTypeContainerName(companyChartType);
                    updatePageTitle();
                    
                    // Разблокирован функционал для Praktis ID - можно работать с графиком
                }
            } catch (e) {
                console.warn('Не удалось загрузить информацию о компании из localStorage:', e);
            }
            
            // Если тип графика не был загружен, загружаем название контейнера для дефолтного типа
            if (!companyChartType || companyChartType === 'icona') {
                await loadChartTypeContainerName(companyChartType || 'icona');
                updatePageTitle();
            }

            applyCompanyInfoToUI();
        }

        // Показать сообщение "в разработке" для Praktis ID
        function showDevelopmentMessage() {
            const container = document.querySelector('.container');
            if (container) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 100px 20px; background: rgba(255, 255, 255, 0.95); border-radius: 20px; box-shadow: 0 10px 40px rgba(33, 150, 243, 0.2); margin-top: 50px;">
                        <h1 style="color: #666; font-size: 2rem; margin-bottom: 20px; font-weight: 300;">В разработке</h1>
                        <p style="color: #999; font-size: 1.2rem; line-height: 1.6;">
                            График "Внедрение Praktis ID" находится в разработке.<br>
                            Скоро здесь появится функционал для работы с этим типом графика.
                        </p>
                    </div>
                `;
            }
        }

        // Перерисовать вкладки этапов на основе текущей конфигурации
        function renderStageTabs() {
            const container = document.querySelector('.stage-tabs-buttons');
            if (!container) return;

            container.innerHTML = '';

            const allBtn = document.createElement('button');
            allBtn.className = 'stage-tab-btn';
            allBtn.textContent = 'Все этапы';
            if (currentStageFilter === 'all') {
                allBtn.classList.add('active');
            }
            allBtn.addEventListener('click', () => {
                currentStageFilter = 'all';
                renderStageTabs();
                renderGantt();
                renderTable();
                applySelectionHighlight();
            });
            container.appendChild(allBtn);

            stageConfig.forEach(shortName => {
                const btn = document.createElement('button');
                btn.className = 'stage-tab-btn';
                btn.textContent = shortName;
                if (currentStageFilter === shortName) {
                    btn.classList.add('active');
                }
                btn.addEventListener('click', () => {
                    // Разворачиваем этап, если он был свернут
                    expandStageByShortName(shortName);
                    
                    // Устанавливаем фильтр по этапу
                    currentStageFilter = shortName;
                    renderStageTabs();
                    
                    // Перерисовываем график и таблицу
                    renderGantt();
                    renderTable();
                    
                    // Пересчитываем позиции меток этапов после разворачивания
                    setTimeout(() => {
                        recalculateStageLabelsPositions();
                    }, 350);
                    
                    applySelectionHighlight();
                });
                container.appendChild(btn);
            });
        }

        // Функция для разворачивания конкретного этапа по короткому названию
        function expandStageByShortName(shortName) {
            // Находим все полные названия этапов, которые соответствуют короткому названию
            const fullStageNames = new Set();
            tasks.forEach(task => {
                if (!task.stage) return;
                
                // Извлекаем короткое название этапа из полного (например, "Этап 2" из "Этап 2. Обучение Планерка")
                const match = task.stage.match(/^(Этап\s+\d+)/);
                if (match) {
                    const taskShortName = match[1];
                    // Сравниваем извлеченное короткое название с искомым
                    if (taskShortName === shortName) {
                        fullStageNames.add(task.stage);
                    }
                } else {
                    // Для пользовательских этапов (без формата "Этап N") сравниваем полностью
                    if (task.stage === shortName) {
                        fullStageNames.add(task.stage);
                    }
                }
            });
            
            // Удаляем найденные этапы из списка свернутых
            let wasExpanded = false;
            fullStageNames.forEach(fullStageName => {
                if (collapsedStages.has(fullStageName)) {
                    collapsedStages.delete(fullStageName);
                    wasExpanded = true;
                    console.log(`✅ Развернут этап: ${fullStageName}`);
                }
            });
            
            if (!wasExpanded && fullStageNames.size > 0) {
                console.log(`ℹ️ Этап "${shortName}" уже развернут (найдено этапов: ${fullStageNames.size})`);
            } else if (fullStageNames.size === 0) {
                console.log(`⚠️ Этапы с названием "${shortName}" не найдены`);
            }
            
            return wasExpanded;
        }

        // Проверка, относится ли задача к текущему выбранному этапу
        function isTaskInCurrentStage(task) {
            if (currentStageFilter === 'all') return true;
            if (!task.stage) return false;
            return task.stage.startsWith(currentStageFilter);
        }

        function isTaskSelected(taskId) {
            return selectedTaskIds.has(taskId);
        }

        // Применить визуальное выделение к текущему набору выбранных задач
        function applySelectionHighlight() {
            document.querySelectorAll('.gantt-row').forEach(row => {
                if (!row.dataset.taskId) return;
                const idStr = row.dataset.taskId;
                const isSelected = selectedTaskIds.has(Number(idStr));
                row.classList.toggle('selected', isSelected);
            });

            const tbody = document.getElementById('tasksTableBody');
            if (tbody) {
                tbody.querySelectorAll('tr').forEach(tr => {
                    if (!tr.dataset.taskId) return;
                    const idStr = tr.dataset.taskId;
                    const isSelected = selectedTaskIds.has(Number(idStr));
                    tr.classList.toggle('selected', isSelected);
                });
            }
        }

        function clearSelection() {
            selectedTaskIds.clear();
            lastSelectedTaskId = null;
            applySelectionHighlight();
        }

        function getPrimarySelectedTaskId() {
            if (lastSelectedTaskId !== null && selectedTaskIds.has(lastSelectedTaskId)) {
                return lastSelectedTaskId;
            }
            const first = selectedTaskIds.values().next();
            return first.done ? null : first.value;
        }

        // Выбор задач по клику (поддержка Shift для диапазона)
        function selectTask(taskId, options = {}) {
            const { range = false } = options;

            if (range && lastSelectedTaskId !== null) {
                // Диапазон между lastSelectedTaskId и текущей задачей
                const startIndex = tasks.findIndex(t => t.id === lastSelectedTaskId);
                const endIndex = tasks.findIndex(t => t.id === taskId);
                if (startIndex === -1 || endIndex === -1) {
                    // если что-то пошло не так — просто обычное выделение
                    selectedTaskIds.clear();
                    selectedTaskIds.add(taskId);
                    lastSelectedTaskId = taskId;
                    applySelectionHighlight();
                    return;
                }
                selectedTaskIds.clear();
                const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];
                for (let i = from; i <= to; i++) {
                    selectedTaskIds.add(tasks[i].id);
                }
            } else {
                // Одиночный клик — выделяем только одну строку
                selectedTaskIds.clear();
                selectedTaskIds.add(taskId);
                lastSelectedTaskId = taskId;
            }

            applySelectionHighlight();
        }

        // Обработка клика по строке (Гант или таблица)
        function handleTaskRowClick(taskId, event) {
            if (event.shiftKey) {
                selectTask(taskId, { range: true });
            } else {
                selectTask(taskId, { range: false });
            }
        }

        // Функция для проверки рабочего дня
        function isWorkday(date) {
            const dayOfWeek = date.getDay();
            const dateStr = formatDateKey(date);
            return dayOfWeek !== 0 && dayOfWeek !== 6 && !holidays.includes(dateStr);
        }

        // Функция для получения дней для задачи
        function getTaskDates(startDate, workDays) {
            const dates = [];
            let currentDate = new Date(startDate);
            let daysAdded = 0;

            while (daysAdded < workDays) {
                if (isWorkday(currentDate)) {
                    dates.push(new Date(currentDate));
                    daysAdded++;
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }

            return dates;
        }

        // Получить рабочие дни между датами (включительно)
        function getWorkdaysBetween(start, end) {
            const dates = [];
            const current = new Date(start);
            const last = new Date(end);
            while (current <= last) {
                if (isWorkday(current)) {
                    dates.push(new Date(current));
                }
                current.setDate(current.getDate() + 1);
            }
            return dates;
        }

        // Получить рабочие дни между датами, исключая дни, помеченные как выходные (weekend-manual)
        function getWorkdaysBetweenExcludingWeekends(start, end, weekendManualDates) {
            const dates = [];
            const current = new Date(start);
            const last = new Date(end);
            while (current <= last) {
                const dateKey = formatDateKey(current);
                // Проверяем, что это рабочий день И он не помечен как выходной
                if (isWorkday(current) && !weekendManualDates.has(dateKey)) {
                    dates.push(new Date(current));
                }
                current.setDate(current.getDate() + 1);
            }
            return dates;
        }

        // Получить рабочие дни, считая назад от конечной даты
        function getWorkdaysBackward(endDate, workDays) {
            const dates = [];
            const current = new Date(endDate);
            while (dates.length < workDays) {
                if (isWorkday(current)) {
                    dates.push(new Date(current));
                }
                current.setDate(current.getDate() - 1);
            }
            return dates.reverse();
        }

        // Пересчитать даты задачи с учетом выходных дней (weekend-manual)
        // Дни со статусом "weekend-manual" не считаются рабочими, поэтому
        // дата завершения сдвигается вперед на количество выходных дней
        function recalculateTaskDatesWithWeekends(task) {
            if (!task || !task.startDate || !task.days) return;

            // Инициализируем dateStatuses, если его нет
            if (!task.dateStatuses) {
                task.dateStatuses = {};
            }

            const dates = [];
            let currentDate = new Date(task.startDate);
            let daysAdded = 0;
            let iterations = 0;
            const maxIterations = task.days * 10; // Защита от бесконечного цикла

            // Собираем рабочие дни, пропуская дни со статусом "weekend-manual"
            while (daysAdded < task.days && iterations < maxIterations) {
                iterations++;
                const dateKey = formatDateKey(currentDate);
                const isWeekendManual = task.dateStatuses[dateKey] === 'weekend-manual';
                
                // Если это рабочий день И он не помечен как выходной - добавляем его
                if (isWorkday(currentDate) && !isWeekendManual) {
                    dates.push(new Date(currentDate));
                    daysAdded++;
                }
                // Если день помечен как выходной, пропускаем его (не считаем рабочим)
                // Продолжаем искать следующие рабочие дни
                
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Обновляем даты задачи
            if (dates.length > 0) {
                task.dates = dates;
                task.startDate = dates[0];
                task.endDate = dates[dates.length - 1];
            } else {
                console.warn('⚠️ recalculateTaskDatesWithWeekends: Не удалось найти рабочие дни для задачи');
            }
        }

        function parseDateFromInput(value) {
            if (!value) return null;
            const [year, month, day] = value.split('-').map(Number);
            if (!year || !month || !day) return null;
            return new Date(year, month - 1, day);
        }

        // Флаг отображения директивного (baseline) плана в Ганте
        let showBaseline = false;
        // Последний сохранённый baseline-план (как пришёл с сервера или после F2)
        let baselineSnapshot = null;
        // Снапшот, ожидающий подтверждения перезаписи
        let pendingBaselineSnapshot = null;
        // Таймер для toast-сообщений
        let baselineToastTimer = null;

        // Инициализация задач
        async function initializeTasks() {
            console.log('🔄 Инициализация задач по умолчанию...');
            
            // Выбираем правильный скелет в зависимости от типа графика
            let skeletonData = projectData; // По умолчанию используем Icona
            if (companyChartType === 'praktis') {
                skeletonData = projectDataPraktis;
                console.log('📊 Используется скелет для Praktis ID');
            } else if (companyChartType === 'icona') {
                skeletonData = projectData;
                console.log('📊 Используется скелет для Icona');
            } else {
                // Для пользовательских типов графиков используем загруженный скелет
                skeletonData = loadedSkeletonData || projectData;
                console.log(`📊 Используется скелет для типа "${companyChartType}"`);
            }
            
            console.log('   skeletonData.length:', skeletonData ? skeletonData.length : 'undefined');
            console.log('   startDate:', startDate);
            
            tasks = [];
            // Сбрасываем счётчик id (исходные задачи идут с 0..N-1)
            nextTaskId = skeletonData ? skeletonData.length : 0;
            let currentDate = new Date(startDate);

            if (!skeletonData || !Array.isArray(skeletonData) || skeletonData.length === 0) {
                console.warn('⚠️ Скелет пустой или не определен! Пытаемся загрузить с сервера...');
                // Пытаемся загрузить скелет с сервера синхронно
                const skeletonLoaded = await loadSkeletonFromServer();
                if (skeletonLoaded) {
                    // После загрузки повторяем инициализацию с правильным скелетом
                    if (companyChartType === 'praktis') {
                        skeletonData = projectDataPraktis;
                    } else if (companyChartType === 'icona') {
                        skeletonData = projectData;
                    } else {
                        // Для пользовательских типов графиков используем загруженный скелет
                        skeletonData = loadedSkeletonData || projectData;
                    }
                    // Продолжаем инициализацию, если скелет загружен
                    if (skeletonData && skeletonData.length > 0) {
                        console.log('✅ Скелет загружен, продолжаем инициализацию с', skeletonData.length, 'задачами');
                        // Продолжаем выполнение функции дальше, не возвращаемся
                    } else {
                        console.error('❌ КРИТИЧЕСКАЯ ОШИБКА: Скелет не загружен или пустой после попытки загрузки!');
                        return;
                    }
                } else {
                    console.error('❌ КРИТИЧЕСКАЯ ОШИБКА: Не удалось загрузить скелет с сервера!');
                    return;
                }
            }

            skeletonData.forEach((item, index) => {
                try {
                    const taskDates = getTaskDates(currentDate, item.days);
                    if (!taskDates || taskDates.length === 0) {
                        console.warn(`⚠️ Не удалось получить даты для задачи ${index}:`, item);
                        return;
                    }
                    const taskObj = {
                        id: index,
                        ...item,
                        startDate: taskDates[0],
                        endDate: taskDates[taskDates.length - 1],
                        dates: taskDates,
                        status: 'pending',
                        dateStatuses: {}, // ключ: YYYY-MM-DD, значение: 'pending' | 'in-progress' | 'completed' | 'weekend-manual'
                        link: item.link || 'О_Н' // Все задачи по умолчанию О_Н (первая тоже, но select заблокирован)
                    };
                    // Синхронизируем task и name для совместимости
                    if (taskObj.task && !taskObj.name) {
                        taskObj.name = taskObj.task;
                    } else if (taskObj.name && !taskObj.task) {
                        taskObj.task = taskObj.name;
                    }
                    tasks.push(taskObj);
                    currentDate = new Date(taskDates[taskDates.length - 1]);
                    currentDate.setDate(currentDate.getDate() + 1);
                } catch (e) {
                    console.error(`❌ Ошибка при создании задачи ${index}:`, e, item);
                }
            });

            console.log('✅ Инициализировано задач:', tasks.length);
            
            if (tasks.length === 0) {
                console.error('❌ КРИТИЧЕСКАЯ ОШИБКА: Не удалось создать ни одной задачи!');
                return;
            }

            updateStatistics();
	    // лок начало: автосохранение
	    autoSaveGanttState();
	    // энд конец
        }

        // Загрузить скелет графика с сервера
        async function loadSkeletonFromServer() {
            try {
                // Используем тип графика компании напрямую, если он задан
                const chartType = companyChartType || 'icona';
                console.log('📥 Загрузка скелета для типа графика:', chartType);
                console.log('📥 companyChartType:', companyChartType);
                const response = await fetch(`/api/gantt-skeleton?chartType=${encodeURIComponent(chartType)}`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data && data.skeleton && Array.isArray(data.skeleton) && data.skeleton.length > 0) {
                        // Сохраняем метаданные столбцов, если они есть
                        if (data.columns && Array.isArray(data.columns) && data.columns.length > 0) {
                            skeletonColumns = data.columns;
                            console.log('✅ Метаданные столбцов загружены:', skeletonColumns.length, 'столбцов');
                        } else {
                            // Используем дефолтные столбцы
                            skeletonColumns = [
                                { id: 'stage', name: 'Этап', field: 'stage', order: 0 },
                                { id: 'control', name: 'Вид контроля', field: 'control', order: 1 },
                                { id: 'task', name: 'Мероприятие', field: 'task', order: 2 }
                            ];
                        }
                        
                        // Сохраняем скелет в зависимости от типа графика
                        if (chartType === 'praktis') {
                            projectDataPraktis = data.skeleton;
                            loadedSkeletonData = null; // Сбрасываем, так как используем projectDataPraktis
                            console.log('✅ Скелет для Praktis ID загружен с сервера, задач:', projectDataPraktis.length);
                        } else if (chartType === 'icona') {
                            // Для Icona можно обновить projectData, если нужно
                            loadedSkeletonData = null; // Сбрасываем, так как используем projectData
                            console.log('✅ Скелет для Icona загружен с сервера, задач:', data.skeleton.length);
                        } else {
                            // Для пользовательских типов графиков сохраняем скелет в отдельную переменную
                            loadedSkeletonData = data.skeleton;
                            console.log(`✅ Скелет для типа "${chartType}" загружен с сервера, задач:`, data.skeleton.length);
                        }
                        // Обновляем заголовок таблицы после загрузки метаданных столбцов
                        updateTableHeader();
                        return true;
                    } else {
                        console.warn('⚠️ Скелет пустой или не найден на сервере для типа:', chartType);
                    }
                } else {
                    console.warn('⚠️ Ошибка загрузки скелета:', response.status, response.statusText);
                }
            } catch (e) {
                console.warn('⚠️ Не удалось загрузить скелет с сервера:', e);
            }
            return false;
        }

        // Сохранить скелет графика на сервер
        async function saveSkeletonToServer(chartType, skeleton) {
            try {
                const response = await fetch('/api/gantt-skeleton', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chartType, skeleton })
                });
                
                if (response.ok) {
                    console.log(`✅ Скелет для ${chartType} сохранён на сервер`);
                    return true;
                } else {
                    console.error('❌ Ошибка сохранения скелета:', response.statusText);
                    return false;
                }
            } catch (e) {
                console.error('❌ Ошибка сохранения скелета:', e);
                return false;
            }
            renderGantt();
            renderTable();
            applyCompanyInfoToUI();
            renderStageTabs();
        }

        // Применить сохранённый baseline-план к текущему массиву tasks
        function applyBaselineToTasks() {
            if (!baselineSnapshot || !Array.isArray(baselineSnapshot.tasks)) return;

            const byId = new Map();
            baselineSnapshot.tasks.forEach(b => {
                byId.set(b.id, b);
            });

            tasks.forEach(task => {
                const b = byId.get(task.id);
                if (!b || !Array.isArray(b.baselineDates) || !b.baselineDates.length) {
                    task.baselineDates = undefined;
                    task.baselineStartDate = undefined;
                    task.baselineEndDate = undefined;
                    return;
                }

                const parsedDates = b.baselineDates
                    .map(ds => parseDateFromInput(ds))
                    .filter(d => d instanceof Date && !isNaN(d.getTime()))
                    .sort((a, b) => a - b);

                if (!parsedDates.length) {
                    task.baselineDates = undefined;
                    task.baselineStartDate = undefined;
                    task.baselineEndDate = undefined;
                    return;
                }

                task.baselineDates = parsedDates;
                task.baselineStartDate = parsedDates[0];
                task.baselineEndDate = parsedDates[parsedDates.length - 1];
            });
        }

        // Построить snapshot директивного плана по текущему состоянию задач
        function buildBaselineSnapshot() {
            return {
                generatedAt: new Date().toISOString(),
                tasks: tasks.map(task => ({
                    id: task.id,
                    baselineDates: Array.isArray(task.dates)
                        ? task.dates.map(d => formatDateKey(d))
                        : []
                }))
            };
        }

        // Переменная для хранения последнего сохраненного состояния (для сравнения)
        let lastSavedState = null;
        
        // Создать детальное описание изменений
        function createChangeDescription() {
            if (!lastSavedState) {
                return {
                    action: 'Изменил график',
                    details: 'Первое сохранение графика'
                };
            }
            
            const changes = [];
            
            // Сравниваем задачи
            const oldTasks = lastSavedState.tasks || [];
            const newTasks = tasks;
            
            // Проверяем добавленные задачи
            if (newTasks.length > oldTasks.length) {
                const addedCount = newTasks.length - oldTasks.length;
                changes.push(`Добавлено задач: ${addedCount}`);
            }
            
            // Проверяем удаленные задачи
            if (newTasks.length < oldTasks.length) {
                const removedCount = oldTasks.length - newTasks.length;
                changes.push(`Удалено задач: ${removedCount}`);
            }
            
            // Проверяем изменения в существующих задачах
            const maxLength = Math.min(oldTasks.length, newTasks.length);
            for (let i = 0; i < maxLength; i++) {
                const oldTask = oldTasks[i];
                const newTask = newTasks[i];
                const taskChanges = [];
                
                if (oldTask.name !== newTask.name && oldTask.task !== newTask.task) {
                    const oldName = oldTask.name || oldTask.task || '';
                    const newName = newTask.name || newTask.task || '';
                    if (oldName !== newName) {
                        taskChanges.push(`Название: "${oldName.substring(0, 30)}..." → "${newName.substring(0, 30)}..."`);
                    }
                }
                
                if (oldTask.startDate !== newTask.startDate) {
                    taskChanges.push(`Дата начала: ${oldTask.startDate || '—'} → ${newTask.startDate || '—'}`);
                }
                
                if (oldTask.endDate !== newTask.endDate) {
                    taskChanges.push(`Дата окончания: ${oldTask.endDate || '—'} → ${newTask.endDate || '—'}`);
                }
                
                if (oldTask.days !== newTask.days) {
                    taskChanges.push(`Рабочих дней: ${oldTask.days || 0} → ${newTask.days || 0}`);
                }
                
                if (oldTask.status !== newTask.status) {
                    const statusNames = {
                        'pending': 'Запланирована',
                        'in-progress': 'В работе',
                        'completed': 'Завершено'
                    };
                    taskChanges.push(`Статус: ${statusNames[oldTask.status] || oldTask.status} → ${statusNames[newTask.status] || newTask.status}`);
                }
                
                if (oldTask.link !== newTask.link) {
                    taskChanges.push(`Связь: ${oldTask.link || '—'} → ${newTask.link || '—'}`);
                }
                
                if (oldTask.responsible !== newTask.responsible) {
                    taskChanges.push(`Ответственный: ${oldTask.responsible || '—'} → ${newTask.responsible || '—'}`);
                }
                
                if (taskChanges.length > 0) {
                    const taskName = (newTask.name || newTask.task || `Задача ${i + 1}`).substring(0, 40);
                    changes.push(`${taskName}: ${taskChanges.join(', ')}`);
                }
            }
            
            // Проверяем изменение даты начала проекта
            if (lastSavedState.startDate !== (startDate ? formatDateKey(startDate) : null)) {
                changes.push(`Дата начала проекта: ${lastSavedState.startDate || '—'} → ${startDate ? formatDateKey(startDate) : '—'}`);
            }
            
            if (changes.length === 0) {
                return {
                    action: 'Изменил график',
                    details: 'Изменения в графике (детали не определены)'
                };
            }
            
            // Группируем изменения по типам для лучшей читаемости
            const groupedChanges = {
                tasks: [], // Изменения задач
                project: [], // Изменения проекта (дата начала)
                added: [], // Добавленные задачи
                removed: [] // Удаленные задачи
            };
            
            changes.forEach(change => {
                if (change.includes('Добавлено задач:')) {
                    groupedChanges.added.push(change);
                } else if (change.includes('Удалено задач:')) {
                    groupedChanges.removed.push(change);
                } else if (change.includes('Дата начала проекта:')) {
                    groupedChanges.project.push(change);
                } else {
                    groupedChanges.tasks.push(change);
                }
            });
            
            // Формируем детальное описание
            const detailsParts = [];
            
            // Сначала изменения проекта
            if (groupedChanges.project.length > 0) {
                detailsParts.push(...groupedChanges.project);
            }
            
            // Затем добавленные/удаленные задачи
            if (groupedChanges.added.length > 0) {
                detailsParts.push(...groupedChanges.added);
            }
            if (groupedChanges.removed.length > 0) {
                detailsParts.push(...groupedChanges.removed);
            }
            
            // Затем изменения в задачах (показываем все, но ограничиваем длину каждого описания)
            if (groupedChanges.tasks.length > 0) {
                // Показываем все изменения задач, но ограничиваем общее количество символов
                const maxDetailsLength = 500; // Максимальная длина деталей
                let currentLength = detailsParts.join('; ').length;
                
                for (let i = 0; i < groupedChanges.tasks.length; i++) {
                    const taskChange = groupedChanges.tasks[i];
                    const testLength = currentLength + (detailsParts.length > 0 ? '; ' : '') + taskChange.length;
                    
                    if (testLength <= maxDetailsLength) {
                        detailsParts.push(taskChange);
                        currentLength = testLength;
                    } else {
                        // Если не влезает, показываем сколько еще осталось
                        const remaining = groupedChanges.tasks.length - i;
                        if (remaining > 0) {
                            detailsParts.push(`... и еще ${remaining} изменений в задачах`);
                        }
                        break;
                    }
                }
            }
            
            const details = detailsParts.join('; ');
            
            return {
                action: 'Изменил график',
                details: details
            };
        }
        
        // Построить полный snapshot состояния графика со всеми данными
        function createFullGanttSnapshot() {
            return {
                version: '1.0',
                savedAt: new Date().toISOString(),
                startDate: startDate ? formatDateKey(startDate) : null,
                tasks: tasks.map(task => {
                    // Синхронизируем task и name перед сохранением
                    const taskName = task.task || task.name || '';
                    return {
                        id: task.id,
                        stage: task.stage || '',
                        substage: task.substage || '',
                        control: task.control || task.controlType || '', // Используем control, поддерживаем старый controlType
                        controlType: task.control || task.controlType || '', // Сохраняем также для обратной совместимости
                        name: taskName,
                        task: taskName, // Сохраняем также в поле task для обратной совместимости
                        days: task.days || 0,
                    startDate: task.startDate ? formatDateKey(task.startDate) : null,
                    endDate: task.endDate ? formatDateKey(task.endDate) : null,
                    dates: Array.isArray(task.dates) ? task.dates.map(d => formatDateKey(d)) : [],
                    status: task.status || 'pending',
                    dateStatuses: task.dateStatuses || {},
                    dateComments: task.dateComments || {},
                    responsible: task.responsible || '',
                    link: task.link || '',
                    baselineDates: Array.isArray(task.baselineDates) ? task.baselineDates.map(d => formatDateKey(d)) : [],
                    baselineStartDate: task.baselineStartDate ? formatDateKey(task.baselineStartDate) : null,
                    baselineEndDate: task.baselineEndDate ? formatDateKey(task.baselineEndDate) : null
                    };
                }),
                settings: {
                    ganttBarStyle: ganttBarStyle || 'dots',
                    showLink: showLink || false,
                    showResponsible: showResponsible || false,
                    zoomLevel: zoomLevel || 1
                },
                // Сохраняем baselineSnapshot для проверки наличия базового плана
                baselineSnapshot: baselineSnapshot || null
            };
        }

        // Сохранить полное состояние графика на сервер
        async function saveFullGanttState() {
            try {
                if (!currentCompany) {
                    console.warn('⚠️ Компания не указана, сохранение пропущено. currentCompany:', currentCompany);
                    console.warn('⚠️ URL:', window.location.href);
                    console.warn('⚠️ localStorage gantt-company:', localStorage.getItem('gantt-company'));
                    return;
                }
                
                if (isViewMode) {
                    console.warn('⚠️ Режим просмотра, сохранение пропущено');
                    return;
                }
                
                // Разблокировано сохранение для всех типов графиков, включая Praktis ID
                const snapshot = createFullGanttSnapshot();
                const companyParam = `?company=${currentCompany}`;
                const url = `/api/gantt-state${companyParam}`;
                
                console.log('💾 Сохранение графика для компании:', currentCompany);
                console.log('📊 Тип графика:', companyChartType);
                console.log('📦 Размер данных:', JSON.stringify(snapshot).length, 'байт');
                console.log('🔗 URL запроса:', url);
                console.log('📊 Количество задач:', snapshot.tasks ? snapshot.tasks.length : 0);
                
                // Получаем информацию о пользователе
                const userStr = localStorage.getItem('gantt-user');
                let userName = 'Неизвестный пользователь';
                let userLogin = null;
                
                console.log('🔍 Получение информации о пользователе:');
                console.log('   localStorage.getItem("gantt-user"):', userStr ? 'найден' : 'не найден');
                
                if (userStr) {
                    try {
                        const user = JSON.parse(userStr);
                        console.log('   Распарсенный пользователь:', user);
                        console.log('   user.name:', user.name);
                        console.log('   user.login:', user.login);
                        
                        // Приоритет: name > login > 'Неизвестный пользователь'
                        if (user.name && user.name.trim()) {
                            userName = user.name.trim();
                        } else if (user.login && user.login.trim()) {
                            userName = user.login.trim();
                        } else {
                            console.warn('⚠️ У пользователя нет ни name, ни login');
                            userName = 'Неизвестный пользователь';
                        }
                        
                        userLogin = user.login || null;
                        console.log('👤 Пользователь для логирования:', { name: userName, login: userLogin });
                    } catch (e) {
                        console.error('❌ Ошибка парсинга пользователя:', e);
                        console.error('   Сырые данные:', userStr);
                        userName = 'Неизвестный пользователь';
                    }
                } else {
                    console.error('❌ Пользователь не найден в localStorage (gantt-user)');
                    console.error('   Режим просмотра:', isViewMode);
                    console.error('   Все ключи localStorage:', Object.keys(localStorage));
                    // В режиме редактирования пользователь должен быть авторизован
                    if (!isViewMode) {
                        console.error('⚠️ ВНИМАНИЕ: Сохранение происходит без авторизованного пользователя!');
                    }
                }
                
                // Создаем детальную информацию об изменениях
                let changeInfo = snapshot.changeInfo || null;
                if (!changeInfo) {
                    // Создаем детальное описание изменений
                    console.log('📝 Создание детального описания изменений...');
                    console.log('   lastSavedState:', lastSavedState ? 'инициализирован' : 'null (первое сохранение)');
                    changeInfo = createChangeDescription();
                    console.log('📝 Детали изменений:', JSON.stringify(changeInfo, null, 2));
                    
                    // Если это первое сохранение, но есть задачи, создаем более информативное описание
                    if (!lastSavedState && tasks && tasks.length > 0) {
                        const taskCount = tasks.length;
                        changeInfo = {
                            action: 'Изменил график',
                            details: `Первое сохранение графика (задач: ${taskCount})`
                        };
                        console.log('📝 Обновлено описание для первого сохранения:', changeInfo);
                    }
                } else {
                    console.log('📝 Используется переданное changeInfo:', JSON.stringify(changeInfo, null, 2));
                }
                
                // Обновляем последнее сохраненное состояние после успешного сохранения
                // (будет обновлено после успешного ответа от сервера)
                
                // Добавляем информацию о пользователе в запрос
                const requestBody = {
                    ...snapshot,
                    userName: userName,
                    userLogin: userLogin, // Добавляем логин для дополнительной идентификации
                    changeInfo: changeInfo
                };
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'X-User-Name': userName
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Ошибка HTTP:', response.status, response.statusText);
                    console.error('❌ Текст ошибки:', errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const responseData = await response.json();
                
                if (responseData && responseData.ok) {
                    console.log('✅ Полное состояние графика сохранено успешно');
                    console.log('✅ Ответ сервера:', responseData);
                    
                    // Обновляем последнее сохраненное состояние для сравнения при следующем сохранении
                    lastSavedState = JSON.parse(JSON.stringify(snapshot));
                    showSaveIndicator(true);
                    // НЕ очищаем историю при автосохранении - пользователь должен иметь возможность
                    // отменить изменения в течение некоторого времени даже после автосохранения.
                    // История будет очищена только при явном сохранении или при загрузке страницы.
                    // clearUndoHistory(); // Закомментировано для возможности отмены после автосохранения
                } else {
                    console.error('❌ Сервер вернул ошибку:', responseData);
                    throw new Error(responseData.error || 'Неизвестная ошибка сохранения');
                }
            } catch (e) {
                console.error('❌ Ошибка при сохранении графика на сервере:', e);
                console.error('❌ Стек ошибки:', e.stack);
                showSaveIndicator(false);
                // Не показываем alert для каждого автосохранения, только логируем
                // alert('Ошибка сохранения: ' + e.message + '\n\nПроверьте консоль браузера для деталей.');
            }
        }

        // Функция для показа индикатора сохранения
        function showSaveIndicator(success) {
            const saveButton = document.getElementById('saveButton');
            const saveButtonText = document.getElementById('saveButtonText');
            
            if (!saveButton || !saveButtonText) return;
            
            if (success) {
                saveButton.classList.add('saving-success');
                saveButtonText.textContent = '✓ Сохранено';
                console.log('💾 Данные сохранены');
                
                // Возвращаем обратно через 2 секунды
                setTimeout(() => {
                    saveButton.classList.remove('saving-success');
                    saveButtonText.textContent = 'Сохранить';
                }, 2000);
            } else {
                saveButton.classList.add('saving-error');
                saveButtonText.textContent = '✗ Ошибка';
                
                setTimeout(() => {
                    saveButton.classList.remove('saving-error');
                    saveButtonText.textContent = 'Сохранить';
                }, 2000);
            }
        }

        // Принудительное сохранение по кнопке
        async function manualSaveGantt() {
            const saveButton = document.getElementById('saveButton');
            const saveButtonText = document.getElementById('saveButtonText');
            
            if (saveButton) {
                saveButton.disabled = true;
                if (saveButtonText) {
                    saveButtonText.textContent = 'Сохранение...';
                }
            }
            
            try {
                await saveFullGanttState();
                showSaveIndicator(true);
            } catch (error) {
                console.error('❌ Ошибка при ручном сохранении:', error);
                showSaveIndicator(false);
                alert('Ошибка сохранения: ' + error.message);
            } finally {
                if (saveButton) {
                    saveButton.disabled = false;
                }
            }
        }

        // Автоматическое сохранение с задержкой (debounce)
        function autoSaveGanttState() {
            console.log('🔄 autoSaveGanttState вызвана');
            console.log('   currentCompany:', currentCompany);
            console.log('   isViewMode:', isViewMode);
            console.log('   URL:', window.location.href);
            
            if (!currentCompany) {
                console.warn('⚠️ autoSaveGanttState: компания не определена, сохранение пропущено');
                console.warn('   Попытка получить из localStorage:', localStorage.getItem('gantt-company'));
                // Попытка восстановить из localStorage
                const savedCompany = localStorage.getItem('gantt-company');
                if (savedCompany) {
                    currentCompany = savedCompany;
                    console.log('✅ Компания восстановлена из localStorage:', currentCompany);
                } else {
                return;
                }
            }
            
            if (isViewMode) {
                console.warn('⚠️ autoSaveGanttState: режим просмотра, сохранение пропущено');
                return;
            }
            
            // Очищаем предыдущий таймер
            if (saveTimeout) {
                clearTimeout(saveTimeout);
                console.log('   Предыдущий таймер очищен');
            }
            
            console.log('⏱️ Запланировано автоматическое сохранение через 1 секунду');
            
            // Уменьшаем задержку до 1 секунды для более быстрого сохранения
            saveTimeout = setTimeout(() => {
                console.log('⏰ Таймер сработал, начинаем сохранение...');
                saveFullGanttState();
            }, 1000);
        }

        // ========== Система истории действий для отмены (Undo) ==========
        
        // Получить ключ для истории в localStorage
        function getUndoHistoryKey() {
            if (!currentCompany) return null;
            return `gantt-undo-history-${currentCompany}`;
        }

        // Загрузить историю из localStorage
        function loadUndoHistory() {
            const key = getUndoHistoryKey();
            if (!key) return;
            
            try {
                const stored = localStorage.getItem(key);
                if (stored) {
                    undoHistory = JSON.parse(stored);
                    // Ограничиваем до MAX_UNDO_HISTORY
                    if (undoHistory.length > MAX_UNDO_HISTORY) {
                        undoHistory = undoHistory.slice(-MAX_UNDO_HISTORY);
                    }
                } else {
                    undoHistory = [];
                }
            } catch (e) {
                console.warn('Ошибка загрузки истории отмены:', e);
                undoHistory = [];
            }
            updateUndoButtonState();
        }

        // Сохранить историю в localStorage
        function saveUndoHistory() {
            const key = getUndoHistoryKey();
            if (!key) return;
            
            try {
                localStorage.setItem(key, JSON.stringify(undoHistory));
            } catch (e) {
                console.warn('Ошибка сохранения истории отмены:', e);
            }
        }

        // Добавить состояние в историю перед изменением
        function addToUndoHistory() {
            // Не сохраняем в историю, если это отмена действия
            if (isUndoing) {
                console.log('⏭️ Пропускаем сохранение в историю (выполняется отмена)');
                return;
            }
            
            // Не сохраняем в режиме просмотра
            if (isViewMode) {
                console.log('⏭️ Пропускаем сохранение в историю (режим просмотра)');
                return;
            }
            
            // Не сохраняем, если компания не определена
            if (!currentCompany) {
                console.log('⏭️ Пропускаем сохранение в историю (компания не определена)');
                return;
            }
            
            console.log('📝 addToUndoHistory: Добавляем состояние в историю отмены');
            console.log('   Текущее количество действий в истории:', undoHistory.length);
            
            // Создаем снимок текущего состояния
            const snapshot = createFullGanttSnapshot();
            console.log('   Снимок создан, задач в снимке:', snapshot.tasks?.length || 0);
            
            // Добавляем в историю
            undoHistory.push(snapshot);
            
            // Ограничиваем размер истории
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                const removed = undoHistory.shift(); // Удаляем самое старое действие
                console.log('   История превысила лимит, удалено старое действие');
            }
            
            console.log('   Новое количество действий в истории:', undoHistory.length);
            
            // Сохраняем в localStorage
            saveUndoHistory();
            
            // Обновляем состояние кнопки
            updateUndoButtonState();
            
            // Сбрасываем флаг сброса плана при любом новом действии
            // (флаг будет установлен заново в confirmResetPlan() если это сброс плана)
            lastActionWasReset = false;
            
            console.log('   ✅ История обновлена, состояние кнопки обновлено');
        }

        // Отменить последнее действие - показывает предупреждение только после сброса плана
        function undoLastAction() {
            // Не отменяем в режиме просмотра
            if (isViewMode) {
                console.warn('Отмена недоступна в режиме просмотра');
                return;
            }
            
            // Проверяем, есть ли что отменять
            if (undoHistory.length === 0) {
                console.warn('Нет действий для отмены');
                return;
            }
            
            // Защита от пустых экранов: проверяем, что текущие данные загружены
            if (!tasks || !Array.isArray(tasks)) {
                console.warn('⚠️ Данные еще не загружены, отмена недоступна');
                showMobileNotification('Пожалуйста, дождитесь загрузки данных перед отменой действия');
                return;
            }
            
            // Проверяем последнее состояние в истории
            const lastState = undoHistory[undoHistory.length - 1];
            if (!lastState || !lastState.tasks || !Array.isArray(lastState.tasks) || lastState.tasks.length === 0) {
                console.warn('⚠️ Последнее состояние в истории не содержит данных');
                showMobileNotification('Невозможно восстановить: состояние не содержит данных');
                return;
            }
            
            // Показываем предупреждение ТОЛЬКО если последнее действие было сбросом плана
            if (lastActionWasReset) {
                // Показываем модальное окно с предупреждением
                const modal = document.getElementById('undoConfirmModal');
                if (modal) {
                    modal.style.display = 'block';
                    
                    // На мобильных устройствах и планшетах позиционируем модальное окно рядом с кнопкой
                    const isMobile = window.innerWidth <= 1024;
                    if (isMobile) {
                        requestAnimationFrame(() => {
                            const undoButton = document.getElementById('undoBtn');
                            if (undoButton) {
                                const modalContent = modal.querySelector('.modal-content');
                                if (modalContent) {
                                    const buttonRect = undoButton.getBoundingClientRect();
                                    const viewportHeight = window.innerHeight;
                                    const buttonBottom = buttonRect.bottom;
                                    const spaceBelow = viewportHeight - buttonBottom;
                                    const spaceAbove = buttonRect.top;
                                    
                                    let topPosition;
                                    if (spaceBelow < 300 && spaceAbove > spaceBelow) {
                                        topPosition = buttonRect.top - 350;
                                    } else {
                                        topPosition = buttonBottom + 10;
                                    }
                                    
                                    modalContent.style.position = 'fixed';
                                    modalContent.style.top = `${Math.max(10, Math.min(topPosition, viewportHeight - 400))}px`;
                                    modalContent.style.left = '50%';
                                    modalContent.style.transform = 'translateX(-50%)';
                                    modalContent.style.margin = '0';
                                    modalContent.style.width = '90%';
                                    modalContent.style.maxWidth = '400px';
                                }
                            }
                        });
                    }
                }
            } else {
                // Если последнее действие НЕ было сбросом плана - выполняем отмену сразу без предупреждения
                performUndo();
            }
        }
        
        // Отменить последнее действие - выполняет фактическую отмену
        function performUndo() {
            // Устанавливаем флаг, чтобы не сохранять в историю при восстановлении
            isUndoing = true;
            
            try {
                // Берем последнее состояние из истории
                const previousState = undoHistory.pop();
                
                // Защита от пустых экранов: проверяем, что состояние существует и содержит данные
                if (!previousState) {
                    console.warn('⚠️ Нет состояния для восстановления');
                    showMobileNotification('Нет данных для восстановления');
                    cancelUndo();
                    return;
                }
                
                // Проверяем, что есть задачи для восстановления
                if (!previousState.tasks || !Array.isArray(previousState.tasks) || previousState.tasks.length === 0) {
                    console.warn('⚠️ Состояние не содержит задач для восстановления');
                    showMobileNotification('Невозможно восстановить: состояние не содержит задач');
                    cancelUndo();
                    return;
                }
                
                // Показываем индикатор загрузки
                showLoadingIndicator('Восстановление данных...');
                
                // Восстанавливаем состояние
                if (previousState.startDate) {
                    startDate = parseDateKey(previousState.startDate);
                }
                
                // Восстанавливаем задачи
                tasks = previousState.tasks.map(task => ({
                    id: task.id,
                    stage: task.stage || '',
                    substage: task.substage || '',
                    control: task.control || task.controlType || '',
                    controlType: task.control || task.controlType || '',
                    name: task.name || task.task || '',
                    task: task.task || task.name || '',
                    days: task.days || 0,
                    startDate: task.startDate ? parseDateKey(task.startDate) : null,
                    endDate: task.endDate ? parseDateKey(task.endDate) : null,
                    dates: Array.isArray(task.dates) ? task.dates.map(d => parseDateKey(d)) : [],
                    status: task.status || 'pending',
                    dateStatuses: task.dateStatuses || {},
                    dateComments: task.dateComments || {},
                    responsible: task.responsible || '',
                    link: task.link || '',
                    baselineDates: Array.isArray(task.baselineDates) ? task.baselineDates.map(d => parseDateKey(d)) : [],
                    baselineStartDate: task.baselineStartDate ? parseDateKey(task.baselineStartDate) : null,
                    baselineEndDate: task.baselineEndDate ? parseDateKey(task.baselineEndDate) : null
                }));
                
                // Восстанавливаем настройки
                if (previousState.settings) {
                    ganttBarStyle = previousState.settings.ganttBarStyle || 'dots';
                    showLink = previousState.settings.showLink || false;
                    showResponsible = previousState.settings.showResponsible || false;
                    zoomLevel = previousState.settings.zoomLevel || 1;
                }
                
                // Обновляем nextTaskId
                if (tasks.length > 0) {
                    const maxId = Math.max(...tasks.map(t => t.id));
                    nextTaskId = maxId + 1;
                }
                
                // Сохраняем текущую позицию прокрутки и активный элемент перед перерисовкой
                const scrollY = window.scrollY || window.pageYOffset;
                const scrollX = window.scrollX || window.pageXOffset;
                
                // Также сохраняем прокрутку контейнера диаграммы, если есть
                const chartContainer = document.getElementById('ganttChart');
                const chartScrollTop = chartContainer ? chartContainer.scrollTop : 0;
                const chartScrollLeft = chartContainer ? chartContainer.scrollLeft : 0;
                
                // Сохраняем активный элемент и убираем фокус, чтобы предотвратить автоматическую прокрутку
                const activeElement = document.activeElement;
                const activeElementInfo = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') 
                    ? { element: activeElement, selectionStart: activeElement.selectionStart, selectionEnd: activeElement.selectionEnd }
                    : null;
                
                if (activeElementInfo) {
                    activeElementInfo.element.blur();
                }

                // Перерисовываем интерфейс
                renderGantt();
                renderTable();
                updateStatistics();
                renderStageTabs();
                
                // Проверяем, что данные успешно восстановлены
                if (!tasks || tasks.length === 0) {
                    console.error('❌ Критическая ошибка: задачи не восстановлены');
                    hideLoadingIndicator();
                    showMobileNotification('Ошибка: не удалось восстановить данные. Пожалуйста, обновите страницу.');
                    cancelUndo();
                    return;
                }
                
                // Восстанавливаем позицию прокрутки сразу, без задержки
                window.scrollTo(scrollX, scrollY);
                const newChartContainer = document.getElementById('ganttChart');
                if (newChartContainer) {
                    newChartContainer.scrollTop = chartScrollTop;
                    newChartContainer.scrollLeft = chartScrollLeft;
                }
                
                // Восстанавливаем фокус на элемент, если он все еще существует (без прокрутки)
                if (activeElementInfo && document.contains(activeElementInfo.element)) {
                    requestAnimationFrame(() => {
                        try {
                            activeElementInfo.element.focus({ preventScroll: true });
                            if (activeElementInfo.element.setSelectionRange && 
                                activeElementInfo.selectionStart !== null && 
                                activeElementInfo.selectionEnd !== null) {
                                activeElementInfo.element.setSelectionRange(
                                    activeElementInfo.selectionStart, 
                                    activeElementInfo.selectionEnd
                                );
                            }
                        } catch (e) {
                            // Игнорируем ошибки при восстановлении фокуса
                        }
                    });
                }
                
                // Сохраняем обновленную историю
                saveUndoHistory();
                
                // Обновляем состояние кнопки
                updateUndoButtonState();
                
                // Сбрасываем флаг сброса плана после успешной отмены
                lastActionWasReset = false;
                
                console.log('✅ Действие отменено, осталось действий в истории:', undoHistory.length);
                
                // Скрываем индикатор загрузки
                hideLoadingIndicator();
                
                // Закрываем модальное окно после успешной отмены
                cancelUndo();
            } catch (e) {
                console.error('❌ Ошибка при отмене действия:', e);
                hideLoadingIndicator();
                showMobileNotification('Ошибка при отмене действия: ' + e.message);
                cancelUndo();
            } finally {
                isUndoing = false;
            }
        }
        
        // Показать уведомление для мобильных устройств (вместо alert)
        function showMobileNotification(message) {
            // Удаляем существующее уведомление, если есть
            const existing = document.getElementById('mobileNotification');
            if (existing) {
                existing.remove();
            }
            
            const isMobile = window.innerWidth <= 1024;
            const notification = document.createElement('div');
            notification.id = 'mobileNotification';
            
            const baseStyles = `
                position: fixed;
                top: ${isMobile ? '20px' : '50%'};
                left: 50%;
                transform: translateX(-50%) ${isMobile ? '' : 'translateY(-50%)'};
                background: rgba(244, 67, 54, 0.95);
                color: white;
                padding: ${isMobile ? '14px 20px' : '16px 32px'};
                border-radius: ${isMobile ? '12px' : '8px'};
                z-index: 10001;
                font-weight: 500;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
                text-align: center;
                word-wrap: break-word;
                max-width: ${isMobile ? '90%' : '500px'};
                font-size: ${isMobile ? '13px' : '15px'};
                line-height: 1.4;
            `;
            
            notification.style.cssText = baseStyles;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Автоматически скрываем через 4 секунды
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.3s ease-out';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, 4000);
        }
        
        // Показать индикатор загрузки
        function showLoadingIndicator(message) {
            // Удаляем существующий индикатор, если есть
            hideLoadingIndicator();
            
            // Определяем, мобильное ли устройство
            const isMobile = window.innerWidth <= 1024;
            
            const indicator = document.createElement('div');
            indicator.id = 'undoLoadingIndicator';
            
            // Адаптивные стили для мобильных и десктопов
            const baseStyles = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.85);
                color: white;
                border-radius: ${isMobile ? '12px' : '8px'};
                z-index: 10000;
                font-weight: 500;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                text-align: center;
                word-wrap: break-word;
                max-width: ${isMobile ? '90%' : 'auto'};
            `;
            
            const mobileStyles = isMobile ? `
                padding: 16px 24px;
                font-size: 14px;
                min-width: 200px;
            ` : `
                padding: 20px 40px;
                font-size: 16px;
            `;
            
            indicator.style.cssText = baseStyles + mobileStyles;
            indicator.textContent = message || 'Загрузка...';
            document.body.appendChild(indicator);
        }
        
        // Скрыть индикатор загрузки
        function hideLoadingIndicator() {
            const indicator = document.getElementById('undoLoadingIndicator');
            if (indicator) {
                indicator.remove();
            }
        }
        
        // Закрыть модальное окно отмены
        function cancelUndo() {
            const modal = document.getElementById('undoConfirmModal');
            if (modal) {
                modal.style.display = 'none';
                // Сбрасываем стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
        }
        
        // Подтвердить отмену действия
        function confirmUndo() {
            performUndo();
        }

        // Обновить состояние кнопки отмены
        function updateUndoButtonState() {
            const undoBtn = document.getElementById('undoBtn');
            if (!undoBtn) {
                console.warn('⚠️ updateUndoButtonState: Кнопка отмены не найдена');
                return;
            }
            
            // Проверяем режим просмотра через canEdit()
            const canEditMode = canEdit && canEdit();
            const hasHistory = undoHistory.length > 0 && canEditMode && currentCompany;
            
            console.log('🔘 updateUndoButtonState:', {
                historyLength: undoHistory.length,
                canEditMode: canEditMode,
                currentCompany: currentCompany,
                hasHistory: hasHistory
            });
            
            if (hasHistory) {
                undoBtn.classList.remove('disabled');
                undoBtn.disabled = false;
                console.log('   ✅ Кнопка отмены АКТИВНА');
            } else {
                undoBtn.classList.add('disabled');
                undoBtn.disabled = true;
                console.log('   ❌ Кнопка отмены ЗАБЛОКИРОВАНА');
                if (undoHistory.length === 0) {
                    console.log('      Причина: история пуста');
                }
                if (!canEditMode) {
                    console.log('      Причина: режим редактирования недоступен');
                }
                if (!currentCompany) {
                    console.log('      Причина: компания не определена');
                }
            }
        }

        // Очистить историю (например, при загрузке с сервера после сохранения)
        function clearUndoHistory() {
            undoHistory = [];
            const key = getUndoHistoryKey();
            if (key) {
                try {
                    localStorage.removeItem(key);
                } catch (e) {
                    console.warn('Ошибка очистки истории отмены:', e);
                }
            }
            updateUndoButtonState();
        }

        // Загрузить полное состояние графика с сервера
        async function loadFullGanttState() {
            try {
                if (!currentCompany) {
                    console.warn('⚠️ Компания не указана, загрузка пропущена');
                    return false;
                }
                
                // Сначала проверяем тип графика компании
                // Загружаем информацию о компании, чтобы проверить тип графика
                try {
                    const companyParam = `?company=${currentCompany}`;
                    const companyInfoRes = await fetch(`/api/company-info${companyParam}`);
                    if (companyInfoRes.ok) {
                        const companyInfo = await companyInfoRes.json();
                        if (companyInfo && companyInfo.chartType) {
                            const chartType = companyInfo.chartType;
                            console.log('📊 Тип графика компании:', chartType);
                            
                            // Разблокирована загрузка для всех типов графиков, включая Praktis ID
                            // Сохраняем тип графика для дальнейшего использования
                            companyChartType = chartType;
                        }
                    }
                } catch (e) {
                    console.warn('⚠️ Не удалось проверить тип графика компании:', e);
                    // Продолжаем загрузку, если не удалось проверить тип
                }
                
                const companyParam = `?company=${currentCompany}`;
                console.log('📥 Загрузка данных графика для компании:', currentCompany);
                const res = await fetch(`/api/gantt-state${companyParam}`);
                if (!res.ok) {
                    console.warn('⚠️ Ошибка загрузки данных графика:', res.status, res.statusText);
                    return false;
                }
                const data = await res.json();
                console.log('📦 Получены данные с сервера:', data ? 'данные получены' : 'null');
                
                // Если данных нет или формат неправильный, возвращаем false
                if (!data) {
                    console.log('ℹ️ Файл данных не существует, будет использована инициализация по умолчанию');
                    return false;
                }
                
                // Проверяем наличие задач
                if (!data.tasks || !Array.isArray(data.tasks)) {
                    console.warn('⚠️ Данные не содержат массив задач, будет использована инициализация по умолчанию');
                    return false;
                }
                
                // Если массив задач пустой, тоже используем инициализацию по умолчанию
                if (data.tasks.length === 0) {
                    console.warn('⚠️ Массив задач пустой, будет использована инициализация по умолчанию');
                    return false;
                }

                console.log('✅ Найдено задач в данных:', data.tasks.length);

                // Проверяем версию данных (старый формат baseline или новый полный формат)
                const isFullFormat = data.version && data.version === '1.0';

                if (isFullFormat) {
                    console.log('✅ Формат данных: полный (version 1.0)');
                    // Восстанавливаем startDate проекта
                    if (data.startDate) {
                        if (data.startDate instanceof Date) {
                            startDate = new Date(data.startDate);
                        } else if (typeof data.startDate === 'string') {
                            const parts = data.startDate.split('-');
                            if (parts.length === 3) {
                                startDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                            }
                        }
                    }

                    // Восстанавливаем задачи
                    tasks = data.tasks.map(task => {
                        // Правильно восстанавливаем названия задач с обратной совместимостью
                        let taskName = '';
                        let taskNameField = '';
                        
                        // Приоритет: task.task > task.name > пустая строка
                        if (task.task) {
                            taskName = task.task;
                            taskNameField = task.task;
                        } else if (task.name) {
                            taskName = task.name;
                            taskNameField = task.name;
                        }
                        
                        // Синхронизируем оба поля
                        const taskObj = {
                            id: task.id,
                            stage: task.stage || '',
                            substage: task.substage || '',
                            control: task.control || task.controlType || '', // Поддержка старого названия controlType
                            name: taskName,
                            task: taskNameField,
                            days: task.days || 0,
                            status: task.status || 'pending',
                            dateStatuses: task.dateStatuses || {},
                            dateComments: task.dateComments || {},
                            responsible: task.responsible || '',
                            link: task.link || 'О_Н', // Все задачи по умолчанию О_Н (первая тоже, но select заблокирован)
                            dates: [],
                            startDate: null,
                            endDate: null
                        };

                        // Восстанавливаем даты
                        if (task.dates && Array.isArray(task.dates)) {
                            taskObj.dates = task.dates.map(dateStr => {
                                // Если уже объект Date, возвращаем его
                                if (dateStr instanceof Date) {
                                    return dateStr;
                                }
                                // Если строка, парсим её
                                if (typeof dateStr === 'string') {
                                    const parts = dateStr.split('-');
                                    if (parts.length === 3) {
                                        return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                                    }
                                }
                                // Если не удалось распарсить, возвращаем текущую дату
                                console.warn('Не удалось распарсить дату:', dateStr);
                                return new Date();
                            });
                            if (taskObj.dates.length > 0) {
                                taskObj.startDate = taskObj.dates[0];
                                taskObj.endDate = taskObj.dates[taskObj.dates.length - 1];
                            }
                        }

                        // Восстанавливаем baseline данные
                        if (task.baselineDates && Array.isArray(task.baselineDates)) {
                            taskObj.baselineDates = task.baselineDates;
                        }
                        if (task.baselineStartDate) {
                            const parts = task.baselineStartDate.split('-');
                            taskObj.baselineStartDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                        }
                        if (task.baselineEndDate) {
                            const parts = task.baselineEndDate.split('-');
                            taskObj.baselineEndDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                        }

                        return taskObj;
                    });

                    // Восстанавливаем настройки
                    if (data.settings) {
                        if (data.settings.ganttBarStyle) ganttBarStyle = data.settings.ganttBarStyle;
                        if (data.settings.showLink !== undefined) {
                            showLink = data.settings.showLink;
                            // Применяем состояние кнопки и класса body
                            const linkBtn = document.getElementById('linkToggleBtn');
                            if (linkBtn) {
                                if (showLink) {
                                    linkBtn.classList.add('active');
                                    document.body.classList.add('show-link');
                                } else {
                                    linkBtn.classList.remove('active');
                                    document.body.classList.remove('show-link');
                                }
                            }
                        }
                        if (data.settings.showResponsible !== undefined) showResponsible = data.settings.showResponsible;
                        if (data.settings.zoomLevel) zoomLevel = data.settings.zoomLevel;
                    }

                    // Восстанавливаем baselineSnapshot
                    if (data.baselineSnapshot) {
                        baselineSnapshot = data.baselineSnapshot;
                        console.log('✅ baselineSnapshot восстановлен из сохранённых данных');
                        applyBaselineToTasks();
                    } else {
                        // Если baselineSnapshot не найден, но есть baselineDates в задачах, пытаемся восстановить
                        const hasBaselineDates = tasks.some(t => Array.isArray(t.baselineDates) && t.baselineDates.length > 0);
                        if (hasBaselineDates) {
                            // Восстанавливаем baselineSnapshot из данных задач
                            baselineSnapshot = buildBaselineSnapshot();
                            console.log('✅ baselineSnapshot восстановлен из baselineDates задач');
                        } else {
                            baselineSnapshot = null;
                            console.log('ℹ️ baselineSnapshot не найден, базовый план не задан');
                        }
                    }

                    // Обновляем счётчик ID
                    if (tasks.length > 0) {
                        nextTaskId = Math.max(...tasks.map(t => t.id)) + 1;
                    }

                    // Перерисовываем график и таблицу
                    updateStatistics();
                    renderGantt();
                    renderTable();
                    renderStageTabs();
                    // Обновляем состояние кнопки директивного плана после восстановления baselineSnapshot
                    updateBaselineToggleButton();
                    autoSaveGanttState(); // Автоматическое сохранение после загрузки

                    console.log('✅ Полное состояние графика загружено, задач:', tasks.length);
                    // Инициализируем lastSavedState для отслеживания изменений
                    lastSavedState = JSON.parse(JSON.stringify(data));
                    console.log('✅ lastSavedState инициализирован для отслеживания изменений');
                    
                    return true;
                } else {
                    // Старый формат baseline - используем существующую логику
                    console.warn('⚠️ Данные в старом формате (без version), будет использована инициализация по умолчанию');
                    return false;
                }
            } catch (e) {
                console.error('❌ Ошибка загрузки полного состояния графика с сервера:', e);
                return false;
            }
        }

        // Сохранить baseline на сервер (без диалогов, просто best-effort)
        async function saveBaselineToServer(snapshot) {
            try {
                const companyParam = currentCompany ? `?company=${currentCompany}` : '';
                await fetch(`/api/gantt-state${companyParam}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(snapshot)
                });
            } catch (e) {
                console.warn('Не удалось сохранить директивный план на сервере:', e);
            }
        }

        // Загрузить baseline-план с сервера (если он есть)
        async function loadBaselineFromServer() {
            try {
                const companyParam = currentCompany ? `?company=${currentCompany}` : '';
                const res = await fetch(`/api/gantt-state${companyParam}`);
                if (!res.ok) return;
                const data = await res.json();
                if (!data || !Array.isArray(data.tasks)) return;
                baselineSnapshot = data;
                applyBaselineToTasks();
                // Обновляем состояние кнопки после загрузки
                updateBaselineToggleButton();
            } catch (e) {
                // тихо игнорируем, если сервер недоступен
                console.warn('Не удалось загрузить директивный план с сервера:', e);
            }
        }

        function showBaselineToast(message) {
            // Создаем элемент если его нет
            let el = document.getElementById('baselineToast');
            if (!el) {
                el = document.createElement('div');
                el.id = 'baselineToast';
                el.className = 'baseline-toast';
                document.body.appendChild(el);
                console.log('Baseline toast element created');
            }
            
            // Убеждаемся что элемент видим
            el.textContent = message;
            el.style.display = 'block';
            el.classList.add('visible');
            
            // Очищаем предыдущий таймер
            if (baselineToastTimer) {
                clearTimeout(baselineToastTimer);
            }
            
            // Скрываем через 3 секунды
            baselineToastTimer = setTimeout(() => {
                if (el) {
                    el.classList.remove('visible');
                    setTimeout(() => {
                        if (el && !el.classList.contains('visible')) {
                            el.style.display = 'none';
                        }
                    }, 300);
                }
            }, 3000);
            
            console.log('Baseline toast shown:', message);
        }

        // Функция для переключения отображения директивного плана (дублирует F3)
        function toggleBaselineDisplay() {
            // Проверяем, задан ли базовый план
            const hasBaseline =
                baselineSnapshot &&
                Array.isArray(baselineSnapshot.tasks) &&
                baselineSnapshot.tasks.some(t => Array.isArray(t.baselineDates) && t.baselineDates.length > 0);

            if (!hasBaseline) {
                if (isViewMode) {
                    showBaselineToast('Директивный план не задан. В режиме просмотра можно только включить отображение существующего плана.');
                } else {
                    showBaselineToast('Базовый план не задан. Нажмите F2, чтобы сохранить текущий график как директивный.');
                }
                return;
            }

            // Переключаем отображение
            showBaseline = !showBaseline;
            updateBaselineToggleButton();
            renderGantt();
        }

        // Обновление состояния кнопки "Директивный план"
        function updateBaselineToggleButton() {
            const btn = document.getElementById('baselineToggleBtn');
            if (!btn) return;
            
            if (showBaseline) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }

        // Функция для установки базового плана (дублирует F2)
        function setBaselinePlan() {
            if (!canEdit()) {
                showBaselineToast('В режиме просмотра нельзя задать новый директивный план. Можно только включить отображение существующего.');
                return;
            }

            const newSnapshot = buildBaselineSnapshot();
            const hasExistingBaseline =
                baselineSnapshot &&
                Array.isArray(baselineSnapshot.tasks) &&
                baselineSnapshot.tasks.some(t => Array.isArray(t.baselineDates) && t.baselineDates.length > 0);

            console.log('setBaselinePlan called. hasExistingBaseline:', hasExistingBaseline, 'baselineSnapshot:', baselineSnapshot);

            if (hasExistingBaseline) {
                // Показываем модальное окно подтверждения перезаписи
                openBaselineConfirmModal(newSnapshot);
            } else {
                // Первое задание базового плана
                try {
                    baselineSnapshot = newSnapshot;
                    applyBaselineToTasks();
                    saveBaselineToServer(baselineSnapshot);
                    // Сохраняем полное состояние, чтобы baselineSnapshot попал в файл
                    autoSaveGanttState();
                    console.log('Calling showBaselineToast for first time from button');
                    // Показываем сообщение сразу
                    showBaselineToast('Вы задали базовый план. Нажмите "Директивный план" или F3 для отображения.');
                    // Обновляем состояние кнопки
                    updateBaselineToggleButton();
                } catch (error) {
                    console.error('Ошибка при сохранении базового плана:', error);
                    // Показываем сообщение даже при ошибке
                    showBaselineToast('Вы задали базовый план. Нажмите "Директивный план" или F3 для отображения.');
                    updateBaselineToggleButton();
                }
            }
        }

        function openBaselineConfirmModal(snapshotToApply) {
            const modal = document.getElementById('baselineConfirmModal');
            if (!modal) return;
            pendingBaselineSnapshot = snapshotToApply;
            modal.style.display = 'block';
        }

        function closeBaselineConfirmModal() {
            const modal = document.getElementById('baselineConfirmModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Модальное окно для ошибок валидации дат
        function openDateValidationModal(message) {
            const modal = document.getElementById('dateValidationModal');
            const msgEl = document.getElementById('dateValidationMessage');
            if (!modal || !msgEl) return;
            msgEl.textContent = message || 'Дата окончания не может быть раньше даты начала.';
            modal.style.display = 'block';
        }

        function closeDateValidationModal() {
            const modal = document.getElementById('dateValidationModal');
            if (!modal) return;
            modal.style.display = 'none';
        }

        function confirmBaselineOverwrite() {
            // Дополнительная проверка режима просмотра для безопасности
            if (!canEdit()) {
                showBaselineToast('В режиме просмотра нельзя задать новый директивный план. Можно только включить отображение существующего.');
                pendingBaselineSnapshot = null;
                closeBaselineConfirmModal();
                return;
            }

            if (pendingBaselineSnapshot) {
                try {
                    baselineSnapshot = pendingBaselineSnapshot;
                    applyBaselineToTasks();
                    saveBaselineToServer(baselineSnapshot);
                    // Сохраняем полное состояние, чтобы baselineSnapshot попал в файл
                    autoSaveGanttState();
                    // Показываем сообщение сразу
                    showBaselineToast('Базовый план перезаписан. Нажмите "Директивный план" или F3 для отображения.');
                    // Обновляем состояние кнопки
                    updateBaselineToggleButton();
                } catch (error) {
                    console.error('Ошибка при перезаписи базового плана:', error);
                    // Показываем сообщение даже при ошибке
                    showBaselineToast('Базовый план перезаписан. Нажмите "Директивный план" или F3 для отображения.');
                    updateBaselineToggleButton();
                }
            }
            pendingBaselineSnapshot = null;
            closeBaselineConfirmModal();
        }

        function cancelBaselineOverwrite() {
            pendingBaselineSnapshot = null;
            closeBaselineConfirmModal();
        }

        // Обновление статистики
        function updateStatistics() {
            // Используем количество этапов из редакции этапов (stageConfig), независимо от названия
            document.getElementById('totalStages').textContent = stageConfig.length;
            document.getElementById('totalTasks').textContent = tasks.length;
            
            // Подсчет рабочих дней по календарю из Ганта (между минимальной датой начала и максимальной датой окончания)
            // Исключаем дни, помеченные как выходные (weekend-manual) вручную пользователем
            let totalDays = 0;
            if (tasks.length > 0) {
                // Находим минимальную дату начала среди всех задач
                let minStartDate = null;
                // Находим максимальную дату окончания среди всех задач
                let maxEndDate = null;
                
                tasks.forEach(task => {
                    if (task.startDate) {
                        const startDate = new Date(task.startDate);
                        if (!minStartDate || startDate < minStartDate) {
                            minStartDate = startDate;
                        }
                    }
                    if (task.endDate) {
                        const endDate = new Date(task.endDate);
                        if (!maxEndDate || endDate > maxEndDate) {
                            maxEndDate = endDate;
                        }
                    }
                });
                
                // Если есть обе даты, считаем рабочие дни между ними, исключая дни со статусом "weekend-manual"
                if (minStartDate && maxEndDate) {
                    // Собираем все дни, помеченные как выходные во всех задачах
                    const weekendManualDates = new Set();
                    tasks.forEach(task => {
                        if (task.dateStatuses) {
                            Object.keys(task.dateStatuses).forEach(dateKey => {
                                if (task.dateStatuses[dateKey] === 'weekend-manual') {
                                    weekendManualDates.add(dateKey);
                                }
                            });
                        }
                    });
                    
                    // Считаем рабочие дни, исключая выходные дни
                    const workdays = getWorkdaysBetweenExcludingWeekends(minStartDate, maxEndDate, weekendManualDates);
                    totalDays = workdays.length;
                }
            }
            document.getElementById('totalDays').textContent = totalDays;

            if (tasks.length > 0) {
                const lastTask = tasks[tasks.length - 1];
                const completionDate = new Date(lastTask.endDate);
                const options = { year: 'numeric', month: 'long', day: 'numeric' };
                document.getElementById('completionDate').textContent = 
                    completionDate.toLocaleDateString('ru-RU', options);
            }
        }

        // Вспомогательная функция: применить ширину к элементу колонки
        function applyColumnWidth(element, key) {
            if (!element || !ganttColumnWidths[key]) return;
            
            // Для колонок "Связь" и "Ответственный" CSS управляет шириной через анимацию
            // Не применяем инлайн-стили, чтобы не перезаписывать CSS анимацию
            if (key === 'link' || key === 'responsible') {
                return;
            }
            
            const w = ganttColumnWidths[key];
            element.style.width = w + 'px';
            element.style.minWidth = w + 'px';
            element.style.maxWidth = w + 'px';
            element.style.flex = `0 0 ${w}px`;
        }

        // Инициализация ресайзера для колонки
        function addColumnResizer(element, key) {
            if (!element) return;
            element.classList.add('gantt-resizable');
            const resizer = document.createElement('div');
            resizer.className = 'gantt-resizer';
            resizer.dataset.columnKey = key;

            let startX = 0;
            let startWidth = 0;

            function onMouseMove(e) {
                const delta = e.clientX - startX;
                const newWidth = Math.max(80, Math.min(500, startWidth + delta));
                ganttColumnWidths[key] = newWidth;
                renderGantt();
            }

            function onMouseUp() {
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
            }

            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                startX = e.clientX;
                startWidth = ganttColumnWidths[key] || element.getBoundingClientRect().width;
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
            });

            element.appendChild(resizer);
        }

        // Вспомогательная функция для вычисления количества символов, которые помещаются в ширину
        // Используем кэшированный элемент для измерения, чтобы не создавать его каждый раз
        let measureElement = null;
        function getMeasureElement() {
            if (!measureElement) {
                measureElement = document.createElement('span');
                measureElement.style.position = 'absolute';
                measureElement.style.visibility = 'hidden';
                measureElement.style.whiteSpace = 'nowrap';
                measureElement.style.fontSize = '11px';
                measureElement.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                measureElement.style.fontWeight = '500';
                document.body.appendChild(measureElement);
            }
            return measureElement;
        }

        function calculateVisibleChars(text, maxWidth, fontSize = 11, fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif') {
            if (!text || text.length === 0) return 0;
            
            const measureEl = getMeasureElement();
            measureEl.style.fontSize = fontSize + 'px';
            measureEl.style.fontFamily = fontFamily;
            
            // Проверяем, помещается ли весь текст
            measureEl.textContent = text;
            const fullWidth = measureEl.offsetWidth;
            
            // Если текст помещается полностью, возвращаем полную длину
            if (fullWidth <= maxWidth) {
                return text.length;
            }
            
            // Бинарный поиск для определения максимального количества символов
            let left = 0;
            let right = text.length;
            let result = 0;
            
            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const testText = text.substring(0, mid);
                
                measureEl.textContent = testText;
                const testWidth = measureEl.offsetWidth;
                
                if (testWidth <= maxWidth) {
                    result = mid;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            
            return result;
        }

        // Отрисовка названия задачи в левой колонке (с поддержкой редактирования)
        function renderTaskLabelContent(labelElement, task, index) {
            labelElement.innerHTML = '';
            const taskName = task.task || task.name || 'Без названия';
            
            // Обновляем data-tooltip с актуальным названием задачи
            // Не используем HTML-сущности, так как CSS attr() их не декодирует
            // setAttribute автоматически экранирует специальные символы для HTML-атрибутов
            if (taskName && taskName.trim()) {
                labelElement.setAttribute('data-tooltip', taskName);
            } else {
                labelElement.removeAttribute('data-tooltip');
            }
            
            // Получаем текущую ширину столбца
            const columnWidth = ganttColumnWidths.label || 260;
            // Вычитаем padding (8px слева + 10px справа = 18px) и границу (2px)
            const availableWidth = columnWidth - 18 - 2;
            
            // Вычисляем, сколько символов поместится в доступную ширину
            const visibleChars = calculateVisibleChars(taskName, availableWidth);
            
            // Определяем, нужно ли обрезать текст
            const needsTruncation = visibleChars < taskName.length;
            
            // Формируем отображаемое имя
            let displayName;
            if (needsTruncation) {
                displayName = taskName.substring(0, visibleChars) + '...';
            } else {
                displayName = taskName;
            }
            
            const span = document.createElement('span');
            span.textContent = displayName;
            
            // Удаляем старый title, чтобы не показывать стандартную подсказку браузера
            span.removeAttribute('title');

            // Обработчик одинарного клика - только выделение строки
            const handleSingleClick = (e) => {
                // Предотвращаем срабатывание drag and drop при клике на label
                if (e) {
                    e.preventDefault();
                    // НЕ останавливаем всплытие, чтобы строка могла выделиться
                }
                
                // Находим родительскую строку
                const row = labelElement.closest('.gantt-row');
                
                // Выделяем строку при клике на label
                if (row && row.dataset.taskId) {
                    const taskId = parseInt(row.dataset.taskId);
                    if (taskId) {
                        selectTask(taskId, { range: false });
                    }
                }
            };

            // Обработчик двойного клика - открытие инпута для редактирования
            const startEditing = (e) => {
                // Предотвращаем срабатывание drag and drop при клике на label
                if (e) {
                    e.preventDefault();
                    e.stopPropagation(); // Останавливаем всплытие для двойного клика
                }
                
                if (!canEdit()) {
                    return; // Блокируем редактирование в режиме просмотра
                }
                
                // Проверяем, не редактируется ли уже эта задача
                if (labelElement.querySelector('input.gantt-task-input')) {
                    return; // Уже в режиме редактирования
                }
                
                // Находим родительскую строку
                const row = labelElement.closest('.gantt-row');
                
                // Выделяем строку при открытии редактирования
                if (row && row.dataset.taskId) {
                    const taskId = parseInt(row.dataset.taskId);
                    if (taskId) {
                        selectTask(taskId, { range: false });
                    }
                }
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'gantt-task-input';
                input.value = task.task || task.name || '';

                labelElement.innerHTML = '';
                labelElement.appendChild(input);
                
                // Небольшая задержка для фокуса, чтобы избежать конфликтов с drag
                setTimeout(() => {
                    input.focus();
                    input.select();
                }, 10);

                // Отключаем drag and drop для строки
                let wasDraggable = false;
                if (row) {
                    wasDraggable = row.draggable;
                    row.draggable = false;
                }

                const finish = (save) => {
                    if (save) {
                        const newName = input.value.trim();
                        if (newName) {
                            task.task = newName;
                            task.name = newName; // Синхронизируем оба поля
                        }
                    }
                    
                    // Включаем drag and drop обратно
                    if (row && wasDraggable) {
                        row.draggable = true;
                    }
                    
                    renderTaskLabelContent(labelElement, task, index);
                    // Восстанавливаем data-tooltip после перерисовки
                    const taskName = task.task || task.name || 'Без названия';
                    if (taskName && taskName.trim()) {
                        labelElement.setAttribute('data-tooltip', taskName);
                    }
                    renderTable();
                };

                input.addEventListener('blur', () => finish(true));
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        finish(false);
                    }
                });
                
                // Предотвращаем срабатывание drag and drop при взаимодействии с input
                input.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });
                input.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                input.addEventListener('select', (e) => {
                    e.stopPropagation();
                });
            };

            // Обработчик одинарного клика - только выделение
            labelElement.addEventListener('click', handleSingleClick);
            // Обработчик двойного клика - открытие инпута
            labelElement.addEventListener('dblclick', startEditing);
            // Также добавляем на mousedown для предотвращения drag
            labelElement.addEventListener('mousedown', (e) => {
                // Если это не input для редактирования, предотвращаем drag
                if (!e.target.classList.contains('gantt-task-input') && 
                    !e.target.closest('input.gantt-task-input')) {
                    e.stopPropagation();
                }
            });

            labelElement.appendChild(span);
        }

        // Функция для пересчета позиций меток этапов (вынесена на уровень модуля для доступа из setZoom)
        function recalculateStageLabelsPositions() {
            const chartContainer = document.getElementById('ganttChart');
            if (!chartContainer) return;
            
            // Проверяем, что в контейнере есть хотя бы одна строка (DOM готов)
            const hasRows = chartContainer.querySelector('.gantt-row');
            if (!hasRows) {
                // Если строк еще нет, откладываем пересчет
                setTimeout(() => recalculateStageLabelsPositions(), 50);
                return;
            }
            
            // Находим контейнеры заново (на случай, если DOM изменился)
            const currentChartContainerParent = chartContainer.closest('.chart-container');
            const currentStageLabelsContainer = currentChartContainerParent 
                ? currentChartContainerParent.querySelector('.gantt-stage-labels')
                : chartContainer.querySelector('.gantt-stage-labels');
            
            // Если контейнер не найден, выходим
            if (!currentStageLabelsContainer || !currentChartContainerParent) {
                return;
            }
            
            // Пересоздаем tasksByStage для надежности
            const tasksByStageRecalc = {};
            tasks.forEach((task, index) => {
                const stage = task.stage || 'Без этапа';
                if (!tasksByStageRecalc[stage]) {
                    tasksByStageRecalc[stage] = [];
                }
                tasksByStageRecalc[stage].push({ task, index });
            });
            
            // Вычисляем начальную позицию (высота заголовка)
            const header = document.querySelector('.gantt-header');
            const headerHeight = header ? header.offsetHeight : 80;
            
            // Пересчитываем позиции всех существующих меток и разделителей
            Object.keys(tasksByStageRecalc).forEach((stageName, stageIndex) => {
                const stageTasks = tasksByStageRecalc[stageName];
                const stageLabel = currentStageLabelsContainer.querySelector(`.gantt-stage-label[data-stage-name="${stageName}"]`);
                
                if (!stageLabel) {
                    return; // Пропускаем, если метка не найдена
                }
                
                const isStageCollapsed = collapsedStages.has(stageName);
                
                // Вычисляем высоту этапа (сумма высот всех строк этапа)
                let stageHeight = 0;
                let actualTop = headerHeight; // Значение по умолчанию
                
                if (isStageCollapsed) {
                    // Ищем строку этапа в диаграмме Ганта
                    const stageRow = chartContainer.querySelector(`.gantt-row[data-stage-name="${stageName}"]`);
                    if (stageRow) {
                        // Используем offsetTop для позиции относительно контейнера (более надежно)
                        stageHeight = stageRow.offsetHeight || 35;
                        // Вычисляем реальную позицию относительно контейнера диаграммы
                        actualTop = stageRow.offsetTop;
                    } else {
                        stageHeight = 35;
                    }
                } else {
                    // Для развернутых этапов используем позицию первой задачи и суммируем высоты
                    if (stageTasks.length > 0) {
                        const firstTaskRow = chartContainer.querySelector(`.gantt-row[data-task-id="${stageTasks[0].task.id}"]`);
                        if (firstTaskRow && firstTaskRow.style.display !== 'none') {
                            // Используем offsetTop для позиции относительно контейнера
                            actualTop = firstTaskRow.offsetTop;
                            
                            // Суммируем высоты всех видимых задач этапа
                            stageTasks.forEach(({ task }) => {
                                const taskRow = chartContainer.querySelector(`.gantt-row[data-task-id="${task.id}"]`);
                                if (taskRow && !taskRow.classList.contains('stage-collapsed') && taskRow.style.display !== 'none') {
                                    stageHeight += (taskRow.offsetHeight || 35);
                                }
                            });
                        }
                    }
                    
                    // Если высота не вычислена, используем минимальную
                    if (stageHeight === 0) {
                        stageHeight = stageTasks.length * 35;
                    }
                }
                
                // Если позиция не вычислена, используем значение по умолчанию
                if (actualTop === headerHeight && stageIndex > 0) {
                    // Для последующих этапов пытаемся вычислить позицию на основе предыдущих
                    const prevStageName = Object.keys(tasksByStageRecalc)[stageIndex - 1];
                    const prevStageLabel = currentStageLabelsContainer.querySelector(`.gantt-stage-label[data-stage-name="${prevStageName}"]`);
                    if (prevStageLabel) {
                        const prevTop = parseFloat(prevStageLabel.style.top) || 0;
                        const prevHeight = parseFloat(prevStageLabel.style.height) || 35;
                        actualTop = prevTop + prevHeight + 2;
                    }
                }
                
                // Обновляем позицию метки на основе реальной позиции
                stageLabel.style.top = Math.max(0, actualTop) + 'px';
                stageLabel.style.height = stageHeight + 'px';
                
                // Обновляем разделитель перед этапом (если есть) - используем реальную позицию метки
                if (stageIndex > 0) {
                    let divider = currentChartContainerParent.querySelector(`.gantt-stage-divider[data-stage-index="${stageIndex}"]`);
                    if (!divider) {
                        // Создаем разделитель, если его нет
                        divider = document.createElement('div');
                        divider.className = 'gantt-stage-divider';
                        divider.setAttribute('data-stage-index', stageIndex);
                        currentChartContainerParent.appendChild(divider);
                    }
                    // Используем позицию метки минус 2px для разделителя
                    divider.style.top = (actualTop - 2) + 'px';
                }
            });
            
            // Добавляем разделитель после последнего этапа, если он свернут
            const stageNames = Object.keys(tasksByStageRecalc);
            if (stageNames.length > 0) {
                const lastStageName = stageNames[stageNames.length - 1];
                const isLastStageCollapsed = collapsedStages.has(lastStageName);
                if (isLastStageCollapsed) {
                    // Вычисляем позицию разделителя после последнего этапа на основе реальной позиции метки
                    const lastStageLabel = currentStageLabelsContainer.querySelector(`.gantt-stage-label[data-stage-name="${lastStageName}"]`);
                    if (lastStageLabel) {
                        const lastTop = parseFloat(lastStageLabel.style.top) || 0;
                        const lastHeight = parseFloat(lastStageLabel.style.height) || 35;
                        const lastDividerTop = lastTop + lastHeight - 2;
                        
                        let lastDivider = currentChartContainerParent.querySelector('.gantt-stage-divider[data-stage-index="last"]');
                        if (!lastDivider) {
                            lastDivider = document.createElement('div');
                            lastDivider.className = 'gantt-stage-divider';
                            lastDivider.setAttribute('data-stage-index', 'last');
                            currentChartContainerParent.appendChild(lastDivider);
                        }
                        lastDivider.style.top = lastDividerTop + 'px';
                    }
                } else {
                    // Удаляем разделитель после последнего этапа, если он развернут
                    const lastDivider = currentChartContainerParent.querySelector('.gantt-stage-divider[data-stage-index="last"]');
                    if (lastDivider) {
                        lastDivider.remove();
                    }
                }
            }
        }

        // Отрисовка диаграммы Ганта
        function renderGantt() {
            const chartContainer = document.getElementById('ganttChart');
            if (!chartContainer) {
                console.error('❌ Элемент ganttChart не найден в DOM!');
                return;
            }
            chartContainer.innerHTML = '';

            if (!tasks.length) {
                console.warn('⚠️ Массив задач пустой, график не будет отрисован');
                return;
            }

            // Определение полного диапазона дат проекта
            const projectFirstDate = new Date(tasks[0].startDate);
            const realLastTaskDate = new Date(tasks[tasks.length - 1].endDate);

            // Правый край проекта:
            //  - в обычном режиме: до конца следующего года (серый "хвост")
            //  - в режиме экспорта: только до последней задачи
            let projectLastDate;
            if (isExporting) {
                projectLastDate = new Date(realLastTaskDate);
            } else {
                projectLastDate = new Date(realLastTaskDate);
                const calendarEnd = new Date(realLastTaskDate.getFullYear() + 1, 11, 31); // 31 декабря следующего года
                if (calendarEnd > projectLastDate) {
                    projectLastDate = calendarEnd;
                }
            }

            // Видимый диапазон: либо весь проект, либо выбранный пользователем месяц
            const firstDate = viewStartDate ? new Date(viewStartDate) : projectFirstDate;
            const lastDate = viewEndDate ? new Date(viewEndDate) : projectLastDate;

            // Базовая плотность: пикселей на день (увеличивается с зумом)
            const pxPerDay = 4 * zoomLevel;

            // Режим шкалы по фактической плотности:
            //  - дни: когда день крупный (≈7px и больше)
            //  - недели: средний масштаб (≈3–7px на день)
            //  - месяцы: когда дни очень плотные (<3px на день)
            let scaleMode;
            if (pxPerDay >= 7) {
                scaleMode = 'day';
            } else if (pxPerDay >= 3) {
                scaleMode = 'week';
            } else {
                scaleMode = 'month';
            }
            // Сохраняем текущий масштаб в глобальную переменную
            currentScaleMode = scaleMode;

            // Формируем единицы времени для основной шкалы
            const timelineUnits = [];

            if (scaleMode === 'day') {
                // Каждый день отдельно
                let currentDate = new Date(firstDate);
                while (currentDate <= lastDate) {
                    timelineUnits.push({
                        type: 'day',
                        start: new Date(currentDate),
                        end: new Date(currentDate),
                        label: String(currentDate.getDate())
                    });
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            } else if (scaleMode === 'week') {
                // Недельные интервалы по 7 дней, привязанные к понедельнику (календарные недели)
                let weekStart = new Date(firstDate);
                // Перематываем к ближайшему понедельнику назад
                while (weekStart.getDay() !== 1) { // 1 = понедельник
                    weekStart.setDate(weekStart.getDate() - 1);
                }

                while (weekStart <= lastDate) {
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekEnd.getDate() + 6); // понедельник–воскресенье

                    const labelFrom = weekStart.getDate();
                    const labelTo = weekEnd.getDate();
                    const monthNameShort = weekStart.toLocaleDateString('ru-RU', { month: 'short' });

                    // Для недель, где обе даты однозначные (например, 3–9),
                    // добавляем пробелы вокруг тире: "3 - 9".
                    // Для 6–12, 20–26 и т.п. формат остаётся "6-12", "20-26".
                    const rangeCompact = `${labelFrom}-${labelTo}`;
                    const rangeWithSpaces = `${labelFrom} - ${labelTo}`;
                    const daysLabel = (labelFrom < 10 && labelTo < 10) ? rangeWithSpaces : rangeCompact;

                    timelineUnits.push({
                        type: 'week',
                        start: new Date(weekStart),
                        end: new Date(weekEnd),
                        label: `${daysLabel} ${monthNameShort}`,
                        daysLabel,
                        monthLabel: monthNameShort
                    });

                    weekStart.setDate(weekStart.getDate() + 7);
                }
            } else {
                // По месяцам
                let current = new Date(firstDate.getFullYear(), firstDate.getMonth(), 1);
                while (current <= lastDate) {
                    const y = current.getFullYear();
                    const m = current.getMonth();
                    const monthStart = new Date(y, m, 1);
                    let monthEnd = new Date(y, m + 1, 0);
                    if (monthStart < firstDate) monthStart.setTime(firstDate.getTime());
                    if (monthEnd > lastDate) monthEnd.setTime(lastDate.getTime());

                    const monthName = current.toLocaleDateString('ru-RU', { month: 'long' });

                    timelineUnits.push({
                        type: 'month',
                        start: monthStart,
                        end: monthEnd,
                        label: `${monthName} ${y}`
                    });

                    current.setMonth(current.getMonth() + 1);
                }
            }

            const msInDay = 24 * 60 * 60 * 1000;

            // Заголовок с основной шкалой
            const header = document.createElement('div');
            header.className = 'gantt-header';

            // Обертка для первой строки (label + details header)
            const headerFirstRow = document.createElement('div');
            headerFirstRow.className = 'gantt-header-first-row';
            headerFirstRow.style.display = 'flex';

            const headerLabel = document.createElement('div');
            headerLabel.className = 'gantt-header-label';
            headerLabel.textContent = 'Задача';
            applyColumnWidth(headerLabel, 'label');
            addColumnResizer(headerLabel, 'label');
            headerFirstRow.appendChild(headerLabel);

            // Заголовки для дополнительных колонок: даты и рабочие дни
            const detailsHeader = document.createElement('div');
            detailsHeader.className = 'gantt-details-header';
            detailsHeader.innerHTML = `
                <div class="gantt-details-cell">Дата начала</div>
                <div class="gantt-details-cell">Дата окончания</div>
                <div class="gantt-details-cell">Рабочих дней</div>
                <div class="gantt-details-cell link-cell">Связь</div>
                <div class="gantt-details-cell responsible-cell">Ответственный</div>
            `;

            const headerCells = detailsHeader.querySelectorAll('.gantt-details-cell');
            if (headerCells[0]) {
                applyColumnWidth(headerCells[0], 'start');
                addColumnResizer(headerCells[0], 'start');
            }
            if (headerCells[1]) {
                applyColumnWidth(headerCells[1], 'end');
                addColumnResizer(headerCells[1], 'end');
            }
            if (headerCells[2]) {
                applyColumnWidth(headerCells[2], 'days');
            }
            if (headerCells[3]) {
                applyColumnWidth(headerCells[3], 'responsible');
            }

            headerFirstRow.appendChild(detailsHeader);
            header.appendChild(headerFirstRow);

            const datesRow = document.createElement('div');
            datesRow.className = 'gantt-header-dates-row';

            timelineUnits.forEach((unit, unitIdx) => {
                const cell = document.createElement('div');
                cell.className = 'gantt-header-cell';
                const unitDays = Math.round((unit.end - unit.start) / msInDay) + 1;
                const width = Math.max(30, unitDays * pxPerDay);
                cell.style.minWidth = width + 'px';
                cell.style.width = width + 'px';

                // Отрисовка подписи шкалы
                if (scaleMode === 'week' && unit.type === 'week' && unit.daysLabel && unit.monthLabel) {
                    const daysSpan = document.createElement('span');
                    daysSpan.className = 'gantt-header-week-days';
                    daysSpan.textContent = unit.daysLabel;

                    const monthSpan = document.createElement('span');
                    monthSpan.className = 'gantt-header-week-month';
                    monthSpan.textContent = unit.monthLabel;

                    cell.appendChild(daysSpan);
                    cell.appendChild(monthSpan);
                } else {
                    cell.textContent = unit.label;
                }

                const isFutureUnit = unit.start > realLastTaskDate;

                if (scaleMode === 'day') {
                    // Подсветка выходных и праздников только в дневном режиме
                    cell.title = unit.start.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    if (!isWorkday(unit.start)) {
                        const key = formatDateKey(unit.start);
                        cell.classList.add(holidays.includes(key) ? 'gantt-holiday' : 'gantt-weekend');
                    }
                } else if (scaleMode === 'week') {
                    const fromStr = unit.start.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    const toStr = unit.end.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    cell.title = `${fromStr} — ${toStr}`;
                } else {
                    const fromStr = unit.start.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    const toStr = unit.end.toLocaleDateString('ru-RU', { year: 'numeric', month: 'long', day: 'numeric' });
                    cell.title = `${fromStr} — ${toStr}`;
                }

                if (isFutureUnit) {
                    cell.classList.add('gantt-future-header');
                }

                // Клик по месяцу в режиме месяцев: зум до выбранного месяца
                if (scaleMode === 'month' && unit.type === 'month') {
                    cell.style.cursor = 'pointer';
                    cell.addEventListener('click', () => {
                        // показываем только выбранный месяц целиком
                        viewStartDate = new Date(unit.start.getFullYear(), unit.start.getMonth(), 1);
                        viewEndDate = new Date(unit.start.getFullYear(), unit.start.getMonth() + 1, 0);
                        // увеличиваем масштаб до дневного уровня
                        setZoom(2); // max зум → точно режим дней
                    });
                }

                datesRow.appendChild(cell);
            });

            header.appendChild(datesRow);

            chartContainer.appendChild(header);

            // Группируем задачи по этапам
            const tasksByStage = {};
            tasks.forEach((task, index) => {
                const stage = task.stage || 'Без этапа';
                if (!tasksByStage[stage]) {
                    tasksByStage[stage] = [];
                }
                tasksByStage[stage].push({ task, index });
            });

            // Получаем родительский контейнер
            const chartContainerParent = chartContainer.closest('.chart-container');
            
            // Удаляем старый контейнер меток и все разделители перед созданием новых
            if (chartContainerParent) {
                const oldLabelsContainer = chartContainerParent.querySelector('.gantt-stage-labels');
                if (oldLabelsContainer) {
                    oldLabelsContainer.remove();
                }
                // Удаляем все старые разделители
                const oldDividers = chartContainerParent.querySelectorAll('.gantt-stage-divider');
                oldDividers.forEach(divider => divider.remove());
            } else {
                // Fallback: если не найден .chart-container, ищем в chartContainer
                const oldLabelsContainer = chartContainer.querySelector('.gantt-stage-labels');
                if (oldLabelsContainer) {
                    oldLabelsContainer.remove();
                }
            }

            // Удаляем старый контейнер кнопок управления, если есть
            if (chartContainerParent) {
                const oldControlsContainer = chartContainerParent.querySelector('.gantt-stage-controls');
                if (oldControlsContainer) {
                    oldControlsContainer.remove();
                }
            }
            
            // Создаем новый контейнер для меток этапов
            const stageLabelsContainer = document.createElement('div');
            stageLabelsContainer.className = 'gantt-stage-labels';
            // Добавляем метки в .chart-container, чтобы они позиционировались относительно него
            if (chartContainerParent) {
                chartContainerParent.appendChild(stageLabelsContainer);
                
                // Создаем контейнер для кнопок управления (над метками этапов)
                const controlsContainer = document.createElement('div');
                controlsContainer.className = 'gantt-stage-controls';
                
                // Кнопка "+" для сворачивания всех этапов
                const collapseBtn = document.createElement('button');
                collapseBtn.className = 'gantt-stage-control-btn';
                collapseBtn.textContent = '+';
                collapseBtn.title = 'Свернуть все этапы';
                collapseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    collapseAllStages();
                });
                
                // Кнопка "-" для разворачивания всех этапов
                const expandBtn = document.createElement('button');
                expandBtn.className = 'gantt-stage-control-btn';
                expandBtn.textContent = '−';
                expandBtn.title = 'Развернуть все этапы';
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    expandAllStages();
                });
                
                controlsContainer.appendChild(collapseBtn);
                controlsContainer.appendChild(expandBtn);
                chartContainerParent.appendChild(controlsContainer);
            } else {
                // Fallback: если не найден .chart-container, добавляем в chartContainer
                chartContainer.appendChild(stageLabelsContainer);
            }

            const rowHeight = 35; // Высота одной строки задачи (min-height из CSS)

            // Отрисовываем задачи по этапам (синхронно)
            Object.keys(tasksByStage).forEach((stageName, stageIndex) => {
                const stageTasks = tasksByStage[stageName];
                const isStageCollapsed = collapsedStages.has(stageName);

                // Если этап свернут, создаем строку этапа вместо всех задач
                if (isStageCollapsed) {
                    const stageRow = createStageRow(stageName, stageTasks, stageIndex);
                    chartContainer.appendChild(stageRow);
                    return; // Пропускаем отрисовку задач этапа
                }

                // Отрисовываем все задачи этого этапа
                stageTasks.forEach(({ task, index }) => {
                const row = document.createElement('div');
                row.className = 'gantt-row';
                row.dataset.taskId = String(task.id);
                
                // Если этап свернут, скрываем строки задач
                if (isStageCollapsed) {
                    row.classList.add('stage-collapsed');
                }

                // Статус строки относительно выбранного этапа
                if (currentStageFilter !== 'all') {
                    if (isTaskInCurrentStage(task)) {
                        row.classList.add('stage-active');
                    } else {
                        row.classList.add('inactive');
                    }
                }

                // Drag & drop поведение
                row.draggable = true;
                row.addEventListener('dragstart', (e) => {
                    // Не начинаем drag, если клик был на label или input для редактирования
                    const target = e.target;
                    if (target && (
                        target.closest('.gantt-label') || 
                        target.classList.contains('gantt-task-input') ||
                        target.closest('input.gantt-task-input')
                    )) {
                        e.preventDefault();
                        return;
                    }
                    
                    draggingTaskId = task.id;
                    row.classList.add('dragging');
                    if (e.dataTransfer) {
                        e.dataTransfer.effectAllowed = 'move';
                    }
                });

                row.addEventListener('dragend', () => {
                    draggingTaskId = null;
                    row.classList.remove('dragging');
                    document.querySelectorAll('.gantt-row-drop-target').forEach(el => el.classList.remove('gantt-row-drop-target'));
                });

                const label = document.createElement('div');
                label.className = 'gantt-label';
                applyColumnWidth(label, 'label');
                renderTaskLabelContent(label, task, index);
                
                // Предотвращаем начало drag при клике на label (после создания label)
                // НЕ останавливаем всплытие, чтобы строка могла выделиться при клике
                label.addEventListener('mousedown', (e) => {
                    // Если это не input для редактирования, предотвращаем drag, но не блокируем клик
                    if (!e.target.classList.contains('gantt-task-input') && 
                        !e.target.closest('input.gantt-task-input')) {
                        // Только предотвращаем drag, но не останавливаем всплытие события
                    }
                });
                
                row.appendChild(label);

                // Дополнительные колонки "Дата начала / Дата окончания / Рабочих дней"
                const detailsRow = document.createElement('div');
                detailsRow.className = 'gantt-details-row';

                const startCell = document.createElement('div');
                startCell.className = 'gantt-details-cell';
                const startInput = document.createElement('input');
                startInput.type = 'date';
                startInput.className = 'gantt-details-input';
                startInput.value = task.startDate ? formatDateForInput(task.startDate) : '';
                startInput.setAttribute('data-index', index);
                startInput.setAttribute('data-field', 'startDate');
                // Блокируем поле в режиме просмотра
                if (isViewMode) {
                    startInput.setAttribute('readonly', 'readonly');
                } else {
                    startInput.addEventListener('change', onTaskTableInputChange);
                }
                startCell.appendChild(startInput);
                applyColumnWidth(startCell, 'start');

                const endCell = document.createElement('div');
                endCell.className = 'gantt-details-cell';
                const endInput = document.createElement('input');
                endInput.type = 'date';
                endInput.className = 'gantt-details-input';
                endInput.value = task.endDate ? formatDateForInput(task.endDate) : '';
                endInput.setAttribute('data-index', index);
                endInput.setAttribute('data-field', 'endDate');
                // Блокируем поле в режиме просмотра
                if (isViewMode) {
                    endInput.setAttribute('readonly', 'readonly');
                } else {
                    endInput.addEventListener('change', onTaskTableInputChange);
                }
                endCell.appendChild(endInput);
                applyColumnWidth(endCell, 'end');

                const daysCell = document.createElement('div');
                daysCell.className = 'gantt-details-cell';
                const daysInput = document.createElement('input');
                daysInput.type = 'number';
                daysInput.min = '0';
                daysInput.className = 'gantt-details-input';
                daysInput.value = task.days;
                daysInput.setAttribute('data-index', index);
                daysInput.setAttribute('data-field', 'days');
                // Блокируем поле в режиме просмотра
                if (isViewMode) {
                    daysInput.setAttribute('readonly', 'readonly');
                } else {
                    daysInput.addEventListener('change', onTaskTableInputChange);
                }
                daysCell.appendChild(daysInput);
                applyColumnWidth(daysCell, 'days');

                detailsRow.appendChild(startCell);
                detailsRow.appendChild(endCell);
                detailsRow.appendChild(daysCell);

                // Ячейка "Связь" всегда создается для анимации
                const linkCell = document.createElement('div');
                linkCell.className = 'gantt-details-cell link-cell';
                const linkSelect = document.createElement('select');
                linkSelect.className = 'gantt-details-input link-select';
                linkSelect.setAttribute('data-index', index);
                linkSelect.setAttribute('data-field', 'link');
                
                // Опции для выпадающего списка (без пустого значения)
                const options = [
                    { value: 'О_Н', text: 'О_Н', tooltip: 'окончание - начало' },
                    { value: 'Н_Н', text: 'Н_Н', tooltip: 'начало - начало' },
                    { value: 'О_О', text: 'О_О', tooltip: 'окончание - окончание' }
                ];
                
                // Устанавливаем значение связи (по умолчанию О_Н, кроме первой задачи)
                const linkValue = index === 0 ? 'О_Н' : (task.link || 'О_Н');
                if (index === 0) {
                    task.link = 'О_Н'; // Первая задача тоже имеет связь, но она не используется
                } else if (!task.link) {
                    task.link = 'О_Н';
                }
                
                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value;
                    option.textContent = opt.text;
                    if (opt.value === linkValue) {
                        option.selected = true;
                    }
                    linkSelect.appendChild(option);
                });
                
                // Устанавливаем подсказку в зависимости от выбранного значения
                function updateLinkTooltip() {
                    const selectedValue = linkSelect.value;
                    const selectedOption = options.find(opt => opt.value === selectedValue);
                    if (selectedOption && selectedOption.tooltip) {
                        linkSelect.setAttribute('data-tooltip', selectedOption.tooltip);
                    } else {
                        linkSelect.removeAttribute('data-tooltip');
                    }
                }
                updateLinkTooltip();
                
                // Устанавливаем дефолтное значение О_Н для всех задач
                if (!task.link) {
                    task.link = 'О_Н';
                    linkSelect.value = 'О_Н';
                    updateLinkTooltip();
                }
                
                // Блокируем поле в режиме просмотра или для первой задачи
                if (isViewMode || index === 0) {
                    linkSelect.setAttribute('disabled', 'disabled');
                } else {
                    linkSelect.addEventListener('change', function(event) {
                        updateLinkTooltip();
                        // Создаем синтетический event, если его нет
                        if (!event || !event.target) {
                            event = { target: this };
                        }
                        onTaskTableInputChange(event);
                    });
                }
                linkCell.appendChild(linkSelect);
                applyColumnWidth(linkCell, 'link');
                detailsRow.appendChild(linkCell);

                // Ячейка "Ответственный" всегда создается для анимации
                const respCell = document.createElement('div');
                respCell.className = 'gantt-details-cell responsible-cell';
                if (task.responsible) {
                    respCell.setAttribute('data-tooltip', task.responsible);
                }
                const respInput = document.createElement('input');
                respInput.type = 'text';
                respInput.className = 'gantt-details-input';
                respInput.value = task.responsible || '';
                respInput.setAttribute('data-index', index);
                respInput.setAttribute('data-field', 'responsible');
                respInput.addEventListener('change', onTaskTableInputChange);
                respCell.appendChild(respInput);
                applyColumnWidth(respCell, 'responsible');
                detailsRow.appendChild(respCell);
                row.appendChild(detailsRow);

            timelineUnits.forEach((unit, unitIdx) => {
                    const cell = document.createElement('div');
                    cell.className = 'gantt-cell';
                    const unitDays = Math.round((unit.end - unit.start) / msInDay) + 1;
                    const width = Math.max(30, unitDays * pxPerDay);
                    cell.style.minWidth = width + 'px';
                    cell.style.width = width + 'px';

                    const isFutureUnit = unit.start > realLastTaskDate;

                    // Проверяем, есть ли у задачи рабочие дни внутри текущей единицы времени
                    const unitDatesForTask = task.dates.filter(d => {
                        const time = d.getTime();
                        return time >= unit.start.getTime() && time <= unit.end.getTime();
                    });

                    // Также проверяем, есть ли в интервале дни со статусом "weekend-manual"
                    // (которые могут быть не в task.dates, так как они исключены из рабочих дней)
                    let hasWeekendManualInUnit = false;
                    let weekendManualDate = null;
                    if (task.dateStatuses) {
                        const unitStartTime = unit.start.getTime();
                        const unitEndTime = unit.end.getTime();
                        // Проверяем все даты в интервале
                        let checkDate = new Date(unit.start);
                        while (checkDate.getTime() <= unitEndTime) {
                            const dateKey = formatDateKey(checkDate);
                            if (task.dateStatuses[dateKey] === 'weekend-manual') {
                                hasWeekendManualInUnit = true;
                                weekendManualDate = new Date(checkDate);
                                break;
                            }
                            checkDate.setDate(checkDate.getDate() + 1);
                        }
                    }

                    const hasWorkInUnit = unitDatesForTask.length > 0 || hasWeekendManualInUnit;

                    if (hasWorkInUnit) {
                        // ВАЖНО: Каждая ячейка обрабатывается отдельно
                        // Статус применяется только к конкретному дню в ячейке, а не ко всей задаче
                        // Это позволяет краситься только выбранной ячейке, а не всей строке
                        // В режиме "точек" покраска по отдельным дням
                        // В режиме "полос" рисуем более широкие сегменты, но статус все равно применяется к отдельным дням

                        // Определяем представительную дату и её статус
                        let representativeDate;
                        let repDateStr;
                        let statusForDate;
                        
                        if (hasWeekendManualInUnit && weekendManualDate) {
                            // Если есть выходной день в интервале, используем его
                            representativeDate = weekendManualDate;
                            repDateStr = formatDateKey(representativeDate);
                            statusForDate = 'weekend-manual';
                        } else if (unitDatesForTask.length > 0) {
                            // Иначе используем первый рабочий день
                            representativeDate = unitDatesForTask[0];
                            repDateStr = formatDateKey(representativeDate);
                            statusForDate = task.dateStatuses[repDateStr] || 'pending';
                        } else {
                            // Fallback (не должно произойти, но на всякий случай)
                            representativeDate = unit.start;
                            repDateStr = formatDateKey(representativeDate);
                            statusForDate = 'pending';
                        }

                        const bar = document.createElement('div');

                        // Подбираем класс оформления бара в зависимости от статуса
                        let barClasses = 'gantt-bar';
                        if (statusForDate === 'completed') {
                            barClasses += ' completed';
                        } else if (statusForDate === 'in-progress') {
                            barClasses += ' in-progress';
                        } else if (statusForDate === 'weekend-manual') {
                            barClasses += ' gantt-weekend';
                        }
                        bar.className = barClasses;

                        // Если для этой даты есть комментарий, добавляем data-tooltip,
                        // чтобы при наведении отображалась подсказка с чёрным фоном.
                        if (task.dateComments && task.dateComments[repDateStr]) {
                            const formattedComment = formatCommentForTooltip(task.dateComments[repDateStr]);
                            bar.setAttribute('data-tooltip', formattedComment);
                        }

                        // В режиме полос убираем символ и управляем скруглением/границами
                        if (ganttBarStyle === 'segments') {
                            bar.textContent = '';

                            // Определяем, есть ли дни задачи в соседних единицах времени,
                            // чтобы понять, начало это, середина или конец непрерывного отрезка.
                            // Учитываем как рабочие дни, так и выходные дни
                            const hasPrev = unitIdx > 0 && (
                                task.dates.some(d => {
                                    const t = d.getTime();
                                    const prev = timelineUnits[unitIdx - 1];
                                    return t >= prev.start.getTime() && t <= prev.end.getTime();
                                }) ||
                                (task.dateStatuses && Object.keys(task.dateStatuses).some(dateKey => {
                                    if (task.dateStatuses[dateKey] === 'weekend-manual') {
                                        const date = parseDateFromInput(dateKey);
                                        if (date) {
                                            const t = date.getTime();
                                            const prev = timelineUnits[unitIdx - 1];
                                            return t >= prev.start.getTime() && t <= prev.end.getTime();
                                        }
                                    }
                                    return false;
                                }))
                            );
                            const hasNext = unitIdx < timelineUnits.length - 1 && (
                                task.dates.some(d => {
                                    const t = d.getTime();
                                    const next = timelineUnits[unitIdx + 1];
                                    return t >= next.start.getTime() && t <= next.end.getTime();
                                }) ||
                                (task.dateStatuses && Object.keys(task.dateStatuses).some(dateKey => {
                                    if (task.dateStatuses[dateKey] === 'weekend-manual') {
                                        const date = parseDateFromInput(dateKey);
                                        if (date) {
                                            const t = date.getTime();
                                            const next = timelineUnits[unitIdx + 1];
                                            return t >= next.start.getTime() && t <= next.end.getTime();
                                        }
                                    }
                                    return false;
                                }))
                            );

                            if (hasPrev && hasNext) {
                                bar.classList.add('segment-middle');
                            } else if (!hasPrev && hasNext) {
                                bar.classList.add('segment-start');
                            } else if (hasPrev && !hasNext) {
                                bar.classList.add('segment-end');
                            } else if (!hasPrev && !hasNext) {
                                // Одиночный сегмент — задача умещается в одну единицу времени,
                                // поэтому скругляем оба края.
                                bar.classList.add('segment-single');
                            }
                        } else {
                            bar.textContent = '■';
                        }

                        // Стандартный title отключаем, чтобы по наведению
                        // показывалась только чёрная подсказка-комментарий.
                        bar.title = '';

                        bar.style.cursor = 'pointer';
                        
                        // Функция для обработки клика/тапа
                        function handleBarClick(event, clientX, clientY) {
                            event.stopPropagation();
                            handleTaskRowClick(task.id, event);

                            if (!canEdit()) {
                                return; // Блокируем изменение статуса в режиме просмотра
                            }

                            const barElement = event.currentTarget || event.target;
                            const rect = barElement ? barElement.getBoundingClientRect() : null;
                            const fallbackX = rect ? rect.left + rect.width / 2 : window.innerWidth / 2;
                            const fallbackY = rect ? rect.top + rect.height / 2 : window.innerHeight / 2;
                            const clickX = typeof clientX === 'number' ? clientX : fallbackX;
                            const clickY = typeof clientY === 'number' ? clientY : fallbackY;

                            // Определяем, какие даты выбраны
                            // ВАЖНО: В детальном режиме каждая ячейка должна обрабатываться отдельно
                            // Статус применяется только к конкретному дню, на который кликнули
                            let selectedDates = [];
                            
                            // В детальном режиме всегда берем только одну конкретную дату из ячейки
                            // Это позволяет краситься только выбранной ячейке, а не всей строке
                            if (unitDatesForTask.length > 0) {
                                // Берем только первую дату из интервала (минимальную дату)
                                // В детальном режиме каждая ячейка представляет один день
                                const firstDate = unitDatesForTask[0];
                                selectedDates = [formatDateKey(firstDate)];
                            } else if (hasWeekendManualInUnit && weekendManualDate) {
                                // Если в интервале есть выходной день, используем его
                                selectedDates = [formatDateKey(weekendManualDate)];
                            } else {
                                // Если нет дат в интервале, используем дату начала интервала
                                selectedDates = [formatDateKey(unit.start)];
                            }
                            
                            // В режиме полос также применяем статус только к одной дате из ячейки
                            // (не ко всем датам задачи), чтобы каждая ячейка красилась отдельно

                            // Если зажат Ctrl/Cmd - добавляем/убираем из множественного выбора
                            if (isCtrlPressed || event.ctrlKey || event.metaKey) {
                                event.preventDefault();
                                
                                // Переключаем выделение для всех дат в выбранном интервале
                                let hasSelected = false;
                                selectedDates.forEach(dateStr => {
                                    const cellKey = `${task.id}:${dateStr}`;
                                    if (selectedCells.has(cellKey)) {
                                        selectedCells.delete(cellKey);
                                        hasSelected = false;
                                    } else {
                                        selectedCells.add(cellKey);
                                        hasSelected = true;
                                    }
                                });
                                
                                // Обновляем визуальное выделение
                                updateCellSelection();
                                
                                // Если есть выбранные ячейки, открываем меню
                                if (selectedCells.size > 0) {
                                    openStatusMenuForMultipleSelection(clickX, clickY);
                                } else {
                                    closeStatusMenu();
                                }
                            } else {
                                // Обычный клик - сбрасываем множественный выбор и открываем меню для одной ячейки
                                if (selectedCells.size > 0) {
                                    selectedCells.clear();
                                    updateCellSelection();
                                }
                                
                                // Передаем barElement для точного позиционирования меню рядом с ячейкой
                                openStatusMenu(clickX, clickY, task.id, selectedDates, barElement);
                            }
                        }
                        
                        // Обработчик клика (для десктопа)
                        bar.addEventListener('click', (event) => {
                            handleBarClick(event, event.clientX, event.clientY);
                        });
                        
                        // Обработчик touch (для мобильных)
                        bar.addEventListener('touchend', (event) => {
                            event.preventDefault();
                            const touch = event.changedTouches[0];
                            if (touch) {
                                handleBarClick(event, touch.clientX, touch.clientY);
                            }
                        });

                        cell.appendChild(bar);
                    }

                    // Отрисовка жёлтой полосы директивного плана (baseline) под текущим баром/ячейкой.
                    // ВАЖНО: baseline рисуем независимо от того, есть ли сейчас работа в этом интервале,
                    // чтобы было видно исходный план даже после сдвигов задач.
                    if (showBaseline && Array.isArray(task.baselineDates) && task.baselineDates.length) {
                        const unitStartTime = unit.start.getTime();
                        const unitEndTime = unit.end.getTime();
                        const hasBaselineInUnit = task.baselineDates.some(d => {
                            const t = d.getTime();
                            return t >= unitStartTime && t <= unitEndTime;
                        });

                        if (hasBaselineInUnit) {
                            const baselineBar = document.createElement('div');
                            baselineBar.className = 'baseline-bar';
                            cell.appendChild(baselineBar);
                        }
                    }

                    if (isFutureUnit) {
                        cell.classList.add('gantt-future-cell');
                    }

                    row.appendChild(cell);
                });

                // Обработка drag-over / drop для изменения порядка задач
                row.addEventListener('dragover', (e) => {
                    if (draggingTaskId === null || draggingTaskId === task.id) return;
                    e.preventDefault();
                    row.classList.add('gantt-row-drop-target');
                });

                row.addEventListener('dragleave', () => {
                    row.classList.remove('gantt-row-drop-target');
                });

                row.addEventListener('drop', (e) => {
                    if (!canEdit()) {
                        e.preventDefault();
                        return;
                    }
                    if (draggingTaskId === null || draggingTaskId === task.id) return;
                    e.preventDefault();
                    row.classList.remove('gantt-row-drop-target');

                    const fromIndex = tasks.findIndex(t => t.id === draggingTaskId);
                    const targetId = task.id;
                    if (fromIndex === -1) return;

                    // Сохраняем состояние в историю перед перетаскиванием
                    addToUndoHistory();

                    console.log('🔄 DRAG&DROP: Начало перетаскивания задачи');
                    console.log('   Перетаскиваемая задача ID:', draggingTaskId);
                    console.log('   Старый индекс:', fromIndex);
                    
                    // Сохраняем данные ДО перемещения для отладки
                    const movedTaskBefore = tasks[fromIndex];
                    console.log('   📋 ДО перемещения - задача:', movedTaskBefore.task || movedTaskBefore.name);
                    console.log('   📋 ДО перемещения - даты:', movedTaskBefore.dates?.map(d => formatDateKey(d)));
                    console.log('   📋 ДО перемещения - статусы дат:', movedTaskBefore.dateStatuses);
                    console.log('   📋 ДО перемещения - комментарии:', movedTaskBefore.dateComments);
                    console.log('   📋 ДО перемещения - общий статус:', movedTaskBefore.status);

                    const [moved] = tasks.splice(fromIndex, 1);
                    const targetIndex = tasks.findIndex(t => t.id === targetId);
                    let newIndex;
                    if (targetIndex === -1) {
                        // если не нашли, кладём в конец
                        tasks.push(moved);
                        newIndex = tasks.length - 1;
                    } else {
                        tasks.splice(targetIndex, 0, moved);
                        newIndex = targetIndex;
                    }

                    console.log('   Новый индекс:', newIndex);
                    console.log('   📋 ПОСЛЕ перемещения (до пересчета) - статусы дат:', moved.dateStatuses);
                    console.log('   📋 ПОСЛЕ перемещения (до пересчета) - комментарии:', moved.dateComments);

                    // Определяем, с какого места нужно пересчитать даты:
                    // берём минимальный индекс между старой и новой позицией
                    // и пересчитываем цепочку, начиная с этой задачи включительно
                    const startIndex = Math.min(fromIndex, newIndex);
                    console.log('   🔢 Начинаем пересчет с индекса:', startIndex);
                    recalculateDatesFrom(startIndex);

                    console.log('   📋 ПОСЛЕ пересчета - статусы дат:', moved.dateStatuses);
                    console.log('   📋 ПОСЛЕ пересчета - комментарии:', moved.dateComments);
                    console.log('   📋 ПОСЛЕ пересчета - новые даты:', moved.dates?.map(d => formatDateKey(d)));

                    draggingTaskId = null;
                    updateStatistics();
                    renderGantt();
                    renderTable();
                });

                // Клик по строке Ганта — выбираем задачу (поддержка Shift)
                row.addEventListener('click', (event) => {
                    handleTaskRowClick(task.id, event);
                });

                chartContainer.appendChild(row);
                });

            });

            // Функция для управления видимостью вертикального скролла
            function updateVerticalScrollVisibility() {
                const chartContainerElement = document.querySelector('.chart-container');
                if (!chartContainerElement) return;
                
                // Получаем все этапы из задач
                const allStages = new Set();
                tasks.forEach(task => {
                    const stage = task.stage || 'Без этапа';
                    allStages.add(stage);
                });
                
                // Проверяем, все ли этапы свернуты
                const allStagesCollapsed = allStages.size > 0 && allStages.size === collapsedStages.size && 
                    Array.from(allStages).every(stageName => collapsedStages.has(stageName));
                
                // Если все этапы свернуты - скрываем вертикальный скролл
                if (allStagesCollapsed) {
                    chartContainerElement.style.overflowY = 'hidden';
                } else {
                    // Если хотя бы один этап развернут - показываем вертикальный скролл
                    chartContainerElement.style.overflowY = 'auto';
                }
            }

            // Функция для сворачивания/разворачивания этапа
            function toggleStageCollapse(stageName) {
                const isCollapsed = collapsedStages.has(stageName);
                
                if (isCollapsed) {
                    // Сохраняем текущую позицию прокрутки перед разворачиванием
                    const scrollY = window.scrollY || window.pageYOffset;
                    const scrollX = window.scrollX || window.pageXOffset;
                    
                    // Также сохраняем прокрутку контейнера диаграммы
                    const currentChartContainer = document.getElementById('ganttChart');
                    const chartScrollTop = currentChartContainer ? currentChartContainer.scrollTop : 0;
                    const chartScrollLeft = currentChartContainer ? currentChartContainer.scrollLeft : 0;
                    
                    // Разворачиваем этап: удаляем из списка свернутых и перерисовываем график
                    collapsedStages.delete(stageName);
                    
                    // Полностью перерисовываем график и таблицу для корректного отображения всех задач
                    renderGantt();
                    renderTable();
                    
                    // Восстанавливаем позицию прокрутки сразу после перерисовки
                    requestAnimationFrame(() => {
                        window.scrollTo(scrollX, scrollY);
                        const newChartContainer = document.getElementById('ganttChart');
                        if (newChartContainer) {
                            newChartContainer.scrollTop = chartScrollTop;
                            newChartContainer.scrollLeft = chartScrollLeft;
                        }
                    });
                    
                    // Показываем метку этапа и обновляем позиции после перерисовки
                    setTimeout(() => {
                        // Восстанавливаем позицию прокрутки еще раз
                        requestAnimationFrame(() => {
                            window.scrollTo(scrollX, scrollY);
                            const newChartContainer = document.getElementById('ganttChart');
                            if (newChartContainer) {
                                newChartContainer.scrollTop = chartScrollTop;
                                newChartContainer.scrollLeft = chartScrollLeft;
                            }
                        });
                        
                        // Показываем метку этапа напрямую
                        const stageLabel = document.querySelector(`.gantt-stage-label[data-stage-name="${stageName}"]`);
                        if (stageLabel) {
                            stageLabel.style.display = '';
                            stageLabel.classList.remove('collapsed');
                        }
                        
                        // Обновляем метку этапа через функцию
                        updateStageLabel(stageName, false);
                        
                        // Пересчитываем позиции всех меток этапов после анимации
                        recalculateStageLabelsPositions();
                        // Обновляем видимость вертикального скролла
                        updateVerticalScrollVisibility();
                        
                        // Финальное восстановление позиции прокрутки после всех обновлений
                        setTimeout(() => {
                            requestAnimationFrame(() => {
                                window.scrollTo(scrollX, scrollY);
                                const newChartContainer = document.getElementById('ganttChart');
                                if (newChartContainer) {
                                    newChartContainer.scrollTop = chartScrollTop;
                                    newChartContainer.scrollLeft = chartScrollLeft;
                                }
                            });
                        }, 100);
                    }, 150);
                } else {
                    // Сворачиваем этап
                    collapsedStages.add(stageName);
                    
                    // Обновляем видимость задач этапа
                    updateStageTasksVisibility(stageName, true);
                    
                    // Обновляем метку этапа
                    updateStageLabel(stageName, true);
                    
                    // Пересчитываем позиции всех меток этапов после анимации
                    setTimeout(() => {
                        // Используем функцию пересчета позиций
                        recalculateStageLabelsPositions();
                        // Обновляем видимость вертикального скролла
                        updateVerticalScrollVisibility();
                    }, 350); // После завершения анимации скрытия/показа строк
                }
            }

            // Функция для сворачивания всех этапов
            function collapseAllStages() {
                const chartContainer = document.getElementById('ganttChart');
                if (!chartContainer) return;
                
                // Получаем все этапы из задач
                const allStages = new Set();
                tasks.forEach(task => {
                    const stage = task.stage || 'Без этапа';
                    allStages.add(stage);
                });
                
                // Сворачиваем все этапы
                allStages.forEach(stageName => {
                    if (!collapsedStages.has(stageName)) {
                        collapsedStages.add(stageName);
                    }
                });
                
                // Перерисовываем график
                renderGantt();
                
                // Скрываем все вертикальные метки этапов после перерисовки
                setTimeout(() => {
                    // Скрываем все метки этапов напрямую через селектор
                    const allStageLabels = document.querySelectorAll('.gantt-stage-label');
                    allStageLabels.forEach(label => {
                        label.style.display = 'none';
                    });
                    
                    // Также вызываем updateStageLabel для каждого этапа (на случай, если нужна дополнительная логика)
                    allStages.forEach(stageName => {
                        updateStageLabel(stageName, true);
                    });
                    // Обновляем видимость вертикального скролла
                    updateVerticalScrollVisibility();
                }, 150);
            }

            // Функция для разворачивания всех этапов
            function expandAllStages() {
                // Получаем все этапы из задач
                const allStages = new Set();
                tasks.forEach(task => {
                    const stage = task.stage || 'Без этапа';
                    allStages.add(stage);
                });
                
                // Разворачиваем все этапы
                collapsedStages.clear();
                
                // Перерисовываем график
                renderGantt();
                
                // Показываем все вертикальные метки этапов после перерисовки
                setTimeout(() => {
                    // Показываем все метки этапов напрямую через селектор
                    const allStageLabels = document.querySelectorAll('.gantt-stage-label');
                    allStageLabels.forEach(label => {
                        label.style.display = '';
                    });
                    
                    // Также вызываем updateStageLabel для каждого этапа
                    allStages.forEach(stageName => {
                        updateStageLabel(stageName, false);
                    });
                    // Обновляем видимость вертикального скролла
                    updateVerticalScrollVisibility();
                }, 150);
            }

            // Функция для вычисления данных этапа (даты начала, окончания, рабочих дней)
            function calculateStageData(stageTasks) {
                if (!stageTasks || stageTasks.length === 0) {
                    return { startDate: null, endDate: null, workdays: 0 };
                }
                
                // Находим минимальную дату начала и максимальную дату окончания
                let minStartDate = null;
                let maxEndDate = null;
                
                stageTasks.forEach(({ task }) => {
                    if (task.startDate) {
                        const startDate = task.startDate instanceof Date ? task.startDate : new Date(task.startDate);
                        if (!minStartDate || startDate < minStartDate) {
                            minStartDate = startDate;
                        }
                    }
                    if (task.endDate) {
                        const endDate = task.endDate instanceof Date ? task.endDate : new Date(task.endDate);
                        if (!maxEndDate || endDate > maxEndDate) {
                            maxEndDate = endDate;
                        }
                    }
                });
                
                // Вычисляем количество рабочих дней между датами
                let workdays = 0;
                if (minStartDate && maxEndDate) {
                    const workdaysArray = getWorkdaysBetween(minStartDate, maxEndDate);
                    workdays = workdaysArray.length;
                }
                
                return { startDate: minStartDate, endDate: maxEndDate, workdays };
            }

            // Функция для создания строки этапа (свернутое состояние)
            function createStageRow(stageName, stageTasks, stageIndex) {
                const stageData = calculateStageData(stageTasks);
                const stageMatch = stageName.match(/^(Этап\s+\d+)/);
                const stageNumber = stageMatch ? stageMatch[1] : stageName;
                
                const row = document.createElement('div');
                row.className = 'gantt-row stage-row-collapsed';
                row.dataset.stageName = stageName;
                row.dataset.isStageRow = 'true';
                
                // Не делаем строку этапа draggable
                row.draggable = false;
                
                // Label с названием этапа
                const label = document.createElement('div');
                label.className = 'gantt-label';
                applyColumnWidth(label, 'label');
                const labelSpan = document.createElement('span');
                labelSpan.textContent = stageNumber;
                labelSpan.style.fontWeight = '600';
                labelSpan.style.color = 'var(--color-primary)';
                label.appendChild(labelSpan);
                row.appendChild(label);
                
                // Дополнительные колонки "Дата начала / Дата окончания / Рабочих дней"
                const detailsRow = document.createElement('div');
                detailsRow.className = 'gantt-details-row';
                
                // Дата начала
                const startCell = document.createElement('div');
                startCell.className = 'gantt-details-cell';
                const startInput = document.createElement('input');
                startInput.type = 'date';
                startInput.className = 'gantt-details-input';
                startInput.value = stageData.startDate ? formatDateForInput(stageData.startDate) : '';
                startInput.setAttribute('readonly', 'readonly');
                startInput.setAttribute('disabled', 'disabled');
                startCell.appendChild(startInput);
                applyColumnWidth(startCell, 'start');
                
                // Дата окончания
                const endCell = document.createElement('div');
                endCell.className = 'gantt-details-cell';
                const endInput = document.createElement('input');
                endInput.type = 'date';
                endInput.className = 'gantt-details-input';
                endInput.value = stageData.endDate ? formatDateForInput(stageData.endDate) : '';
                endInput.setAttribute('readonly', 'readonly');
                endInput.setAttribute('disabled', 'disabled');
                endCell.appendChild(endInput);
                applyColumnWidth(endCell, 'end');
                
                // Рабочих дней
                const daysCell = document.createElement('div');
                daysCell.className = 'gantt-details-cell';
                const daysInput = document.createElement('input');
                daysInput.type = 'number';
                daysInput.min = '0';
                daysInput.className = 'gantt-details-input';
                daysInput.value = stageData.workdays;
                daysInput.setAttribute('readonly', 'readonly');
                daysInput.setAttribute('disabled', 'disabled');
                daysCell.appendChild(daysInput);
                applyColumnWidth(daysCell, 'days');
                
                detailsRow.appendChild(startCell);
                detailsRow.appendChild(endCell);
                detailsRow.appendChild(daysCell);
                
                // Ячейка "Связь" - скрыта для строки этапа
                const linkCell = document.createElement('div');
                linkCell.className = 'gantt-details-cell link-cell';
                linkCell.style.display = 'none';
                detailsRow.appendChild(linkCell);
                
                // Ячейка "Ответственный" - скрыта для строки этапа
                const respCell = document.createElement('div');
                respCell.className = 'gantt-details-cell responsible-cell';
                respCell.style.display = 'none';
                detailsRow.appendChild(respCell);
                
                row.appendChild(detailsRow);
                
                // Пустые ячейки для временной шкалы (не рисуем бары для этапа)
                timelineUnits.forEach(() => {
                    const cell = document.createElement('div');
                    cell.className = 'gantt-cell';
                    cell.style.minWidth = '30px';
                    cell.style.width = '30px';
                    row.appendChild(cell);
                });
                
                // Добавляем обработчик клика для разворачивания этапа
                row.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleStageCollapse(stageName);
                });
                
                // Добавляем курсор pointer для индикации кликабельности
                row.style.cursor = 'pointer';
                
                return row;
            }

            // Функция для обновления видимости задач этапа
            function updateStageTasksVisibility(stageName, isCollapsing) {
                const tasksByStage = {};
                tasks.forEach((task, index) => {
                    const stage = task.stage || 'Без этапа';
                    if (!tasksByStage[stage]) {
                        tasksByStage[stage] = [];
                    }
                    tasksByStage[stage].push({ task, index });
                });

                const stageTasks = tasksByStage[stageName] || [];
                
                if (isCollapsing) {
                    // Сворачиваем: создаем строку этапа и скрываем задачи
                    // Находим первую задачу этапа для позиционирования
                    const firstTaskRow = chartContainer.querySelector(`[data-task-id="${stageTasks[0].task.id}"]`);
                    if (firstTaskRow) {
                        // Удаляем старую строку этапа, если есть
                        const oldStageRow = chartContainer.querySelector(`[data-stage-name="${stageName}"]`);
                        if (oldStageRow) {
                            oldStageRow.remove();
                        }
                        
                        // Создаем новую строку этапа
                        const stageRow = createStageRow(stageName, stageTasks, 0);
                        
                        // Вставляем строку этапа на место первой задачи СРАЗУ (до скрытия задач)
                        if (firstTaskRow.parentNode) {
                            firstTaskRow.parentNode.insertBefore(stageRow, firstTaskRow);
                        } else {
                            chartContainer.appendChild(stageRow);
                        }
                        
                        // Создаем строку этапа в таблице задач
                        const firstTableRow = document.querySelector(`#tasksTableBody tr[data-task-id="${stageTasks[0].task.id}"]`);
                        if (firstTableRow) {
                            const oldStageTableRow = document.querySelector(`#tasksTableBody tr[data-stage-name="${stageName}"]`);
                            if (oldStageTableRow) {
                                oldStageTableRow.remove();
                            }
                            const stageTableRow = createStageTableRow(stageName, stageTasks);
                            firstTableRow.parentNode.insertBefore(stageTableRow, firstTableRow);
                        }
                        
                        // Теперь скрываем все задачи этапа одновременно (без задержки между ними)
                        stageTasks.forEach(({ task }) => {
                            // Скрываем строку в диаграмме Ганта
                            const taskRow = chartContainer.querySelector(`[data-task-id="${task.id}"]`);
                            if (taskRow && taskRow !== stageRow) {
                                // Добавляем класс для анимации и сразу скрываем
                                taskRow.classList.add('collapsing');
                                // Скрываем быстро, чтобы не было пробелов
                                setTimeout(() => {
                                    taskRow.style.display = 'none';
                                    taskRow.classList.remove('collapsing');
                                }, 200);
                            }
                            
                            // Скрываем строку в таблице задач
                            const tableRow = document.querySelector(`#tasksTableBody tr[data-task-id="${task.id}"]`);
                            if (tableRow) {
                                // Добавляем класс для анимации и сразу скрываем
                                tableRow.classList.add('collapsing');
                                // Скрываем быстро, чтобы не было пробелов
                                setTimeout(() => {
                                    tableRow.style.display = 'none';
                                    tableRow.classList.remove('collapsing');
                                }, 200);
                            }
                        });
                    }
                } else {
                    // Разворачиваем: удаляем строку этапа и показываем задачи
                    // Удаляем строку этапа из диаграммы Ганта
                    const stageRow = chartContainer.querySelector(`[data-stage-name="${stageName}"]`);
                    if (stageRow) {
                        stageRow.remove();
                    }
                    
                    // Удаляем строку этапа из таблицы задач
                    const stageTableRow = document.querySelector(`#tasksTableBody tr[data-stage-name="${stageName}"]`);
                    if (stageTableRow) {
                        stageTableRow.remove();
                    }
                    
                    // Небольшая задержка перед показом задач для корректной анимации
                    setTimeout(() => {
                        // Показываем все задачи этапа с анимацией
                        stageTasks.forEach(({ task }, index) => {
                            // Показываем строку в диаграмме Ганта
                            const taskRow = chartContainer.querySelector(`[data-task-id="${task.id}"]`);
                            if (taskRow) {
                                // Удаляем класс stage-collapsed, если он есть
                                taskRow.classList.remove('stage-collapsed');
                                taskRow.style.display = '';
                                taskRow.style.visibility = 'visible';
                                setTimeout(() => {
                                    taskRow.classList.add('expanding');
                                    setTimeout(() => {
                                        taskRow.classList.remove('expanding');
                                    }, 300);
                                }, index * 50);
                            }
                            
                            // Показываем строку в таблице задач
                            const tableRow = document.querySelector(`#tasksTableBody tr[data-task-id="${task.id}"]`);
                            if (tableRow) {
                                // Удаляем класс stage-collapsed, если он есть
                                tableRow.classList.remove('stage-collapsed');
                                tableRow.style.display = '';
                                tableRow.style.visibility = 'visible';
                                setTimeout(() => {
                                    tableRow.classList.add('expanding');
                                    setTimeout(() => {
                                        tableRow.classList.remove('expanding');
                                    }, 300);
                                }, index * 50);
                            }
                        });
                    }, 50);
                }
            }
            
            // Функция для создания строки этапа в таблице задач
            function createStageTableRow(stageName, stageTasks) {
                const stageData = calculateStageData(stageTasks);
                const stageMatch = stageName.match(/^(Этап\s+\d+)/);
                const stageNumber = stageMatch ? stageMatch[1] : stageName;
                
                // Используем метаданные столбцов, если они есть, иначе дефолтные
                const columns = skeletonColumns || [
                    { id: 'stage', name: 'Этап', field: 'stage', order: 0 },
                    { id: 'control', name: 'Вид контроля', field: 'control', order: 1 },
                    { id: 'task', name: 'Мероприятие', field: 'task', order: 2 }
                ];
                const sortedColumns = [...columns].sort((a, b) => a.order - b.order);
                
                const row = document.createElement('tr');
                row.className = 'stage-row-collapsed';
                row.dataset.stageName = stageName;
                row.dataset.isStageRow = 'true';
                
                // Ячейка с номером (пустая для строки этапа)
                const numCell = document.createElement('td');
                numCell.textContent = '';
                row.appendChild(numCell);
                
                // Ячейка "Выбор этапа" (пустая для строки этапа)
                const stageSelectCell = document.createElement('td');
                stageSelectCell.textContent = '';
                row.appendChild(stageSelectCell);
                
                // Ячейки для настраиваемых столбцов - первая с названием этапа, остальные пустые
                sortedColumns.forEach((col, colIndex) => {
                    const cell = document.createElement('td');
                    if (colIndex === 0 && col.field === 'stage') {
                        // Первая колонка (обычно "Этап") - показываем название этапа
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = stageNumber;
                        nameSpan.style.fontWeight = '600';
                        nameSpan.style.color = 'var(--color-primary)';
                        cell.appendChild(nameSpan);
                    } else {
                        // Остальные колонки - пустые
                        cell.textContent = '';
                    }
                    row.appendChild(cell);
                });
                
                // Ячейка с датой начала
                const startCell = document.createElement('td');
                const startInput = document.createElement('input');
                startInput.type = 'date';
                startInput.className = 'tasks-table-input';
                startInput.value = stageData.startDate ? formatDateForInput(stageData.startDate) : '';
                startInput.setAttribute('readonly', 'readonly');
                startInput.setAttribute('disabled', 'disabled');
                startCell.appendChild(startInput);
                row.appendChild(startCell);
                
                // Ячейка с датой окончания
                const endCell = document.createElement('td');
                const endInput = document.createElement('input');
                endInput.type = 'date';
                endInput.className = 'tasks-table-input';
                endInput.value = stageData.endDate ? formatDateForInput(stageData.endDate) : '';
                endInput.setAttribute('readonly', 'readonly');
                endInput.setAttribute('disabled', 'disabled');
                endCell.appendChild(endInput);
                row.appendChild(endCell);
                
                // Ячейка с рабочими днями
                const daysCell = document.createElement('td');
                const daysInput = document.createElement('input');
                daysInput.type = 'number';
                daysInput.className = 'tasks-table-input';
                daysInput.min = '0';
                daysInput.value = stageData.workdays;
                daysInput.setAttribute('readonly', 'readonly');
                daysInput.setAttribute('disabled', 'disabled');
                daysCell.appendChild(daysInput);
                row.appendChild(daysCell);
                
                // Ячейка "Связь" (пустая для строки этапа)
                const linkCell = document.createElement('td');
                linkCell.className = 'table-col-link';
                linkCell.textContent = '';
                row.appendChild(linkCell);
                
                // Ячейка "Ответственный" (пустая для строки этапа)
                const respCell = document.createElement('td');
                respCell.className = 'table-col-responsible';
                respCell.textContent = '';
                row.appendChild(respCell);
                
                // Ячейка "Статус" (пустая для строки этапа)
                const statusCell = document.createElement('td');
                statusCell.textContent = '';
                row.appendChild(statusCell);
                
                // Добавляем обработчик клика для разворачивания этапа
                row.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleStageCollapse(stageName);
                });
                
                return row;
            }

            // Функция для обновления метки этапа
            function updateStageLabel(stageName, isCollapsing) {
                const stageLabel = document.querySelector(`.gantt-stage-label[data-stage-name="${stageName}"]`);
                if (!stageLabel) return;

                if (isCollapsing) {
                    // Сворачиваем: скрываем метку этапа (теперь используется строка этапа)
                    stageLabel.style.display = 'none';
                    
                    // Находим первую задачу этапа для позиционирования
                    const tasksByStage = {};
                    tasks.forEach((task, index) => {
                        const stage = task.stage || 'Без этапа';
                        if (!tasksByStage[stage]) {
                            tasksByStage[stage] = [];
                        }
                        tasksByStage[stage].push({ task, index });
                    });
                    
                    const stageTasks = tasksByStage[stageName] || [];
                    if (stageTasks.length > 0) {
                        const firstTaskRow = chartContainer.querySelector(`[data-task-id="${stageTasks[0].task.id}"]`);
                        if (firstTaskRow) {
                            const rowRect = firstTaskRow.getBoundingClientRect();
                            const chartContainerParent = chartContainer.closest('.chart-container');
                            if (chartContainerParent) {
                                const containerRect = chartContainerParent.getBoundingClientRect();
                                const stageTop = rowRect.top - containerRect.top;
                                stageLabel.style.top = stageTop + 'px';
                                stageLabel.style.height = '35px';
                            }
                        }
                    }
                } else {
                    // Разворачиваем: показываем метку этапа обратно
                    stageLabel.style.display = '';
                    stageLabel.classList.remove('collapsed');
                    
                    // Пересчитываем высоту этапа
                    const tasksByStage = {};
                    tasks.forEach((task, index) => {
                        const stage = task.stage || 'Без этапа';
                        if (!tasksByStage[stage]) {
                            tasksByStage[stage] = [];
                        }
                        tasksByStage[stage].push({ task, index });
                    });
                    
                    const stageTasks = tasksByStage[stageName] || [];
                    if (stageTasks.length > 0) {
                        const firstTaskRow = chartContainer.querySelector(`[data-task-id="${stageTasks[0].task.id}"]`);
                        if (firstTaskRow) {
                            const rowRect = firstTaskRow.getBoundingClientRect();
                            const chartContainerParent = chartContainer.closest('.chart-container');
                            if (chartContainerParent) {
                                const containerRect = chartContainerParent.getBoundingClientRect();
                                const stageTop = rowRect.top - containerRect.top;
                                
                                // Вычисляем высоту этапа
                                let stageHeight = 0;
                                stageTasks.forEach(({ task }) => {
                                    const taskRow = chartContainer.querySelector(`[data-task-id="${task.id}"]`);
                                    if (taskRow && !taskRow.classList.contains('stage-collapsed')) {
                                        stageHeight += taskRow.offsetHeight || 35;
                                    }
                                });
                                
                                stageLabel.style.top = stageTop + 'px';
                                stageLabel.style.height = stageHeight + 'px';
                            }
                        }
                    }
                }
            }

            // После создания всех задач создаем метки этапов с правильным позиционированием
            function createStageLabels() {
                // Находим контейнеры заново (на случай, если DOM изменился)
                const currentChartContainerParent = chartContainer.closest('.chart-container');
                const currentStageLabelsContainer = currentChartContainerParent 
                    ? currentChartContainerParent.querySelector('.gantt-stage-labels')
                    : chartContainer.querySelector('.gantt-stage-labels');
                
                // Если контейнер не найден, выходим
                if (!currentStageLabelsContainer || !currentChartContainerParent) {
                    console.warn('Контейнер меток этапов не найден');
                    return;
                }
                
                // Удаляем старый контейнер кнопок управления, если есть
                const oldControlsContainer = currentChartContainerParent.querySelector('.gantt-stage-controls');
                if (oldControlsContainer) {
                    oldControlsContainer.remove();
                }
                
                // Создаем контейнер для кнопок управления (над метками этапов)
                const controlsContainer = document.createElement('div');
                controlsContainer.className = 'gantt-stage-controls';
                
                // Кнопка "+" для сворачивания всех этапов
                const collapseBtn = document.createElement('button');
                collapseBtn.className = 'gantt-stage-control-btn';
                collapseBtn.textContent = '+';
                collapseBtn.title = 'Свернуть все этапы';
                collapseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    collapseAllStages();
                });
                
                // Кнопка "-" для разворачивания всех этапов
                const expandBtn = document.createElement('button');
                expandBtn.className = 'gantt-stage-control-btn';
                expandBtn.textContent = '−';
                expandBtn.title = 'Развернуть все этапы';
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    expandAllStages();
                });
                
                controlsContainer.appendChild(collapseBtn);
                controlsContainer.appendChild(expandBtn);
                currentChartContainerParent.appendChild(controlsContainer);
                
                // Очищаем старые метки и разделители перед созданием новых
                currentStageLabelsContainer.innerHTML = '';
                const oldDividers = currentChartContainerParent.querySelectorAll('.gantt-stage-divider');
                oldDividers.forEach(divider => divider.remove());
                
                const headerHeight = header.offsetHeight || 80;
                let currentTop = headerHeight;
                
                // Вычисляем позицию заголовка относительно .chart-container
                if (currentChartContainerParent && header) {
                    const headerRect = header.getBoundingClientRect();
                    const containerRect = currentChartContainerParent.getBoundingClientRect();
                    currentTop = Math.max(0, headerRect.top - containerRect.top);
                }
                
                // Вычисляем начальную позицию (высота заголовка)
                let accumulatedTop = headerHeight;
                
                // Создаем метки и разделители для каждого этапа
                Object.keys(tasksByStage).forEach((stageName, stageIndex) => {
                    const stageTasks = tasksByStage[stageName];
                    const isStageCollapsed = collapsedStages.has(stageName);
                    
                    // Вычисляем высоту этапа (сумма высот всех строк этапа)
                    let stageHeight = 0;
                    if (isStageCollapsed) {
                        const stageRow = chartContainer.querySelector(`[data-stage-name="${stageName}"]`);
                        stageHeight = stageRow ? stageRow.offsetHeight : 35;
                    } else {
                        stageTasks.forEach(({ task }) => {
                            const taskRow = chartContainer.querySelector(`[data-task-id="${task.id}"]`);
                            if (taskRow && !taskRow.classList.contains('stage-collapsed')) {
                                stageHeight += taskRow.offsetHeight || 35;
                            }
                        });
                    }
                    
                    // Если высота не вычислена, используем минимальную
                    if (stageHeight === 0) {
                        stageHeight = isStageCollapsed ? 35 : (stageTasks.length * 35);
                    }
                    
                    // Добавляем разделительную полосу перед этапом (кроме первого)
                    if (stageIndex > 0) {
                        const divider = document.createElement('div');
                        divider.className = 'gantt-stage-divider';
                        divider.setAttribute('data-stage-index', stageIndex);
                        divider.style.top = (accumulatedTop - 2) + 'px';
                        currentChartContainerParent.appendChild(divider);
                    }
                    
                    // Создаем метку этапа
                    const stageLabel = document.createElement('div');
                    stageLabel.className = 'gantt-stage-label';
                    const stageMatch = stageName.match(/^(Этап\s+\d+)/);
                    const stageNumber = stageMatch ? stageMatch[1] : stageName;
                    stageLabel.textContent = stageNumber;
                    stageLabel.setAttribute('data-stage-name', stageName);
                    stageLabel.style.top = accumulatedTop + 'px';
                    stageLabel.style.height = stageHeight + 'px';
                    
                    // Проверяем, свернут ли этап
                    if (isStageCollapsed) {
                        stageLabel.classList.add('collapsed');
                        stageLabel.style.height = '35px';
                        stageLabel.style.display = 'none'; // Скрываем метку при сворачивании
                        stageHeight = 35;
                    }
                    
                    // Добавляем обработчик клика для сворачивания/разворачивания
                    stageLabel.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleStageCollapse(stageName);
                    });
                    
                    currentStageLabelsContainer.appendChild(stageLabel);
                    
                    // Обновляем накопленную высоту для следующего этапа
                    accumulatedTop += stageHeight + 2;
                });
                
                // Добавляем разделитель после последнего этапа, если он свернут
                const stageNames = Object.keys(tasksByStage);
                if (stageNames.length > 0) {
                    const lastStageName = stageNames[stageNames.length - 1];
                    const isLastStageCollapsed = collapsedStages.has(lastStageName);
                    if (isLastStageCollapsed) {
                        // Вычисляем позицию разделителя после последнего этапа
                        // accumulatedTop уже содержит позицию после последнего этапа (включая отступ 2px)
                        // Разделитель должен быть в конце последнего этапа, то есть на accumulatedTop - 2
                        let lastDivider = currentChartContainerParent.querySelector('.gantt-stage-divider[data-stage-index="last"]');
                        if (!lastDivider) {
                            lastDivider = document.createElement('div');
                            lastDivider.className = 'gantt-stage-divider';
                            lastDivider.setAttribute('data-stage-index', 'last');
                            currentChartContainerParent.appendChild(lastDivider);
                        }
                        lastDivider.style.top = (accumulatedTop - 2) + 'px';
                    } else {
                        // Удаляем разделитель после последнего этапа, если он развернут
                        const lastDivider = currentChartContainerParent.querySelector('.gantt-stage-divider[data-stage-index="last"]');
                        if (lastDivider) {
                            lastDivider.remove();
                        }
                    }
                }
                
                // Пересчитываем позиции после создания всех меток (для исправления наложения при первой загрузке)
                // Используем несколько пересчетов для гарантии корректного позиционирования
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        recalculateStageLabelsPositions();
                        // Дополнительный пересчет через небольшую задержку для надежности
                        setTimeout(() => {
                            recalculateStageLabelsPositions();
                        }, 100);
                    });
                });
            }
            
            // Создаем метки этапов с использованием requestAnimationFrame для гарантии готовности DOM
            requestAnimationFrame(() => {
                setTimeout(() => {
                    createStageLabels();
                    // Дополнительный пересчет через больший интервал для гарантии корректного позиционирования
                    setTimeout(() => {
                        recalculateStageLabelsPositions();
                    }, 300);
                }, 100);
            });

            // После перерисовки восстанавливаем подсветку выбранной строки (если была)
            applySelectionHighlight();
            
            // Обновляем видимость вертикального скролла после перерисовки
            setTimeout(() => {
                updateVerticalScrollVisibility();
            }, 100);
        }

        // Обновить заголовок таблицы на основе метаданных столбцов
        function updateTableHeader() {
            const thead = document.querySelector('#tasksTable thead tr');
            if (!thead) return;

            // Используем метаданные столбцов, если они есть, иначе дефолтные
            const columns = skeletonColumns || [
                { id: 'stage', name: 'Этап', field: 'stage', order: 0 },
                { id: 'control', name: 'Вид контроля', field: 'control', order: 1 },
                { id: 'task', name: 'Мероприятие', field: 'task', order: 2 }
            ];

            // Сортируем столбцы по порядку
            const sortedColumns = [...columns].sort((a, b) => a.order - b.order);

            // Генерируем заголовки столбцов
            const headerCells = [
                '<th>№ п/п</th>',
                '<th>Выбор этапа</th>',
                ...sortedColumns.map(col => `<th>${col.name}</th>`),
                '<th>Дата начала</th>',
                '<th>Дата окончания</th>',
                '<th>Рабочих дней</th>',
                '<th class="table-col-link">Связь</th>',
                '<th class="table-col-responsible">Ответственный</th>',
                '<th>Статус</th>'
            ];

            thead.innerHTML = headerCells.join('');
        }

        // Отрисовка таблицы
        function renderTable() {
            // Обновляем заголовок таблицы перед отрисовкой
            updateTableHeader();
            
            const tbody = document.getElementById('tasksTableBody');
            tbody.innerHTML = '';

            // Используем метаданные столбцов, если они есть, иначе дефолтные
            const columns = skeletonColumns || [
                { id: 'stage', name: 'Этап', field: 'stage', order: 0 },
                { id: 'control', name: 'Вид контроля', field: 'control', order: 1 },
                { id: 'task', name: 'Мероприятие', field: 'task', order: 2 }
            ];
            const sortedColumns = [...columns].sort((a, b) => a.order - b.order);

            // Группируем задачи по этапам
            const tasksByStage = {};
            tasks.forEach((task, index) => {
                const stage = task.stage || 'Без этапа';
                if (!tasksByStage[stage]) {
                    tasksByStage[stage] = [];
                }
                tasksByStage[stage].push({ task, index });
            });

            // Отрисовываем задачи по этапам
            Object.keys(tasksByStage).forEach((stageName, stageIndex) => {
                const stageTasks = tasksByStage[stageName];
                const isStageCollapsed = collapsedStages.has(stageName);

                // Если этап свернут, создаем строку этапа вместо всех задач
                if (isStageCollapsed) {
                    const stageTableRow = createStageTableRow(stageName, stageTasks);
                    tbody.appendChild(stageTableRow);
                    return; // Пропускаем отрисовку задач этапа
                }

                // Отрисовываем все задачи этого этапа
                stageTasks.forEach(({ task, index }) => {
                const row = document.createElement('tr');
                row.dataset.taskId = String(task.id);

                // Проверяем, свернут ли этап задачи
                const taskStage = task.stage || 'Без этапа';
                if (collapsedStages.has(taskStage)) {
                    row.classList.add('stage-collapsed');
                }

                // Статус строки относительно выбранного этапа
                if (currentStageFilter !== 'all') {
                    if (isTaskInCurrentStage(task)) {
                        row.classList.add('stage-active');
                    } else {
                        row.classList.add('inactive');
                    }
                }
                const startStr = task.startDate ? formatDateForInput(task.startDate) : '';
                const endStr = task.endDate ? formatDateForInput(task.endDate) : '';

                // Разбираем этап на префикс "Этап N" и редактируемый хвост
                let stagePrefix = '';
                let stageSuffix = task.stage || '';
                let currentStageShort = '';
                const stageMatch = (task.stage || '').match(/^(Этап\s+\d+\.?\s*)(.*)$/);
                if (stageMatch) {
                    stagePrefix = stageMatch[1];
                    stageSuffix = stageMatch[2] || '';
                    // Извлекаем короткое название этапа (без точки и пробелов в конце)
                    currentStageShort = stageMatch[1].trim().replace(/\.$/, '');
                } else if (task.stage) {
                    // Если этап не соответствует формату "Этап N", используем его целиком
                    currentStageShort = task.stage;
                }

                // Получаем список доступных этапов
                const availableStages = getAvailableStages();
                
                // Определяем, какой этап должен быть выбран
                let selectedStage = '';
                if (currentStageShort) {
                    // Ищем точное совпадение или этап, который начинается с текущего короткого названия
                    const matchedStage = availableStages.find(s => s === currentStageShort || s.startsWith(currentStageShort));
                    selectedStage = matchedStage || currentStageShort;
                } else if (task.stage) {
                    // Если этап не соответствует формату "Этап N", ищем его в списке
                    const matchedStage = availableStages.find(s => s === task.stage);
                    selectedStage = matchedStage || (availableStages.length > 0 ? availableStages[0] : '');
                } else {
                    // Если этапа нет, выбираем первый доступный
                    selectedStage = availableStages.length > 0 ? availableStages[0] : '';
                }
                
                // Формируем опции для select
                let stageSelectOptions = '';
                availableStages.forEach(stage => {
                    const isSelected = stage === selectedStage;
                    stageSelectOptions += `<option value="${stage.replace(/"/g, '&quot;')}" ${isSelected ? 'selected' : ''}>${stage}</option>`;
                });

                // Проверяем, можно ли редактировать (для блокировки в режиме просмотра)
                const isEditable = canEdit();
                const disabledAttr = isEditable ? '' : 'disabled';

                // Подготавливаем значения для подсказок
                const fullStage = task.stage || '';
                
                // Генерируем ячейки для настраиваемых столбцов
                const columnCells = sortedColumns.map(col => {
                    let cellContent = '';
                    let tooltipAttr = '';
                    
                    if (col.field === 'stage') {
                        // Специальная обработка для столбца "Этап"
                        const fullValue = task.stage || '';
                        // Экранируем кавычки и амперсанды для безопасной вставки в HTML-атрибут
                        const escapedValue = fullValue ? fullValue.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;') : '';
                        tooltipAttr = escapedValue ? `data-tooltip="${escapedValue}"` : '';
                        cellContent = `
                            <span class="stage-prefix">${stagePrefix}</span>
                            <input type="text"
                                   class="tasks-table-input"
                                   data-index="${index}"
                                   data-field="stageSuffix"
                                   data-prefix="${stagePrefix}"
                                   title=""
                                   ${isEditable ? '' : 'readonly'}>
                        `;
                    } else {
                        // Обычные столбцы
                        const value = task[col.field] || '';
                        // Экранируем кавычки и амперсанды для безопасной вставки в HTML-атрибут
                        const escapedValue = value ? value.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;') : '';
                        tooltipAttr = escapedValue ? `data-tooltip="${escapedValue}"` : '';
                        // Определяем поле для data-field: для task используем taskTitle, для остальных - имя поля
                        const dataField = col.field === 'task' ? 'taskTitle' : col.field;
                        cellContent = `
                            <input type="text"
                                   class="tasks-table-input"
                                   data-index="${index}"
                                   data-field="${dataField}"
                                   title=""
                                   ${isEditable ? '' : 'readonly'}>
                        `;
                    }
                    
                    return `<td ${tooltipAttr}>${cellContent}</td>`;
                }).join('');
                
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>
                        <select class="tasks-table-input-select" data-index="${index}" data-field="stageSelect" ${disabledAttr}>
                            ${stageSelectOptions}
                        </select>
                    </td>
                    ${columnCells}
                    <td>
                        <input type="date"
                               class="tasks-table-input"
                               value="${startStr}"
                               data-index="${index}"
                               data-field="startDate"
                               ${isEditable ? '' : 'readonly'}>
                    </td>
                    <td>
                        <input type="date"
                               class="tasks-table-input"
                               value="${endStr}"
                               data-index="${index}"
                               data-field="endDate"
                               ${isEditable ? '' : 'readonly'}>
                    </td>
                    <td>
                        <input type="number"
                               class="tasks-table-input"
                               min="0"
                               value="${task.days}"
                               data-index="${index}"
                               data-field="days"
                               ${isEditable ? '' : 'readonly'}>
                    </td>
                    <td class="table-col-link">
                        <select class="tasks-table-input link-select"
                                data-index="${index}"
                                data-field="link"
                                ${isEditable && index > 0 ? '' : 'disabled'}>
                            <option value="О_Н" ${(task.link === 'О_Н' || !task.link) ? 'selected' : ''}>О_Н</option>
                            <option value="Н_Н" ${task.link === 'Н_Н' ? 'selected' : ''}>Н_Н</option>
                            <option value="О_О" ${task.link === 'О_О' ? 'selected' : ''}>О_О</option>
                        </select>
                    </td>
                    <td class="table-col-responsible" ${task.responsible ? `data-tooltip="${task.responsible.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}"` : ''}>
                        <input type="text"
                               class="tasks-table-input"
                               value="${task.responsible || ''}"
                               data-index="${index}"
                               data-field="responsible">
                    </td>
                    <td>
                        <select class="tasks-table-input-select" data-index="${index}" data-field="status" ${disabledAttr}>
                            <option value="pending" ${task.status === 'pending' ? 'selected' : ''}>Запланирована</option>
                            <option value="in-progress" ${task.status === 'in-progress' ? 'selected' : ''}>В работе</option>
                            <option value="completed" ${task.status === 'completed' ? 'selected' : ''}>Завершено</option>
                        </select>
                    </td>
                `;

                // Устанавливаем значения для всех настраиваемых столбцов
                sortedColumns.forEach(col => {
                    if (col.field === 'stage') {
                        // Поле этапа — редактируется только хвост после "Этап N."
                        const stageInput = row.querySelector('input[data-field="stageSuffix"]');
                        if (stageInput) {
                            stageInput.value = stageSuffix;
                        }
                    } else if (col.field === 'task') {
                        // Подставляем текст названия задачи в input
                        const titleInput = row.querySelector('input[data-field="taskTitle"]');
                        if (titleInput) {
                            // Синхронизируем поля task и name
                            if (task.task && !task.name) {
                                task.name = task.task;
                            } else if (task.name && !task.task) {
                                task.task = task.name;
                            }
                            // Используем существующее название или пустую строку (не устанавливаем "Новая задача" автоматически)
                            titleInput.value = task.task || task.name || '';
                        }
                    } else {
                        // Обычные столбцы
                        const input = row.querySelector(`input[data-field="${col.field}"]`);
                        if (input) {
                            input.value = task[col.field] || '';
                        }
                    }
                });

                // Drag & drop для таблицы
                row.draggable = canEdit(); // Блокируем drag&drop в режиме просмотра
                row.addEventListener('dragstart', (e) => {
                    if (!canEdit()) {
                        e.preventDefault();
                        return;
                    }
                    draggingTaskId = task.id;
                    row.classList.add('dragging');
                    if (e.dataTransfer) {
                        e.dataTransfer.effectAllowed = 'move';
                    }
                });

                row.addEventListener('dragend', () => {
                    draggingTaskId = null;
                    row.classList.remove('dragging');
                    tbody.querySelectorAll('.table-row-drop-target').forEach(el => el.classList.remove('table-row-drop-target'));
                });

                row.addEventListener('dragover', (e) => {
                    if (draggingTaskId === null || draggingTaskId === task.id) return;
                    e.preventDefault();
                    row.classList.add('table-row-drop-target');
                });

                row.addEventListener('dragleave', () => {
                    row.classList.remove('table-row-drop-target');
                });

                row.addEventListener('drop', (e) => {
                    if (!canEdit()) {
                        e.preventDefault();
                        return;
                    }
                    if (draggingTaskId === null || draggingTaskId === task.id) return;
                    e.preventDefault();
                    row.classList.remove('table-row-drop-target');

                    const fromIndex = tasks.findIndex(t => t.id === draggingTaskId);
                    const targetId = task.id;
                    if (fromIndex === -1) return;

                    // Сохраняем состояние в историю перед перетаскиванием
                    addToUndoHistory();

                    console.log('🔄 DRAG&DROP (таблица): Начало перетаскивания задачи');
                    console.log('   Перетаскиваемая задача ID:', draggingTaskId);
                    console.log('   Старый индекс:', fromIndex);
                    
                    // Сохраняем данные ДО перемещения для отладки
                    const movedTaskBefore = tasks[fromIndex];
                    console.log('   📋 ДО перемещения - задача:', movedTaskBefore.task || movedTaskBefore.name);
                    console.log('   📋 ДО перемещения - даты:', movedTaskBefore.dates?.map(d => formatDateKey(d)));
                    console.log('   📋 ДО перемещения - статусы дат:', movedTaskBefore.dateStatuses);
                    console.log('   📋 ДО перемещения - комментарии:', movedTaskBefore.dateComments);
                    console.log('   📋 ДО перемещения - общий статус:', movedTaskBefore.status);

                    const [moved] = tasks.splice(fromIndex, 1);
                    const targetIndex = tasks.findIndex(t => t.id === targetId);
                    let newIndex;
                    if (targetIndex === -1) {
                        tasks.push(moved);
                        newIndex = tasks.length - 1;
                    } else {
                        tasks.splice(targetIndex, 0, moved);
                        newIndex = targetIndex;
                    }

                    console.log('   Новый индекс:', newIndex);
                    console.log('   📋 ПОСЛЕ перемещения (до пересчета) - статусы дат:', moved.dateStatuses);
                    console.log('   📋 ПОСЛЕ перемещения (до пересчета) - комментарии:', moved.dateComments);

                    const startIndex = Math.min(fromIndex, newIndex);
                    console.log('   🔢 Начинаем пересчет с индекса:', startIndex);
                    recalculateDatesFrom(startIndex);

                    console.log('   📋 ПОСЛЕ пересчета - статусы дат:', moved.dateStatuses);
                    console.log('   📋 ПОСЛЕ пересчета - комментарии:', moved.dateComments);
                    console.log('   📋 ПОСЛЕ пересчета - новые даты:', moved.dates?.map(d => formatDateKey(d)));

                    draggingTaskId = null;
                    updateStatistics();
                    renderGantt();
                    renderTable();
                });

                // Обработчик mousedown для предотвращения срабатывания клика строки при выделении текста
                let isSelectingText = false;
                row.addEventListener('mousedown', (event) => {
                    const target = event.target;
                    const isInputElement = target.tagName === 'INPUT' || 
                                         target.tagName === 'SELECT' || 
                                         target.tagName === 'TEXTAREA' ||
                                         target.closest('input, select, textarea');
                    
                    if (isInputElement && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA')) {
                        // Если это поле ввода, разрешаем выделение текста
                        isSelectingText = true;
                        // Останавливаем всплытие события, чтобы клик строки не сработал
                        event.stopPropagation();
                    } else {
                        isSelectingText = false;
                    }
                });
                
                // Клик по строке таблицы — выбор задачи и подсветка (поддержка Shift)
                row.addEventListener('click', (event) => {
                    // Проверяем, что клик не на поле ввода или select
                    const target = event.target;
                    const isInputElement = target.tagName === 'INPUT' || 
                                         target.tagName === 'SELECT' || 
                                         target.tagName === 'TEXTAREA' ||
                                         target.closest('input, select, textarea');
                    
                    // Если клик на поле ввода, не обрабатываем клик строки
                    if (isInputElement) {
                        return;
                    }
                    
                    // Если идет выделение текста, не обрабатываем клик строки
                    if (isSelectingText) {
                        return;
                    }
                    
                    // Проверяем, не идет ли выделение текста в поле ввода
                    const activeElement = document.activeElement;
                    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                        const input = activeElement;
                        // Проверяем, есть ли выделение текста в активном поле ввода
                        if (input.selectionStart !== null && input.selectionEnd !== null && 
                            input.selectionStart !== input.selectionEnd) {
                            return; // Идет выделение текста в поле ввода, не обрабатываем клик строки
                        }
                    }
                    
                    // Проверяем, не идет ли выделение текста на странице
                    const selection = window.getSelection();
                    if (selection && selection.toString().length > 0) {
                        return; // Идет выделение текста, не обрабатываем клик строки
                    }
                    
                    handleTaskRowClick(task.id, event);
                });
                
                // Сбрасываем флаг выделения текста при отпускании мыши
                row.addEventListener('mouseup', (event) => {
                    // Небольшая задержка, чтобы дать браузеру время обработать выделение текста
                    setTimeout(() => {
                        isSelectingText = false;
                    }, 10);
                });

                tbody.appendChild(row);
                }); // Конец forEach по stageTasks
            }); // Конец forEach по этапам (Object.keys(tasksByStage))

            // После перерисовки восстанавливаем подсветку выбранной строки (если была)
            applySelectionHighlight();

            // Навешиваем обработчики изменений
            tbody.querySelectorAll('.tasks-table-input, .tasks-table-input-select').forEach(input => {
                input.addEventListener('change', onTaskTableInputChange);
            });
            
            // Делегирование событий для текстовых input полей в детальной таблице
            // Используем один обработчик на уровне tbody, чтобы избежать дублирования при перерисовке
            // Удаляем старые обработчики, если они есть (по атрибуту)
            if (!tbody.hasAttribute('data-text-modal-handlers')) {
                tbody.setAttribute('data-text-modal-handlers', 'true');
                
                tbody.addEventListener('click', (e) => {
                    const input = e.target;
                    if (input && 
                        input.tagName === 'INPUT' &&
                        input.classList.contains('tasks-table-input') && 
                        input.type === 'text' && 
                        !input.hasAttribute('readonly') && 
                        canEdit() &&
                        (input.closest('#tasksTable') || input.closest('.tasks-table'))) {
                        
                        console.log('🖱️ Click на текстовое поле (делегирование):', input.getAttribute('data-field'));
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        input.blur();
                        setTimeout(() => {
                            openTextInputModal(input);
                        }, 50);
                        return false;
                    }
                }, true); // Используем capture phase для приоритета
                
                tbody.addEventListener('focus', (e) => {
                    const input = e.target;
                    if (input && 
                        input.tagName === 'INPUT' &&
                        input.classList.contains('tasks-table-input') && 
                        input.type === 'text' && 
                        !input.hasAttribute('readonly') && 
                        canEdit() &&
                        (input.closest('#tasksTable') || input.closest('.tasks-table'))) {
                        
                        console.log('🎯 Focus на текстовое поле (делегирование):', input.getAttribute('data-field'));
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        input.blur();
                        setTimeout(() => {
                            openTextInputModal(input);
                        }, 50);
                        return false;
                    }
                }, true); // Используем capture phase для приоритета
                
                tbody.addEventListener('touchstart', (e) => {
                    const input = e.target;
                    if (input && 
                        input.tagName === 'INPUT' &&
                        input.classList.contains('tasks-table-input') && 
                        input.type === 'text' && 
                        !input.hasAttribute('readonly') && 
                        canEdit() &&
                        (input.closest('#tasksTable') || input.closest('.tasks-table'))) {
                        
                        console.log('👆 Touchstart на текстовое поле (делегирование):', input.getAttribute('data-field'));
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        input.blur();
                        setTimeout(() => {
                            openTextInputModal(input);
                        }, 50);
                        return false;
                    }
                }, true); // Используем capture phase для приоритета
            }
            
            // Специальный обработчик для select "Связь" - обновление подсказки
            tbody.querySelectorAll('select.link-select[data-field="link"]').forEach(select => {
                const tooltips = {
                    'О_Н': 'окончание - начало',
                    'Н_Н': 'начало - начало',
                    'О_О': 'окончание - окончание'
                };
                
                function updateTooltip() {
                    const value = select.value;
                    const tooltip = tooltips[value] || '';
                    if (tooltip) {
                        select.setAttribute('data-tooltip', tooltip);
                    } else {
                        select.removeAttribute('data-tooltip');
                    }
                }
                
                // Устанавливаем подсказку при загрузке
                updateTooltip();
                
                // Обновляем подсказку при изменении
                select.addEventListener('change', updateTooltip);
            });
            
            // Специальный обработчик для select статуса - открываем меню статуса вместо стандартного выпадающего списка
            tbody.querySelectorAll('select[data-field="status"]').forEach(select => {
                // Блокируем стандартное открытие выпадающего списка
                select.addEventListener('mousedown', (event) => {
                    if (!canEdit()) {
                        event.preventDefault();
                        return;
                    }
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                    
                    const index = parseInt(select.getAttribute('data-index'), 10);
                    const task = tasks[index];
                    if (!task) return;
                    
                    // Получаем координаты select для позиционирования меню
                    // Используем getBoundingClientRect() для получения координат относительно viewport
                    const rect = select.getBoundingClientRect();
                    // Позиционируем меню справа от select, выравнивая по верхнему краю
                    // Координаты getBoundingClientRect() уже относительно viewport
                    const x = rect.right; // Правая граница select
                    const y = rect.top; // Верхний край select (меню будет выровнено по верхнему краю)
                    
                    console.log('📍 Select координаты:', { 
                        left: rect.left, 
                        right: rect.right, 
                        top: rect.top, 
                        bottom: rect.bottom,
                        width: rect.width,
                        height: rect.height,
                        x: x,
                        y: y
                    });
                    
                    // Сохраняем координаты для позиционирования
                    lastClickCoordinates.x = x;
                    lastClickCoordinates.y = y;
                    
                    // Открываем меню статуса рядом с select
                    // Используем все даты задачи для открытия меню
                    const taskDates = task.dates || [];
                    const dateStrs = taskDates.map(d => formatDateKey(d));
                    
                    // Открываем меню с правильными координатами
                    openStatusMenu(x, y, task.id, dateStrs);
                    // Устанавливаем флаг, что меню было открыто из select
                    statusMenuOpenedFromSelect = true;
                });
                
                // Обработчик click для предотвращения закрытия меню при клике на select
                // Используем capture фазу, чтобы перехватить событие до того, как оно дойдет до window.onclick
                select.addEventListener('click', (event) => {
                    if (!canEdit()) {
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        return;
                    }
                    // Останавливаем всплытие события, чтобы window.onclick не закрыл меню
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                    // Предотвращаем стандартное поведение select
                    event.preventDefault();
                }, true); // true = capture фаза
                
                // Обработчик mouseup для предотвращения закрытия меню при отпускании кнопки мыши
                // Используем capture фазу, чтобы перехватить событие до того, как оно дойдет до window.onclick
                select.addEventListener('mouseup', (event) => {
                    if (!canEdit()) {
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        return;
                    }
                    // Останавливаем всплытие события, чтобы window.onclick не закрыл меню
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                    // Предотвращаем стандартное поведение select
                    event.preventDefault();
                }, true); // true = capture фаза
                
                // Также обрабатываем touch события для мобильных устройств
                select.addEventListener('touchstart', (event) => {
                    if (!canEdit()) {
                        event.preventDefault();
                        return;
                    }
                    event.preventDefault();
                    event.stopPropagation();
                    
                    const index = parseInt(select.getAttribute('data-index'), 10);
                    const task = tasks[index];
                    if (!task) return;
                    
                    // Получаем координаты тапа и позиционируем меню рядом с select
                    const rect = select.getBoundingClientRect();
                    const touch = event.touches[0];
                    // Используем координаты тапа, но если они далеко от select, используем позицию select
                    const tapX = touch.clientX;
                    const tapY = touch.clientY;
                    // Позиционируем меню справа от select, выравнивая по верхнему краю
                    const x = rect.right; // Правая граница select
                    const y = rect.top; // Верхний край select (меню будет выровнено по верхнему краю)
                    
                    console.log('📍 Touch координаты:', { 
                        tapX, 
                        tapY,
                        selectLeft: rect.left,
                        selectRight: rect.right,
                        selectTop: rect.top,
                        selectBottom: rect.bottom,
                        finalX: x,
                        finalY: y
                    });
                    
                    // Сохраняем координаты для позиционирования
                    lastClickCoordinates.x = x;
                    lastClickCoordinates.y = y;
                    
                    // Открываем меню статуса рядом с select
                    const taskDates = task.dates || [];
                    const dateStrs = taskDates.map(d => formatDateKey(d));
                    
                    openStatusMenu(x, y, task.id, dateStrs);
                });
            });
        }

        // Обработка изменения полей в детальной таблице
        function onTaskTableInputChange(event) {
            // Обработка случая, когда функция вызывается через .call(this) без event
            if (!event || !event.target) {
                if (this && this.nodeName) {
                    // Если this - это элемент (input/select), создаем синтетический event
                    event = { target: this };
                } else {
                    console.error('onTaskTableInputChange: нет event и нет this');
                    return;
                }
            }
            
            if (!canEdit()) {
                if (event.preventDefault) {
                    event.preventDefault();
                }
                if (event.target && event.target.blur) {
                    event.target.blur();
                }
                return; // Блокируем редактирование в режиме просмотра
            }
            const input = event.target;
            const index = parseInt(input.getAttribute('data-index'), 10);
            const field = input.getAttribute('data-field');
            const task = tasks[index];
            if (!task) return;

            // Сохраняем состояние в историю перед изменением
            // Проверяем, было ли уже сохранено для этого поля в данный момент редактирования
            const undoKey = `undo_${index}_${field}`;
            if (!window[undoKey]) {
                console.log(`📝 Добавляем в историю отмены: изменение ${field} задачи ${index}`);
                addToUndoHistory();
                window[undoKey] = true;
                // Сбрасываем флаг через небольшую задержку, чтобы можно было отменить серию изменений
                setTimeout(() => {
                    delete window[undoKey];
                }, 1000);
            }

            // Обновляем базовые поля
            if (field === 'taskTitle') {
                task.task = input.value || '';
                task.name = task.task; // Синхронизируем оба поля
                // Обновляем подсказку на родительском td
                const td = input.closest('td');
                if (td) {
                    if (task.task) {
                        td.setAttribute('data-tooltip', task.task);
                    } else {
                        td.removeAttribute('data-tooltip');
                    }
                }
            } else if (field === 'stageSelect') {
                // Обработка изменения этапа через выпадающий список
                const newStageShort = input.value;
                const oldStage = task.stage || '';
                
                // Проверяем, является ли новый этап пользовательским (не "Этап N")
                const isNewStageCustom = !newStageShort.match(/^Этап\s+\d+$/);
                
                let newStage;
                if (isNewStageCustom) {
                    // Если новый этап - пользовательский, используем его как есть, без добавления суффикса
                    newStage = newStageShort;
                } else {
                    // Если новый этап - стандартный "Этап N", извлекаем суффикс из старого этапа
                    let stageSuffix = '';
                    const oldStageMatch = oldStage.match(/^(Этап\s+\d+\.?\s*)(.*)$/);
                    if (oldStageMatch) {
                        stageSuffix = oldStageMatch[2] || '';
                    }
                    
                    // Формируем новый этап: префикс + суффикс (если есть)
                    if (stageSuffix.trim()) {
                        // Если есть суффикс, добавляем его к новому этапу
                        newStage = `${newStageShort}. ${stageSuffix.trim()}`;
                    } else {
                        // Если суффикса нет, используем только название этапа
                        newStage = newStageShort;
                    }
                }
                
                // Обновляем этап только для текущей задачи (не групповое переименование)
                task.stage = newStage;
                
                // Переинициализируем конфигурацию этапов и вкладки
                initializeStageConfig();
                renderStageTabs();
                
                // Обновляем отображение графика и таблицы
                renderGantt();
                renderTable();
                
                // Сохраняем изменения
                debouncedSave();
            } else if (field === 'stageSuffix') {
                const oldStage = task.stage || '';
                const prefix = input.getAttribute('data-prefix') || '';
                const suffix = (input.value || '').trim();

                // Если есть известный префикс "Этап N", блокируем его изменение
                let newStage;
                if (prefix) {
                    newStage = suffix ? (prefix + ' ' + suffix) : prefix.trim();
                } else {
                    // Для нестандартных строк (без "Этап N") редактируем всё целиком
                    newStage = suffix;
                }

                // Групповое переименование: меняем название у всех задач
                // с тем же исходным этапом
                if (oldStage && oldStage !== newStage) {
                    tasks.forEach(t => {
                        if (t.stage === oldStage) {
                            t.stage = newStage;
                        }
                    });
                }
                task.stage = newStage;

                // Переинициализируем конфигурацию этапов и вкладки
                initializeStageConfig();
                renderStageTabs();
                
                // Обновляем подсказку на родительском td
                const td = input.closest('td');
                if (td) {
                    if (task.stage) {
                        td.setAttribute('data-tooltip', task.stage);
                    } else {
                        td.removeAttribute('data-tooltip');
                    }
                }
            } else if (field === 'control') {
                task.control = input.value || '';
                // Обновляем подсказку на родительском td
                const td = input.closest('td');
                if (td) {
                    if (task.control) {
                        td.setAttribute('data-tooltip', task.control);
                    } else {
                        td.removeAttribute('data-tooltip');
                    }
                }
            } else if (field === 'startDate') {
                task.startDate = parseDateFromInput(input.value);

                // Если уже есть дата окончания и она стала раньше даты начала — подтягиваем её вперёд
                if (task.startDate && task.endDate && task.endDate < task.startDate) {
                    task.endDate = new Date(task.startDate);
                    // Обновляем все связанные инпуты даты окончания (и в таблице, и в Ганте)
                    document
                        .querySelectorAll(`input[data-index="${index}"][data-field="endDate"]`)
                        .forEach(inp => {
                            inp.value = formatDateForInput(task.endDate);
                        });
                }
            } else if (field === 'endDate') {
                const newEnd = parseDateFromInput(input.value);

                // Правило: дата окончания не может быть раньше даты начала
                if (task.startDate && newEnd && newEnd < task.startDate) {
                    task.endDate = new Date(task.startDate);
                    input.value = formatDateForInput(task.endDate);
                    openDateValidationModal('Дата окончания не может быть раньше даты начала.');
                } else {
                    task.endDate = newEnd;
                }
            } else if (field === 'days') {
                const val = parseInt(input.value, 10);
                task.days = isNaN(val) || val < 0 ? 0 : val;
            } else if (field === 'link') {
                task.link = input.value || '';
            } else if (field === 'responsible') {
                task.responsible = input.value || '';
                // Всегда показываем полное значение в data-tooltip на родительской <td> (таблица),
                // чтобы при переполнении можно было увидеть всех ответственных при наведении в едином стиле подсказок.
                const td = input.closest('.table-col-responsible');
                if (td) {
                    if (task.responsible) {
                        td.setAttribute('data-tooltip', task.responsible);
                    } else {
                        td.removeAttribute('data-tooltip');
                    }
                }
                // Также обновляем подсказку в Ганте (если колонка видна)
                const ganttRow = document.querySelector(`.gantt-row[data-task-id="${task.id}"]`);
                if (ganttRow) {
                    const ganttRespCell = ganttRow.querySelector('.gantt-details-cell input[data-field="responsible"]')?.parentElement;
                    if (ganttRespCell) {
                        if (task.responsible) {
                            ganttRespCell.setAttribute('data-tooltip', task.responsible);
                        } else {
                            ganttRespCell.removeAttribute('data-tooltip');
                        }
                    }
                }
            } else if (field === 'status') {
                // Обработка изменения статуса через select теперь происходит через меню статуса
                // Этот обработчик оставлен на случай, если статус изменится другим способом
                // Но обычно меню статуса открывается при клике на select
                const newStatus = input.value;
                const oldStatus = task.status;
                
                // Если статус действительно изменился (не через меню), применяем его
                if (newStatus !== oldStatus) {
                    // Сохраняем старое значение для отката, если пользователь отменит
                    input.value = oldStatus; // Возвращаем старое значение в select
                    
                    // Сохраняем координаты элемента select для позиционирования модального окна
                    const rect = input.getBoundingClientRect();
                    lastClickCoordinates.x = rect.left + rect.width / 2;
                    lastClickCoordinates.y = rect.top + rect.height / 2;
                    
                    // Показываем предупреждение перед применением статуса
                    openScaleWarning(newStatus, null, true, index);
                }
                return; // Не применяем статус сразу, ждём подтверждения
            }

            // Пересчитываем даты задачи в зависимости от заполненных полей.
            // Логика:
            // - меняем дату начала → фиксируем days и пересчитываем дату конца;
            //   ИСКЛЮЧЕНИЕ: для связи О_О (окончание-окончание) дата окончания фиксирована, пересчитываем только days;
            // - меняем дату окончания → фиксируем дату начала и пересчитываем days;
            // - меняем days → считаем от даты начала (если есть) или от даты конца.
            if (field === 'startDate') {
                // Проверяем тип связи
                const linkType = task.link || 'О_Н';
                
                if (linkType === 'О_О') {
                    // Для связи О_О: дата окончания фиксирована, пересчитываем только рабочие дни
                    if (task.startDate && task.endDate) {
                        // Обе даты заданы → пересчитываем количество рабочих дней
                        // Дата окончания остается неизменной (не пересчитывается)
                        const dates = getWorkdaysBetween(task.startDate, task.endDate);
                        task.dates = dates;
                        task.days = dates.length;
                    } else if (task.startDate && task.days > 0) {
                        // Если дата окончания не задана, но есть рабочие дни - считаем от даты начала
                        const dates = getTaskDates(task.startDate, task.days);
                        task.dates = dates;
                        task.startDate = dates[0];
                        task.endDate = dates[dates.length - 1];
                    }
                } else {
                    // Для связей О_Н и Н_Н: стандартная логика
                    if (task.startDate && task.days > 0) {
                        // Дата начала + рабочие дни → считаем дату конца
                        const dates = getTaskDates(task.startDate, task.days);
                        task.dates = dates;
                        task.startDate = dates[0];
                        task.endDate = dates[dates.length - 1];
                    } else if (task.startDate && task.endDate) {
                        // Обе даты заданы → пересчитываем количество рабочих дней
                        const dates = getWorkdaysBetween(task.startDate, task.endDate);
                        task.dates = dates;
                        task.days = dates.length;
                    }
                }
                
                // Если у следующей задачи связь Н_Н, пересчитываем её дату начала
                if (index < tasks.length - 1) {
                    const nextTask = tasks[index + 1];
                    if (nextTask.link === 'Н_Н' && task.startDate) {
                        nextTask.startDate = new Date(task.startDate);
                        recalculateTaskDatesWithWeekends(nextTask);
                        // Пересчитываем все последующие задачи
                        recalculateFollowingTasks(index + 1);
                    }
                }
            } else if (field === 'endDate') {
                if (task.startDate && task.endDate) {
                    // Фиксируем дату начала, двигаем только конец → считаем новые рабочие дни
                    const dates = getWorkdaysBetween(task.startDate, task.endDate);
                    task.dates = dates;
                    task.days = dates.length;
                } else if (task.endDate && task.days > 0) {
                    // Есть дата конца и количество рабочих дней → считаем дату начала назад
                    const dates = getWorkdaysBackward(task.endDate, task.days);
                    task.dates = dates;
                    task.startDate = dates[0];
                    task.endDate = dates[dates.length - 1];
                }
                
                // Если у следующей задачи связь О_О, пересчитываем её дату окончания
                if (index < tasks.length - 1) {
                    const nextTask = tasks[index + 1];
                    if (nextTask.link === 'О_О' && task.endDate) {
                        nextTask.endDate = new Date(task.endDate);
                        if (nextTask.days > 0) {
                            const dates = getWorkdaysBackward(nextTask.endDate, nextTask.days);
                            nextTask.dates = dates;
                            nextTask.startDate = dates[0];
                            nextTask.endDate = dates[dates.length - 1];
                        }
                        // Пересчитываем все последующие задачи
                        recalculateFollowingTasks(index + 1);
                    }
                }
            } else if (field === 'days') {
                // Проверяем тип связи
                const linkType = task.link || 'О_Н';
                
                if (linkType === 'О_О') {
                    // Для связи О_О: дата окончания фиксирована, пересчитываем дату начала назад
                    if (task.endDate && task.days > 0) {
                        // Есть дата конца и количество рабочих дней → считаем дату начала назад
                        // Дата окончания остается фиксированной (не пересчитывается)
                        const dates = getWorkdaysBackward(task.endDate, task.days);
                        task.dates = dates;
                        task.startDate = dates[0];
                        // task.endDate остается неизменным
                    } else if (task.startDate && task.days > 0) {
                        // Если дата окончания не задана, но есть дата начала - считаем от даты начала
                        const dates = getTaskDates(task.startDate, task.days);
                        task.dates = dates;
                        task.startDate = dates[0];
                        task.endDate = dates[dates.length - 1];
                    }
                } else {
                    // Для связей О_Н и Н_Н: стандартная логика
                    if (task.startDate && task.days > 0) {
                        // Есть дата начала и количество рабочих дней → считаем дату конца
                        const dates = getTaskDates(task.startDate, task.days);
                        task.dates = dates;
                        task.startDate = dates[0];
                        task.endDate = dates[dates.length - 1];
                    } else if (task.endDate && task.days > 0) {
                        // Есть дата конца и количество рабочих дней → считаем дату начала назад
                        const dates = getWorkdaysBackward(task.endDate, task.days);
                        task.dates = dates;
                        task.startDate = dates[0];
                        task.endDate = dates[dates.length - 1];
                    }
                }
            }

            // При ручном редактировании дат/количества дней очищаем
            // покраску по дням, чтобы не путать пользователя (статус
            // по строке управляется отдельно через поле "status")
            if (field === 'startDate' || field === 'endDate' || field === 'days') {
                task.dateStatuses = {};
                if (task.status === 'in-progress' || task.status === 'completed') {
                    task.dates.forEach(d => {
                        const key = formatDateKey(d);
                        task.dateStatuses[key] = task.status;
                    });
                }
            }

            // Обработка изменения связи
            if (field === 'link') {
                const linkType = input.value || 'О_Н';
                task.link = linkType;
                
                console.log(`🔗 Изменение связи задачи ${index} на ${linkType}`);
                
                // Пересчитываем даты текущей задачи в зависимости от типа связи
                if (index > 0) {
                    const prevTask = tasks[index - 1];
                    
                    if (linkType === 'Н_Н') {
                        // Н_Н: начало-начало - задача начинается в ту же дату, что и предшественник
                        if (prevTask.startDate) {
                            task.startDate = new Date(prevTask.startDate);
                            if (task.days > 0) {
                                recalculateTaskDatesWithWeekends(task);
                            }
                            console.log(`  ✅ Н_Н: задача начинается ${formatDateForInput(task.startDate)}`);
                        } else {
                            console.warn(`  ⚠️ Н_Н: у предыдущей задачи нет даты начала`);
                        }
                    } else if (linkType === 'О_О') {
                        // О_О: окончание-окончание - задача заканчивается в ту же дату, что и предшественник
                        if (prevTask.endDate) {
                            task.endDate = new Date(prevTask.endDate);
                            if (task.days > 0) {
                                const dates = getWorkdaysBackward(task.endDate, task.days);
                                task.dates = dates;
                                task.startDate = dates[0];
                                task.endDate = dates[dates.length - 1];
                            }
                            console.log(`  ✅ О_О: задача заканчивается ${formatDateForInput(task.endDate)}`);
                        } else {
                            console.warn(`  ⚠️ О_О: у предыдущей задачи нет даты окончания`);
                        }
                    } else if (linkType === 'О_Н') {
                        // О_Н: окончание-начало - задача начинается после окончания предыдущей
                        if (prevTask.endDate) {
                            const newStart = new Date(prevTask.endDate);
                            newStart.setDate(newStart.getDate() + 1);
                            // Ищем следующий рабочий день
                            while (!isWorkday(newStart)) {
                                newStart.setDate(newStart.getDate() + 1);
                            }
                            task.startDate = newStart;
                            if (task.days > 0) {
                                recalculateTaskDatesWithWeekends(task);
                            }
                            console.log(`  ✅ О_Н: задача начинается ${formatDateForInput(task.startDate)}`);
                        } else {
                            console.warn(`  ⚠️ О_Н: у предыдущей задачи нет даты окончания`);
                        }
                    }
                }
                
                // Сбрасываем статусы дат при изменении связи
                task.dateStatuses = {};
            }

            // Жёсткая последовательность: все последующие задачи
            // автоматически сдвигаются так, чтобы начинаться на следующий
            // рабочий день после окончания предыдущей, при этом своё
            // количество рабочих дней каждая задача сохраняет.
            // Теперь учитывается тип связи каждой задачи.
            recalculateFollowingTasks(index);

            // Обновляем значения в input полях сразу после пересчета
            // (до полного рендера, чтобы пользователь видел изменения сразу)
            const allInputs = document.querySelectorAll(`[data-index="${index}"]`);
            allInputs.forEach(inp => {
                const field = inp.getAttribute('data-field');
                if (field === 'startDate' && task.startDate) {
                    inp.value = formatDateForInput(task.startDate);
                } else if (field === 'endDate' && task.endDate) {
                    inp.value = formatDateForInput(task.endDate);
                } else if (field === 'days') {
                    inp.value = task.days;
                }
            });

            // Сохраняем текущую позицию прокрутки и активный элемент перед перерисовкой
            const scrollY = window.scrollY || window.pageYOffset;
            const scrollX = window.scrollX || window.pageXOffset;
            
            // Также сохраняем прокрутку контейнера диаграммы, если есть
            const chartContainer = document.getElementById('ganttChart');
            const chartScrollTop = chartContainer ? chartContainer.scrollTop : 0;
            const chartScrollLeft = chartContainer ? chartContainer.scrollLeft : 0;
            
            // Сохраняем активный элемент и убираем фокус, чтобы предотвратить автоматическую прокрутку
            const activeElement = document.activeElement;
            const activeElementInfo = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') 
                ? { element: activeElement, selectionStart: activeElement.selectionStart, selectionEnd: activeElement.selectionEnd }
                : null;
            
            if (activeElementInfo) {
                activeElementInfo.element.blur();
            }

            updateStatistics();
            // Всегда обновляем диаграмму Ганта, чтобы обновить input поля в ней
            renderGantt();
            renderTable();
            
            // Восстанавливаем позицию прокрутки сразу, без задержки
            window.scrollTo(scrollX, scrollY);
            const newChartContainer = document.getElementById('ganttChart');
            if (newChartContainer) {
                newChartContainer.scrollTop = chartScrollTop;
                newChartContainer.scrollLeft = chartScrollLeft;
            }
            
            // Восстанавливаем фокус на элемент, если он все еще существует (без прокрутки)
            if (activeElementInfo && document.contains(activeElementInfo.element)) {
                // Используем requestAnimationFrame для восстановления фокуса после рендера
                requestAnimationFrame(() => {
                    try {
                        activeElementInfo.element.focus({ preventScroll: true });
                        // Восстанавливаем выделение текста, если это input
                        if (activeElementInfo.element.setSelectionRange && 
                            activeElementInfo.selectionStart !== null && 
                            activeElementInfo.selectionEnd !== null) {
                            activeElementInfo.element.setSelectionRange(
                                activeElementInfo.selectionStart, 
                                activeElementInfo.selectionEnd
                            );
                        }
                    } catch (e) {
                        // Игнорируем ошибки при восстановлении фокуса
                    }
                });
            }
            
            // Автоматическое сохранение после изменения задачи
            console.log('📝 Изменение задачи:', field, 'для задачи:', task.task || task.name);
            
            // Для критических полей (даты, статусы, связи) сохраняем немедленно
            if (field === 'startDate' || field === 'endDate' || field === 'days' || field === 'status' || field === 'link') {
                console.log('💾 Критическое изменение даты/статуса/связи, сохраняем немедленно');
                saveFullGanttState(); // Сохраняем сразу
            } else {
                autoSaveGanttState(); // Для остальных полей - с задержкой
            }
        }

        // Пересчитать все задачи после указанного индекса в строгой последовательности
        function recalculateFollowingTasks(changedIndex) {
            console.log('🔢 recalculateFollowingTasks: Начало пересчета с индекса', changedIndex);
            for (let i = changedIndex + 1; i < tasks.length; i++) {
                const prevTask = tasks[i - 1];
                const task = tasks[i];
                
                // Устанавливаем дефолтное значение О_Н, если связи нет
                if (!task.link) {
                    task.link = 'О_Н';
                }
                
                // Определяем тип связи (по умолчанию О_Н)
                const linkType = task.link || 'О_Н';
                
                let newStart, newEnd;
                let shouldRecalculate = false;

                if (linkType === 'Н_Н') {
                    // Н_Н: начало-начало - задача начинается в ту же дату, что и предшественник
                    if (!prevTask.startDate) continue;
                    newStart = new Date(prevTask.startDate);
                    shouldRecalculate = !task.startDate || task.startDate.getTime() !== newStart.getTime();
                    
                    if (shouldRecalculate) {
                        task.startDate = newStart;
                        // Пересчитываем даты с учетом количества рабочих дней
                        recalculateTaskDatesWithWeekends(task);
                    }
                } else if (linkType === 'О_О') {
                    // О_О: окончание-окончание - задача заканчивается в ту же дату, что и предшественник
                    if (!prevTask.endDate) continue;
                    newEnd = new Date(prevTask.endDate);
                    shouldRecalculate = !task.endDate || task.endDate.getTime() !== newEnd.getTime();
                    
                    if (shouldRecalculate) {
                        task.endDate = newEnd;
                        // Пересчитываем дату начала назад от даты окончания
                        if (task.days > 0) {
                            const dates = getWorkdaysBackward(task.endDate, task.days);
                            task.dates = dates;
                            task.startDate = dates[0];
                            task.endDate = dates[dates.length - 1];
                        }
                    }
                } else {
                    // О_Н (по умолчанию): окончание-начало - задача начинается после окончания предыдущей
                    if (!prevTask.endDate) continue;
                    newStart = new Date(prevTask.endDate);
                    newStart.setDate(newStart.getDate() + 1);
                    // Ищем следующий рабочий день
                    while (!isWorkday(newStart)) {
                        newStart.setDate(newStart.getDate() + 1);
                    }
                    shouldRecalculate = !task.startDate || task.startDate.getTime() !== newStart.getTime();
                    
                    if (shouldRecalculate) {
                        task.startDate = newStart;
                        // Пересчитываем даты с учетом выходных дней (weekend-manual)
                        recalculateTaskDatesWithWeekends(task);
                    }
                }

                if (!shouldRecalculate) {
                    console.log(`   ⏭️  Даты не изменились для задачи ${i}, пропускаем`);
                    continue;
                }

                console.log(`\n   🔄 Обработка задачи ${i}:`, task.task || task.name || `ID ${task.id}`);
                console.log(`   🔗 Тип связи: ${linkType}`);
                console.log('   📅 Старая дата начала:', task.startDate ? formatDateKey(task.startDate) : 'нет');
                console.log('   📅 Новая дата начала:', formatDateKey(task.startDate));
                console.log('   📅 Дата окончания:', task.endDate ? formatDateKey(task.endDate) : 'нет');
                console.log('   📅 Старые даты:', task.dates?.map(d => formatDateKey(d)) || []);
                console.log('   📊 Старые статусы дат:', task.dateStatuses);
                console.log('   💬 Старые комментарии:', task.dateComments);

                console.log('   📅 Новые даты:', task.dates?.map(d => formatDateKey(d)) || []);
                console.log('   ⚠️  СБРОС статусов дат!');
                console.log('      - Статусы ДО сброса:', task.dateStatuses);
                console.log('      - Комментарии ДО сброса:', task.dateComments);

                // Сбрасываем индивидуальные статусы дат для сдвинутых задач
                task.dateStatuses = {};
                
                console.log('      - Статусы ПОСЛЕ сброса:', task.dateStatuses);
                console.log('   ❌ ВСЕ СТАТУСЫ УДАЛЕНЫ!');
            }
            console.log('🔢 recalculateFollowingTasks: Пересчет завершен\n');
        }

        // Пересчитать даты задач начиная с указанного индекса (используется после drag&drop)
        function recalculateDatesFrom(startIndex) {
            if (startIndex < 0 || startIndex >= tasks.length) return;
            console.log('🔢 recalculateDatesFrom: Начало пересчета с индекса', startIndex);
            autoSaveGanttState();
            let prevTask = null;
            if (startIndex > 0) {
                prevTask = tasks[startIndex - 1];
            }

            for (let i = startIndex; i < tasks.length; i++) {
                const task = tasks[i];
                console.log(`\n   🔄 Обработка задачи ${i}:`, task.task || task.name || `ID ${task.id}`);

                // Устанавливаем дефолтное значение О_Н, если связи нет
                if (!task.link && i > 0) {
                    task.link = 'О_Н';
                }
                
                // Определяем тип связи (по умолчанию О_Н для первой задачи нет связи)
                const linkType = task.link || 'О_Н';
                
                let dates;
                
                if (i === 0) {
                    // Для первой задачи сохраняем её существующую дату начала
                    const newStart = new Date(task.startDate);
                    dates = getTaskDates(newStart, task.days);
                } else if (prevTask) {
                    if (linkType === 'Н_Н') {
                        // Н_Н: начало-начало - задача начинается в ту же дату, что и предшественник
                        if (prevTask.startDate) {
                            const newStart = new Date(prevTask.startDate);
                            dates = getTaskDates(newStart, task.days);
                        } else {
                            continue;
                        }
                    } else if (linkType === 'О_О') {
                        // О_О: окончание-окончание - задача заканчивается в ту же дату, что и предшественник
                        if (prevTask.endDate) {
                            const newEnd = new Date(prevTask.endDate);
                            dates = getWorkdaysBackward(newEnd, task.days);
                        } else {
                            continue;
                        }
                    } else {
                        // О_Н (по умолчанию): окончание-начало - задача начинается после окончания предыдущей
                        if (prevTask.endDate) {
                            const newStart = new Date(prevTask.endDate);
                            newStart.setDate(newStart.getDate() + 1);
                            dates = getTaskDates(newStart, task.days);
                        } else {
                            continue;
                        }
                    }
                } else {
                    continue;
                }

                console.log('   📅 Старая дата начала:', task.startDate ? formatDateKey(task.startDate) : 'нет');
                console.log('   📅 Новая дата начала:', formatDateKey(dates[0]));
                console.log('   📅 Старые даты:', task.dates?.map(d => formatDateKey(d)) || []);
                console.log('   📊 Старые статусы дат:', task.dateStatuses);
                console.log('   💬 Старые комментарии:', task.dateComments);

                // Сохраняем старые статусы и комментарии перед изменением дат
                const oldDateStatuses = { ...task.dateStatuses };
                const oldDateComments = { ...(task.dateComments || {}) };
                const oldDates = [...(task.dates || [])];
                
                console.log('   💾 Сохранены старые данные:');
                console.log('      - Статусы:', oldDateStatuses);
                console.log('      - Комментарии:', oldDateComments);
                console.log('      - Старые даты:', oldDates.map(d => formatDateKey(d)));
                
                task.dates = dates;
                task.startDate = dates[0];
                task.endDate = dates[dates.length - 1];
                
                // Обновляем prevTask для следующей итерации
                prevTask = task;

                console.log('   📅 Новые даты:', dates.map(d => formatDateKey(d)));
                console.log('   ⚠️  СБРОС статусов и комментариев!');
                console.log('      - Статусы ДО сброса:', task.dateStatuses);
                console.log('      - Комментарии ДО сброса:', task.dateComments);

                // После изменения цепочки сбрасываем покраску дат
                // НЕ применяем общий статус задачи ко всем датам автоматически
                // Индивидуальные статусы дат должны устанавливаться вручную
                task.dateStatuses = {};
                task.dateComments = {};
                
                console.log('      - Статусы ПОСЛЕ сброса:', task.dateStatuses);
                console.log('      - Комментарии ПОСЛЕ сброса:', task.dateComments);
                console.log('   ❌ ВСЕ СТАТУСЫ И КОММЕНТАРИИ УДАЛЕНЫ!');

                // Если задача была перемещена, но даты остались теми же (маловероятно, но возможно),
                // можно попытаться сохранить статусы, но в большинстве случаев даты меняются,
                // поэтому просто сбрасываем все индивидуальные статусы

                prevEnd = task.endDate;
            }
            console.log('🔢 recalculateDatesFrom: Пересчет завершен\n');
        }

        // Вставка новой задачи под выбранной (Insert)
        function insertTaskBelowSelected() {
            if (!canEdit()) {
                return; // Блокируем добавление задач в режиме просмотра
            }
            
            // Сохраняем состояние в историю перед добавлением задачи
            addToUndoHistory();
            
            const baseId = getPrimarySelectedTaskId();
            if (baseId === null) return;

            const index = tasks.findIndex(t => t.id === baseId);
            if (index === -1) return;

            const selectedTask = tasks[index];
            if (!selectedTask.endDate) return;

            // Дата начала новой задачи: следующий рабочий день после конца выбранной
            let newStart = new Date(selectedTask.endDate);
            do {
                newStart.setDate(newStart.getDate() + 1);
            } while (!isWorkday(newStart));

            const newDates = getTaskDates(newStart, 1); // длительность 1 рабочий день

            const newTask = {
                id: nextTaskId++,
                stage: selectedTask.stage,
                control: selectedTask.control,
                task: 'Новая задача',
                days: 1,
                substage: '',
                startDate: newDates[0],
                endDate: newDates[newDates.length - 1],
                dates: newDates,
                status: 'pending',
                dateStatuses: {},
                link: '',
                responsible: ''
            };

            // Вставляем новую задачу сразу после выбранной
            tasks.splice(index + 1, 0, newTask);

            // Пересчитываем все последующие задачи, чтобы они шли после новой
            recalculateFollowingTasks(index + 1);

            // Сохраняем текущую позицию прокрутки и активный элемент перед перерисовкой
            const scrollY = window.scrollY || window.pageYOffset;
            const scrollX = window.scrollX || window.pageXOffset;
            
            // Также сохраняем прокрутку контейнера диаграммы, если есть
            const chartContainer = document.getElementById('ganttChart');
            const chartScrollTop = chartContainer ? chartContainer.scrollTop : 0;
            const chartScrollLeft = chartContainer ? chartContainer.scrollLeft : 0;
            
            // Сохраняем активный элемент и убираем фокус, чтобы предотвратить автоматическую прокрутку
            const activeElement = document.activeElement;
            const activeElementInfo = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') 
                ? { element: activeElement, selectionStart: activeElement.selectionStart, selectionEnd: activeElement.selectionEnd }
                : null;
            
            if (activeElementInfo) {
                activeElementInfo.element.blur();
            }

            updateStatistics();
            renderGantt();
            renderTable();

            // Восстанавливаем позицию прокрутки сразу, без задержки
            window.scrollTo(scrollX, scrollY);
            const newChartContainer = document.getElementById('ganttChart');
            if (newChartContainer) {
                newChartContainer.scrollTop = chartScrollTop;
                newChartContainer.scrollLeft = chartScrollLeft;
            }
            
            // Восстанавливаем фокус на элемент, если он все еще существует (без прокрутки)
            if (activeElementInfo && document.contains(activeElementInfo.element)) {
                requestAnimationFrame(() => {
                    try {
                        activeElementInfo.element.focus({ preventScroll: true });
                        if (activeElementInfo.element.setSelectionRange && 
                            activeElementInfo.selectionStart !== null && 
                            activeElementInfo.selectionEnd !== null) {
                            activeElementInfo.element.setSelectionRange(
                                activeElementInfo.selectionStart, 
                                activeElementInfo.selectionEnd
                            );
                        }
                    } catch (e) {
                        // Игнорируем ошибки при восстановлении фокуса
                    }
                });
            }

            // Выделяем только что созданную строку
            selectTask(newTask.id);
	    autoSaveGanttState();
            autoSaveGanttState(); // Автоматическое сохранение после добавления задачи
        }

        // Удаление выбранных задач (Delete)
        function deleteSelectedTask() {
            if (!canEdit()) {
                return; // Блокируем удаление задач в режиме просмотра
            }
            if (!selectedTaskIds.size) return;

            // Сохраняем состояние в историю перед удалением задачи
            addToUndoHistory();

            // Получаем индексы всех выделенных задач
            const indices = [];
            tasks.forEach((t, idx) => {
                if (selectedTaskIds.has(t.id)) {
                    indices.push(idx);
                }
            });

            if (!indices.length) return;

            const firstIndex = Math.min(...indices);

            // Удаляем выделенные задачи с конца, чтобы не сбить индексы
            indices
                .sort((a, b) => b - a)
                .forEach(i => {
                    tasks.splice(i, 1);
                });

            selectedTaskIds.clear();
            lastSelectedTaskId = null;

            if (!tasks.length) {
                // Если задач не осталось — просто перерисовываем без пересчёта
                updateStatistics();
                renderGantt();
                renderTable();
                return;
            }

            // Пересчитываем цепочку дат начиная с позиции, где была первая удалённая задача
            const startIndex = Math.min(firstIndex, tasks.length - 1);
            if (startIndex === 0) {
                recalculateDatesFrom(0);
            } else {
                recalculateFollowingTasks(startIndex - 1);
            }
		autoSaveGanttState();

            // Ставим курсор на задачу, которая стала на место первой удалённой (если есть)
            const newIndex = Math.min(startIndex, tasks.length - 1);
            const newSelected = tasks[newIndex];
            if (newSelected) {
                selectedTaskIds.add(newSelected.id);
                lastSelectedTaskId = newSelected.id;
            }

            updateStatistics();
            renderGantt();
            renderTable();

            applySelectionHighlight();
            autoSaveGanttState(); // Автоматическое сохранение после удаления задачи
        }

        // Окно подтверждения удаления
        function openDeleteConfirm() {
            if (!selectedTaskIds.size) return;
            const modal = document.getElementById('deleteConfirmModal');
            if (!modal) return;
            modal.style.display = 'block';
            isDeleteConfirmOpen = true;
            
            // Позиционируем модальное окно рядом с выбранной строкой
            const primaryTaskId = getPrimarySelectedTaskId();
            if (primaryTaskId) {
                // Ищем строку в таблице или в диаграмме Ганта
                const tableRow = document.querySelector(`#tasksTableBody tr[data-task-id="${primaryTaskId}"]`);
                const ganttRow = document.querySelector(`.gantt-row[data-task-id="${primaryTaskId}"]`);
                const referenceElement = tableRow || ganttRow;
                
                if (referenceElement) {
                    // Двойной requestAnimationFrame для гарантии, что контент отрендерился
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            const modalContent = modal.querySelector('.modal-content');
                            if (!modalContent) return;
                            
                            const elementRect = referenceElement.getBoundingClientRect();
                            const viewportHeight = window.innerHeight;
                            const viewportWidth = window.innerWidth;
                            
                            // Получаем реальные размеры модального окна после рендера
                            const modalRect = modalContent.getBoundingClientRect();
                            const modalHeight = modalRect.height || 200;
                            const modalWidth = Math.min(modalRect.width || 500, viewportWidth - 40);
                            
                            // Вычисляем пространство сверху и снизу от строки
                            const spaceBelow = viewportHeight - elementRect.bottom;
                            const spaceAbove = elementRect.top;
                            
                            // Определяем, где больше места - сверху или снизу
                            let topPosition;
                            if (spaceBelow < modalHeight + 20 && spaceAbove > spaceBelow) {
                                // Показываем над строкой
                                topPosition = elementRect.top - modalHeight - 20;
                            } else {
                                // Показываем под строкой
                                topPosition = elementRect.bottom + 20;
                            }
                            
                            // Убеждаемся, что окно не выходит за пределы экрана
                            const minTop = 20;
                            const maxTop = viewportHeight - modalHeight - 20;
                            topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                            
                            // Центрируем по горизонтали относительно строки, но не выходим за пределы экрана
                            let leftPosition = elementRect.left + (elementRect.width / 2) - (modalWidth / 2);
                            const minLeft = 20;
                            const maxLeft = viewportWidth - modalWidth - 20;
                            leftPosition = Math.max(minLeft, Math.min(leftPosition, maxLeft));
                            
                            // Применяем позиционирование
                            modalContent.style.setProperty('position', 'fixed', 'important');
                            modalContent.style.setProperty('top', topPosition + 'px', 'important');
                            modalContent.style.setProperty('left', leftPosition + 'px', 'important');
                            modalContent.style.setProperty('transform', 'none', 'important');
                            modalContent.style.setProperty('margin', '0', 'important');
                            modalContent.style.setProperty('width', 'calc(100% - 40px)', 'important');
                            modalContent.style.setProperty('max-width', '500px', 'important');
                        });
                    });
                } else {
                    // Если строка не найдена, используем стандартное центрирование
                    requestAnimationFrame(() => {
                        const modalContent = modal.querySelector('.modal-content');
                        if (modalContent) {
                            modalContent.style.removeProperty('position');
                            modalContent.style.removeProperty('top');
                            modalContent.style.removeProperty('left');
                            modalContent.style.removeProperty('transform');
                            modalContent.style.removeProperty('margin');
                            modalContent.style.removeProperty('width');
                            modalContent.style.removeProperty('max-width');
                        }
                    });
                }
            }
        }

        function cancelDeleteTask() {
            const modal = document.getElementById('deleteConfirmModal');
            if (modal) {
                modal.style.display = 'none';
                
                // Сбрасываем все стили позиционирования при закрытии
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.removeProperty('position');
                    modalContent.style.removeProperty('top');
                    modalContent.style.removeProperty('left');
                    modalContent.style.removeProperty('transform');
                    modalContent.style.removeProperty('margin');
                    modalContent.style.removeProperty('width');
                    modalContent.style.removeProperty('max-width');
                }
            }
            isDeleteConfirmOpen = false;
        }

        function confirmDeleteTask() {
            deleteSelectedTask();
            cancelDeleteTask();
        }

// Асинхронная загрузка html2pdf.js библиотеки
let html2pdfLoaded = false;
let html2pdfLoading = false;

function loadHtml2Pdf() {
    return new Promise((resolve, reject) => {
        // Если уже загружена, сразу возвращаем
        if (html2pdfLoaded && typeof html2pdf !== 'undefined') {
            resolve();
            return;
        }
        
        // Если уже загружается, ждём
        if (html2pdfLoading) {
            const checkInterval = setInterval(() => {
                if (html2pdfLoaded && typeof html2pdf !== 'undefined') {
                    clearInterval(checkInterval);
                    resolve();
                }
            }, 100);
            return;
        }
        
        // Начинаем загрузку
        html2pdfLoading = true;
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js';
        script.async = true;
        script.onload = () => {
            html2pdfLoaded = true;
            html2pdfLoading = false;
            if (typeof html2pdf !== 'undefined') {
                resolve();
            } else {
                reject(new Error('html2pdf не загрузился'));
            }
        };
        script.onerror = () => {
            html2pdfLoading = false;
            reject(new Error('Не удалось загрузить html2pdf.js. Проверьте подключение к интернету.'));
        };
        
        // Устанавливаем таймаут 10 секунд
        setTimeout(() => {
            if (!html2pdfLoaded) {
                html2pdfLoading = false;
                script.remove();
                reject(new Error('Таймаут загрузки html2pdf.js'));
            }
        }, 10000);
        
        document.head.appendChild(script);
    });
}

// Функция генерации имени файла с названием компании и датой/временем
function generateExportFileName(extension) {
    // Получаем название компании из элемента или глобальной переменной
    const nameEl = document.getElementById('companyNameDisplay');
    let companyNameText = '';
    
    // Сначала пытаемся получить из элемента
    if (nameEl) {
        if (nameEl.classList.contains('has-value')) {
            companyNameText = nameEl.innerText || nameEl.textContent || '';
        }
    }
    
    // Если не получилось, используем глобальную переменную
    if ((!companyNameText || companyNameText.trim() === '') && typeof companyName !== 'undefined' && companyName) {
        companyNameText = companyName;
    }
    
    // Если название не задано, используем дефолтное
    if (!companyNameText || companyNameText.trim() === '' || companyNameText === 'Введите название компании') {
        companyNameText = 'ICONA';
    }
    
    // Очищаем название от недопустимых символов для имени файла
    // Убираем: / \ : * ? " < > |
    companyNameText = companyNameText
        .replace(/[/\\:*?"<>|]/g, '')
        .replace(/\s+/g, '_') // Заменяем пробелы на подчеркивания
        .replace(/_+/g, '_') // Убираем множественные подчеркивания
        .replace(/^_+|_+$/g, '') // Убираем подчеркивания в начале и конце
        .trim();
    
    // Если после очистки название пустое, используем дефолтное
    if (!companyNameText) {
        companyNameText = 'ICONA';
    }
    
    // Генерируем дату и время в формате YYYY-MM-DD_HH-MM-SS
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    
    const dateTime = `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
    
    // Формируем имя файла
    const fileName = `График_внедрения_${companyNameText}_${dateTime}.${extension}`;
    
    return fileName;
}

// Экспорт в PDF: детальный Гант (опционально) по выбранному масштабу + таблица задач с комментариями
async function exportPDF(scaleMode = 'day', includeDiagram = true) {
    if (!tasks || !tasks.length) return;
    
    // Загружаем библиотеку html2pdf.js перед использованием
    try {
        await loadHtml2Pdf();
    } catch (error) {
        console.error('Ошибка загрузки html2pdf.js:', error);
        alert('Не удалось загрузить библиотеку для экспорта в PDF. Пожалуйста, проверьте подключение к интернету и попробуйте снова.');
        return;
    }
    
    if (typeof html2pdf === 'undefined') {
        alert('Библиотека html2pdf не доступна. Пожалуйста, обновите страницу и попробуйте снова.');
        return;
    }

    const logoEl = document.getElementById('companyLogo');
    const nameDisplay = document.getElementById('companyNameDisplay');

    // Контейнер для экспорта
    const exportWrapper = document.createElement('div');
    exportWrapper.style.padding = '16px';
    exportWrapper.style.paddingBottom = '40px'; // Увеличиваем отступ снизу, чтобы последняя строка не обрезалась
    exportWrapper.style.background = '#ffffff';
    exportWrapper.style.fontFamily = window.getComputedStyle(document.body).fontFamily || 'sans-serif';
    exportWrapper.style.fontSize = '10px';
    exportWrapper.style.color = '#000';

    // Функция создания шапки с логотипом
    const createHeader = () => {
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.gap = '16px';
        header.style.marginBottom = '12px';

        if (logoEl) {
            const logoClone = logoEl.cloneNode(true);
            logoClone.style.width = '40px';
            logoClone.style.height = '40px';
            logoClone.style.borderRadius = '8px';
            logoClone.style.border = '1px solid #e0e0e0';
            logoClone.style.objectFit = 'contain';
            logoClone.style.background = '#fafafa';
            logoClone.style.padding = '4px';
            header.appendChild(logoClone);
        }

        const nameBlock = document.createElement('div');
        const title = document.createElement('div');
        title.textContent = `График внедрения и обучения системы ${chartTypeContainerName}`;
        title.style.fontSize = '14px';
        title.style.fontWeight = '600';

        const company = document.createElement('div');
        const currentNameText =
            nameDisplay && nameDisplay.classList.contains('has-value')
                ? (nameDisplay.innerText || nameDisplay.textContent)
                : '';
        company.innerText = currentNameText || 'Название компании';
        company.style.marginTop = '2px';
        company.style.fontSize = '12px';
        company.style.fontWeight = '600';

        nameBlock.appendChild(title);
        nameBlock.appendChild(company);
        header.appendChild(nameBlock);
        
        return header;
    };

    // --- Шапка ---
    exportWrapper.appendChild(createHeader());

    // Функция для создания ячейки с границей
    const addCellBorder = (td) => {
        td.style.border = '1px solid #cccccc';
        td.style.padding = '2px 3px';
    };

    let diagramRendered = false;
    const shouldIncludeDiagram = includeDiagram !== false;

    if (shouldIncludeDiagram) {
        const timelineUnits = buildExportTimeline(scaleMode);
        if (!timelineUnits.length) {
            console.warn('Не удалось построить временную шкалу для PDF. Будет экспортирована только таблица.');
        } else {
            diagramRendered = true;
            const scaleLabel = getExportScaleLabel(scaleMode);
            const ganttTitle = document.createElement('div');
            ganttTitle.textContent = `Диаграмма Ганта (${scaleLabel})`;
            ganttTitle.style.fontSize = '12px';
            ganttTitle.style.fontWeight = '600';
            ganttTitle.style.margin = '4px 0 6px 0';
            exportWrapper.appendChild(ganttTitle);

            const statusColors = {
                pending: '#1e88e5',
                'in-progress': '#ff9800',
                completed: '#4caf50',
                'weekend-manual': '#ffe0e0'
            };

            const unitsPerPage = scaleMode === 'day' ? 22 : scaleMode === 'week' ? 12 : 6;
            const chunks = [];
            for (let i = 0; i < timelineUnits.length; i += unitsPerPage) {
                chunks.push(timelineUnits.slice(i, i + unitsPerPage));
            }

            chunks.forEach((chunk, chunkIdx) => {
                if (chunkIdx > 0) {
                    const spacer = document.createElement('div');
                    spacer.style.height = '40px';
                    exportWrapper.appendChild(spacer);
                }

                const ganttTable = document.createElement('table');
                ganttTable.style.borderCollapse = 'collapse';
                ganttTable.style.width = '100%';
                ganttTable.style.fontSize = '8px';
                ganttTable.style.marginBottom = '20px';

                const headerTr = document.createElement('tr');
                const baseHeaders = ['Задача', 'Ответственный', 'Дата начала', 'Дата окончания', 'Рабочих дней'];
                baseHeaders.forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.style.background = '#f5f5f5';
                    th.style.color = '#222222';
                    th.style.fontWeight = '600';
                    th.style.fontSize = '8px';
                    th.style.whiteSpace = 'nowrap';
                    addCellBorder(th);
                    headerTr.appendChild(th);
                });

                chunk.forEach(unit => {
                    const th = document.createElement('th');
                    th.textContent = unit.label;
                    th.style.background = '#e3f2fd';
                    th.style.color = '#222222';
                    th.style.fontWeight = '600';
                    th.style.fontSize = '7px';
                    th.style.whiteSpace = 'nowrap';
                    addCellBorder(th);
                    headerTr.appendChild(th);
                });

                ganttTable.appendChild(headerTr);

                tasks.forEach(task => {
                    const tr = document.createElement('tr');

                    const baseValues = [
                        task.task,
                        task.responsible || '',
                        task.startDate ? task.startDate.toLocaleDateString('ru-RU') : '',
                        task.endDate ? task.endDate.toLocaleDateString('ru-RU') : '',
                        task.days != null ? String(task.days) : ''
                    ];

                    baseValues.forEach((val, idx) => {
                        const td = document.createElement('td');
                        td.textContent = val;
                        td.style.fontSize = '8px';
                        if (idx === 0) td.style.whiteSpace = 'nowrap';
                        addCellBorder(td);
                        tr.appendChild(td);
                    });

                    const statuses = task.dateStatuses || {};

                    chunk.forEach(unit => {
                        const td = document.createElement('td');
                        addCellBorder(td);

                        const unitStart = unit.start.getTime();
                        const unitEnd = unit.end.getTime();

                        let hasWorkday = false;
                        let intervalStatus = 'pending';

                        if (Array.isArray(task.dates)) {
                            const daysInUnit = task.dates.filter(d => {
                                const t = d.getTime();
                                return t >= unitStart && t <= unitEnd;
                            });

                            if (daysInUnit.length > 0) {
                                hasWorkday = true;
                                if (scaleMode === 'day' && daysInUnit.length === 1) {
                                    const key = formatDateKey(daysInUnit[0]);
                                    intervalStatus = statuses[key] || 'pending';
                                } else {
                                    const statusesInUnit = new Set();
                                    daysInUnit.forEach(d => {
                                        const key = formatDateKey(d);
                                        const s = statuses[key];
                                        if (s) statusesInUnit.add(s);
                                    });
                                    if (statusesInUnit.has('completed')) intervalStatus = 'completed';
                                    else if (statusesInUnit.has('in-progress')) intervalStatus = 'in-progress';
                                    else if (statusesInUnit.has('weekend-manual')) intervalStatus = 'weekend-manual';
                                    else intervalStatus = 'pending';
                                }
                            }
                        }

                        if (hasWorkday) {
                            const color = statusColors[intervalStatus] || statusColors.pending;
                            td.style.background = color;
                        }

                        tr.appendChild(td);
                    });

                    ganttTable.appendChild(tr);
                });

                exportWrapper.appendChild(ganttTable);
            });
        }
    }

    if (diagramRendered) {
        const separator = document.createElement('div');
        separator.style.height = '60px';
        exportWrapper.appendChild(separator);
    }

    // --- Детальная таблица задач с комментариями ---
    const detailTitle = document.createElement('div');
    detailTitle.textContent = 'Детальная таблица задач';
    detailTitle.style.fontSize = '12px';
    detailTitle.style.fontWeight = '600';
    detailTitle.style.margin = '4px 0 6px 0';
    exportWrapper.appendChild(detailTitle);

    const detailTable = document.createElement('table');
    detailTable.style.borderCollapse = 'collapse';
    detailTable.style.width = '100%';
    detailTable.style.marginBottom = '20px'; // Добавляем отступ снизу таблицы

    // Заголовок таблицы
    const detailHeaderTr = document.createElement('tr');
    [
        '№ п/п',
        'Этап',
        'Вид контроля',
        'Мероприятие',
        'Рабочих дней',
        'Ответственный',
        'Дата начала',
        'Дата окончания',
        'Комментарии по датам'
    ].forEach(text => {
        const th = document.createElement('th');
        th.textContent = text;
        th.style.background = '#f5f5f5';
        th.style.color = '#222222';
        th.style.fontWeight = '600';
        th.style.fontSize = '9px';
        th.style.whiteSpace = 'nowrap';
        addCellBorder(th);
        detailHeaderTr.appendChild(th);
    });
    detailTable.appendChild(detailHeaderTr);

    // Строки задач
    tasks.forEach((task, idx) => {
        const tr = document.createElement('tr');

        let commentsSummary = '';
        if (task.dateComments) {
            const entries = Object.entries(task.dateComments)
                .filter(([, text]) => text && String(text).trim().length > 0)
                .sort(([d1], [d2]) => (d1 < d2 ? -1 : d1 > d2 ? 1 : 0))
                .map(([date, text]) => `${date}: ${String(text).trim()}`);
            commentsSummary = entries.join('; ');
        }

        const cells = [
            idx + 1,
            task.stage || '',
            task.control || '',
            task.task || '',
            task.days != null ? String(task.days) : '',
            task.responsible || '',
            task.startDate ? task.startDate.toLocaleDateString('ru-RU') : '',
            task.endDate ? task.endDate.toLocaleDateString('ru-RU') : '',
            commentsSummary
        ];

        cells.forEach((val, cellIdx) => {
            const td = document.createElement('td');
            td.textContent = val;
            td.style.fontSize = '9px';
            if (cellIdx === 3 || cellIdx === 8) {
                td.style.whiteSpace = 'normal';
            } else {
                td.style.whiteSpace = 'nowrap';
            }
            addCellBorder(td);
            tr.appendChild(td);
        });

        detailTable.appendChild(tr);
    });

    exportWrapper.appendChild(detailTable);

    // --- Генерация PDF ---
    
    // Показываем индикатор загрузки
    const loadingIndicator = document.createElement('div');
    loadingIndicator.textContent = 'Генерация PDF...';
    loadingIndicator.style.position = 'fixed';
    loadingIndicator.style.top = '50%';
    loadingIndicator.style.left = '50%';
    loadingIndicator.style.transform = 'translate(-50%, -50%)';
    loadingIndicator.style.padding = '20px 40px';
    loadingIndicator.style.background = 'rgba(0, 0, 0, 0.8)';
    loadingIndicator.style.color = '#fff';
    loadingIndicator.style.borderRadius = '8px';
    loadingIndicator.style.zIndex = '999999';
    loadingIndicator.style.fontSize = '16px';
    loadingIndicator.style.fontWeight = '600';
    document.body.appendChild(loadingIndicator);
    
    document.body.appendChild(exportWrapper);

    const opt = {
        margin: [10, 10, 20, 10], // [top, left, bottom, right] - увеличиваем нижний отступ
        filename: generateExportFileName('pdf'),
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
            scale: 2,
            useCORS: true,
            logging: false,
            windowWidth: exportWrapper.scrollWidth,
            windowHeight: exportWrapper.scrollHeight
        },
        jsPDF: { 
            orientation: 'landscape', 
            unit: 'mm', 
            format: 'a3'
        }
    };

    html2pdf()
        .set(opt)
        .from(exportWrapper)
        .save()
        .then(() => {
            document.body.removeChild(exportWrapper);
            loadingIndicator.textContent = 'PDF готов!';
            setTimeout(() => {
                if (loadingIndicator.parentNode) {
                    document.body.removeChild(loadingIndicator);
                }
            }, 3000); // 3 секунды
        })
        .catch((err) => {
            console.error('Ошибка генерации PDF:', err);
            document.body.removeChild(exportWrapper);
            if (loadingIndicator.parentNode) {
                document.body.removeChild(loadingIndicator);
            }
            alert('Произошла ошибка при генерации PDF');
        });
}

        // Построение временной шкалы для экспорта в Excel (дни/недели/месяцы/годы)
        function buildExportTimeline(scaleMode) {
            if (!tasks.length) return [];

            const projectFirstDate = new Date(tasks[0].startDate);
            const realLastTaskDate = new Date(tasks[tasks.length - 1].endDate);
            const msInDay = 24 * 60 * 60 * 1000;

            const units = [];

            if (scaleMode === 'day') {
                let currentDate = new Date(projectFirstDate);
                while (currentDate <= realLastTaskDate) {
                    units.push({
                        type: 'day',
                        start: new Date(currentDate),
                        end: new Date(currentDate),
                        label: currentDate.toLocaleDateString('ru-RU')
                    });
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            } else if (scaleMode === 'week') {
                let weekStart = new Date(projectFirstDate);
                while (weekStart.getDay() !== 1) { // к ближайшему понедельнику назад
                    weekStart.setDate(weekStart.getDate() - 1);
                }
                while (weekStart <= realLastTaskDate) {
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekEnd.getDate() + 6);
                    const label = `${weekStart.toLocaleDateString('ru-RU')} — ${weekEnd.toLocaleDateString('ru-RU')}`;
                    units.push({
                        type: 'week',
                        start: new Date(weekStart),
                        end: new Date(weekEnd),
                        label
                    });
                    weekStart.setDate(weekStart.getDate() + 7);
                }
            } else if (scaleMode === 'month') {
                let current = new Date(projectFirstDate.getFullYear(), projectFirstDate.getMonth(), 1);
                while (current <= realLastTaskDate) {
                    const y = current.getFullYear();
                    const m = current.getMonth();
                    const monthStart = new Date(y, m, 1);
                    const monthEnd = new Date(y, m + 1, 0);
                    const label = current.toLocaleDateString('ru-RU', { month: 'long', year: 'numeric' });
                    units.push({
                        type: 'month',
                        start: monthStart,
                        end: monthEnd,
                        label
                    });
                    current.setMonth(current.getMonth() + 1);
                }
            } else if (scaleMode === 'year') {
                let currentYear = projectFirstDate.getFullYear();
                const lastYear = realLastTaskDate.getFullYear();
                while (currentYear <= lastYear) {
                    const yearStart = new Date(currentYear, 0, 1);
                    const yearEnd = new Date(currentYear, 11, 31);
                    units.push({
                        type: 'year',
                        start: yearStart,
                        end: yearEnd,
                        label: String(currentYear)
                    });
                    currentYear++;
                }
            }

            return units;
        }

        function getExportScaleLabel(scaleMode) {
            switch (scaleMode) {
                case 'day': return 'Гант (дни)';
                case 'week': return 'Гант (недели)';
                case 'month': return 'Гант (месяцы)';
                case 'year': return 'Гант (годы)';
                default: return 'Гант';
            }
        }

        // Подбор ширины столбцов под содержимое (приближённый авто‑подбор)
        function buildAutoColumnWidths(aoa) {
            if (!Array.isArray(aoa) || !aoa.length) return [];

            const colCount = aoa.reduce((max, row) => Math.max(max, row.length), 0);
            const maxLens = new Array(colCount).fill(0);

            aoa.forEach(row => {
                row.forEach((cell, colIdx) => {
                    if (cell === null || cell === undefined) return;
                    const text = String(cell);
                    if (text.length > maxLens[colIdx]) {
                        maxLens[colIdx] = text.length;
                    }
                });
            });

            return maxLens.map((len, idx) => {
                // Базовая ширина: первая колонка шире (задачи), остальные чуть уже
                const base = idx === 0 ? 20 : 8;
                const wch = Math.min(60, Math.max(base, len + 2));
                return { wch };
            });
        }

        // Экспорт в Excel
        function exportExcel() {
            // Показываем индикатор загрузки
            const loadingIndicator = document.createElement('div');
            loadingIndicator.textContent = 'Генерация Excel...';
            loadingIndicator.style.position = 'fixed';
            loadingIndicator.style.top = '50%';
            loadingIndicator.style.left = '50%';
            loadingIndicator.style.transform = 'translate(-50%, -50%)';
            loadingIndicator.style.padding = '20px 40px';
            loadingIndicator.style.background = 'rgba(0, 0, 0, 0.8)';
            loadingIndicator.style.color = '#fff';
            loadingIndicator.style.borderRadius = '8px';
            loadingIndicator.style.zIndex = '999999';
            loadingIndicator.style.fontSize = '16px';
            loadingIndicator.style.fontWeight = '600';
            document.body.appendChild(loadingIndicator);
            
            // Используем setTimeout чтобы индикатор успел отобразиться
            setTimeout(() => {
                try {
                    _exportExcelInternal(loadingIndicator);
                } catch (error) {
                    console.error('Ошибка экспорта Excel:', error);
                    if (loadingIndicator.parentNode) {
                        document.body.removeChild(loadingIndicator);
                    }
                    alert('Произошла ошибка при экспорте в Excel');
                }
            }, 100);
        }
        
        // Внутренняя функция экспорта
        function _exportExcelInternal(loadingIndicator) {
            // Если библиотека XLSX не загрузилась (например, нет интернета к CDN),
            // делаем простой экспорт в CSV, который Excel спокойно открывает.
            if (typeof XLSX === 'undefined') {
                try {
                    const selectEl = document.getElementById('excelScaleMode');
                    const rawMode = selectEl ? String(selectEl.value || '').toLowerCase() : 'day';
                    let scaleMode = 'day';
                    if (rawMode.startsWith('week') || rawMode.startsWith('нед')) scaleMode = 'week';
                    else if (rawMode.startsWith('month') || rawMode.startsWith('мес')) scaleMode = 'month';
                    else if (rawMode.startsWith('year') || rawMode.startsWith('год')) scaleMode = 'year';

                    const timelineUnits = buildExportTimeline(scaleMode);

                    let csv = '\uFEFF';

                    // Блок 1: Гант
                    if (timelineUnits.length) {
                        csv += '"' + getExportScaleLabel(scaleMode).replace(/"/g, '""') + '"\n';

                        const ganttHeader = ['Задача', 'Дата начала', 'Дата окончания', 'Рабочих дней'];
                        timelineUnits.forEach(unit => {
                            ganttHeader.push(unit.label);
                        });
                        csv += '"' + ganttHeader.map(v => String(v).replace(/"/g, '""')).join('";"') + '"\n';

                        tasks.forEach(task => {
                            const rowBase = [
                                task.task,
                                task.startDate ? task.startDate.toLocaleDateString('ru-RU') : '',
                                task.endDate ? task.endDate.toLocaleDateString('ru-RU') : '',
                                task.days
                            ];

                            const row = rowBase.map(v => String(v).replace(/"/g, '""'));

                            timelineUnits.forEach(unit => {
                                if (!task.startDate || !task.endDate || !Array.isArray(task.dates)) {
                                    row.push('');
                                    return;
                                }

                                const unitStart = unit.start.getTime();
                                const unitEnd = unit.end.getTime();
                                const hasWorkdayInUnit = task.dates.some(d => {
                                    const t = d.getTime();
                                    return t >= unitStart && t <= unitEnd;
                                });

                                row.push(hasWorkdayInUnit ? '■' : '');
                            });

                            csv += '"' + row.join('";"') + '"\n';
                        });

                        csv += '\n\n';
                    }

                    // Блок 2: Таблица задач как есть
                    csv += '"Таблица задач"\n';
                    csv += '"№ п/п";"Этап";"Вид контроля";"Мероприятие";"Рабочих дней";"Ответственный";"Дата начала";"Дата окончания"\n';
                    tasks.forEach((task, index) => {
                        const row = [
                            index + 1,
                            task.stage,
                            task.control,
                            task.task,
                            task.days,
                            task.responsible || '',
                            task.startDate.toLocaleDateString('ru-RU'),
                            task.endDate.toLocaleDateString('ru-RU')
                        ].map(value => String(value).replace(/"/g, '""'));
                        csv += '"' + row.join('";"') + '"\n';
                    });

                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = generateExportFileName('csv');
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Закрываем индикатор
                    loadingIndicator.textContent = 'CSV готов!';
                    setTimeout(() => {
                        if (loadingIndicator.parentNode) {
                            document.body.removeChild(loadingIndicator);
                        }
                    }, 3000); // 3 секунды
                } catch (e) {
                    if (loadingIndicator.parentNode) {
                        document.body.removeChild(loadingIndicator);
                    }
                    alert('Не удалось выгрузить файл. Попробуйте ещё раз или откройте страницу с интернетом для полноценного Excel-экспорта.');
                }
                return;
            }

            const wb = XLSX.utils.book_new();

            const selectEl = document.getElementById('excelScaleMode');
            const rawMode = selectEl ? String(selectEl.value || '').toLowerCase() : 'day';
            let scaleMode = 'day';
            if (rawMode.startsWith('week') || rawMode.startsWith('нед')) scaleMode = 'week';
            else if (rawMode.startsWith('month') || rawMode.startsWith('мес')) scaleMode = 'month';
            else if (rawMode.startsWith('year') || rawMode.startsWith('год')) scaleMode = 'year';

            const timelineUnits = buildExportTimeline(scaleMode);

            // Лист 1: Гант в выбранном масштабе
            if (timelineUnits.length) {
                const ganttSheetName = getExportScaleLabel(scaleMode);
                const ganttData = [];

                const headerRow = ['Задача', 'Дата начала', 'Дата окончания', 'Рабочих дней'];
                timelineUnits.forEach(unit => {
                    headerRow.push(unit.label);
                });
                ganttData.push(headerRow);

                tasks.forEach(task => {
                    const row = [
                        task.task,
                        task.startDate ? task.startDate.toLocaleDateString('ru-RU') : '',
                        task.endDate ? task.endDate.toLocaleDateString('ru-RU') : '',
                        task.days
                    ];

                    timelineUnits.forEach(unit => {
                        if (!task.startDate || !task.endDate || !Array.isArray(task.dates)) {
                            row.push('');
                            return;
                        }

                        const unitStart = unit.start.getTime();
                        const unitEnd = unit.end.getTime();
                        const hasWorkdayInUnit = task.dates.some(d => {
                            const t = d.getTime();
                            return t >= unitStart && t <= unitEnd;
                        });

                        row.push(hasWorkdayInUnit ? '■' : '');
                    });

                    ganttData.push(row);
                });

                const ganttWs = XLSX.utils.aoa_to_sheet(ganttData);
                // Настройка ширины столбцов для листа Ганта
                const ganttCols = buildAutoColumnWidths(ganttData);
                
                // Столбец A (индекс 0) - автоматическая ширина по самой длинной строке
                // Находим самую длинную строку в первом столбце
                let maxLength = 0;
                ganttData.forEach(row => {
                    if (row[0] && String(row[0]).length > maxLength) {
                        maxLength = String(row[0]).length;
                    }
                });
                // Устанавливаем ширину столбца A по самой длинной строке + небольшой отступ
                if (ganttCols[0]) {
                    ganttCols[0].wch = Math.max(20, maxLength + 2); // минимум 20, но может быть больше
                }
                
                // Столбец B (индекс 1) - "Дата начала" - ширина 15
                if (ganttCols[1]) ganttCols[1].wch = 15;
                // Столбец C (индекс 2) - "Дата окончания" - ширина 15
                if (ganttCols[2]) ganttCols[2].wch = 15;
                // Столбец D (индекс 3) - "Рабочих дней" - ширина 15
                if (ganttCols[3]) ganttCols[3].wch = 15;
                // Столбцы E и далее (индекс 4+) - диаграмма Ганта - ширина 10
                for (let i = 4; i < ganttCols.length; i++) {
                    if (ganttCols[i]) ganttCols[i].wch = 10;
                }
                ganttWs['!cols'] = ganttCols;

                // Закрашиваем ячейки интервалов Ганта цветом в зависимости от статуса задачи.
                // Колонки интервалов начинаются с индекса 4 (0-based) — после базовых полей.
                const ganttStartCol = 4;

                // Цвета, соответствующие цветам на странице:
                // синий (план), оранжевый (в работе), зелёный (завершено),
                // розовый (ручной выходной), жёлтый (ручной праздник).
                const fillStyles = {
                    pending: {
                        patternType: 'solid',
                        fgColor: { rgb: 'FF1E88E5' },
                        bgColor: { rgb: 'FF1E88E5' }
                    },
                    'in-progress': {
                        patternType: 'solid',
                        fgColor: { rgb: 'FFFF9800' },
                        bgColor: { rgb: 'FFFF9800' }
                    },
                    completed: {
                        patternType: 'solid',
                        fgColor: { rgb: 'FF4CAF50' },
                        bgColor: { rgb: 'FF4CAF50' }
                    },
                    'weekend-manual': {
                        patternType: 'solid',
                        fgColor: { rgb: 'FFFFE0E0' },
                        bgColor: { rgb: 'FFFFE0E0' }
                    }
                };

                // Устанавливаем выравнивание по центру для столбцов B, C, D (индексы 1, 2, 3)
                // Проходим по всем строкам (включая заголовок)
                for (let rowIdx = 0; rowIdx < ganttData.length; rowIdx++) {
                    // Столбец B (индекс 1) - "Дата начала"
                    const addrB = XLSX.utils.encode_cell({ c: 1, r: rowIdx });
                    if (ganttWs[addrB]) {
                        ganttWs[addrB].s = ganttWs[addrB].s || {};
                        ganttWs[addrB].s.alignment = { horizontal: 'center', vertical: 'center' };
                    }
                    // Столбец C (индекс 2) - "Дата окончания"
                    const addrC = XLSX.utils.encode_cell({ c: 2, r: rowIdx });
                    if (ganttWs[addrC]) {
                        ganttWs[addrC].s = ganttWs[addrC].s || {};
                        ganttWs[addrC].s.alignment = { horizontal: 'center', vertical: 'center' };
                    }
                    // Столбец D (индекс 3) - "Рабочих дней"
                    const addrD = XLSX.utils.encode_cell({ c: 3, r: rowIdx });
                    if (ganttWs[addrD]) {
                        ganttWs[addrD].s = ganttWs[addrD].s || {};
                        ganttWs[addrD].s.alignment = { horizontal: 'center', vertical: 'center' };
                    }
                }
                
                // Устанавливаем выравнивание по центру для заголовков столбцов E+ (диаграмма Ганта)
                // Заголовки находятся в первой строке (rowIdx = 0), столбцы начинаются с индекса 4
                for (let colIdx = 4; colIdx < ganttCols.length; colIdx++) {
                    const addr = XLSX.utils.encode_cell({ c: colIdx, r: 0 });
                    if (ganttWs[addr]) {
                        ganttWs[addr].s = ganttWs[addr].s || {};
                        ganttWs[addr].s.alignment = { horizontal: 'center', vertical: 'center' };
                    }
                }

                tasks.forEach((task, taskIdx) => {
                    // В ganttData первая строка (r=0) — заголовок,
                    // далее идут строки задач (r=1 + taskIdx)
                    const excelRow = 1 + taskIdx;
                    timelineUnits.forEach((unit, unitIdx) => {
                        const col = ganttStartCol + unitIdx;
                        const addr = XLSX.utils.encode_cell({ c: col, r: excelRow });
                        const cell = ganttWs[addr];
                        if (!cell || !cell.v) return; // пропускаем пустые ячейки

                        // Определяем статус для данного интервала времени.
                        // Если масштаб = "дни" — строго по конкретным дням, как на Ганте:
                        // берём первый рабочий день интервала и его статус в dateStatuses
                        // (или "pending", если статуса нет). Общий статус задачи не используем.
                        let intervalStatus = 'pending';
                        const unitStart = unit.start.getTime();
                        const unitEnd = unit.end.getTime();

                        if (scaleMode === 'day') {
                            if (Array.isArray(task.dates) && task.dates.length) {
                                const day = task.dates.find(d => {
                                    const t = d.getTime();
                                    return t >= unitStart && t <= unitEnd;
                                });
                                if (day) {
                                    const key = formatDateKey(day);
                                    if (task.dateStatuses && task.dateStatuses[key]) {
                                        intervalStatus = task.dateStatuses[key];
                                    } else {
                                        intervalStatus = 'pending';
                                    }
                                }
                            }
                        } else if (task.dateStatuses) {
                            // Для недель/месяцев/годов агрегируем статусы в интервале
                            const statusesInUnit = new Set();
                            task.dates.forEach(d => {
                                const t = d.getTime();
                                if (t < unitStart || t > unitEnd) return;
                                const key = formatDateKey(d);
                                const s = task.dateStatuses[key];
                                if (s) statusesInUnit.add(s);
                            });

                            // Приоритет: завершено > в работе > выходной > план
                            if (statusesInUnit.has('completed')) intervalStatus = 'completed';
                            else if (statusesInUnit.has('in-progress')) intervalStatus = 'in-progress';
                            else if (statusesInUnit.has('weekend-manual')) intervalStatus = 'weekend-manual';
                            else if (task.status) intervalStatus = task.status;
                            else intervalStatus = 'pending';
                        } else if (task.status) {
                            intervalStatus = task.status;
                        }

                        // Собираем комментарии по датам внутри текущего интервала времени
                        let commentsLines = [];
                        if (task.dateComments) {
                            task.dates.forEach(d => {
                                const t = d.getTime();
                                if (t < unitStart || t > unitEnd) return;
                                const key = formatDateKey(d);
                                const comment = task.dateComments[key];
                                if (comment && comment.trim().length > 0) {
                                    commentsLines.push(`${key}: ${comment.trim()}`);
                                }
                            });
                        }

                        const fill = fillStyles[intervalStatus] || fillStyles.pending;
                        cell.s = cell.s || {};
                        cell.s.fill = fill;
                        cell.s.alignment = cell.s.alignment || { horizontal: 'center', vertical: 'center' };

                        // Если есть комментарии по датам для этого интервала — добавляем их
                        // как комментарий Excel (note), чтобы были видны при наведении в Excel.
                        if (commentsLines.length > 0) {
                            const noteText = commentsLines.join('\n');
                            cell.c = cell.c || [];
                            cell.c.push({ t: noteText });
                        }
                    });
                });

                XLSX.utils.book_append_sheet(wb, ganttWs, ganttSheetName);
            }

            // Лист 2: таблица задач как есть
            const wsData = [
                [`График внедрения и обучения системы ${chartTypeContainerName}`],
                [],
                ['№ п/п', 'Этап', 'Вид контроля', 'Мероприятие', 'Рабочих дней', 'Ответственный', 'Дата начала', 'Дата окончания', 'Комментарии по датам']
            ];

            tasks.forEach((task, index) => {
                let commentsSummary = '';
                if (task.dateComments) {
                    const entries = Object.entries(task.dateComments)
                        .filter(([, text]) => text && String(text).trim().length > 0)
                        .sort(([d1], [d2]) => (d1 < d2 ? -1 : d1 > d2 ? 1 : 0))
                        .map(([date, text]) => `${date}: ${String(text).trim()}`);
                    commentsSummary = entries.join('; ');
                }

                wsData.push([
                    index + 1,
                    task.stage,
                    task.control,
                    task.task,
                    task.days,
                    task.responsible || '',
                    task.startDate.toLocaleDateString('ru-RU'),
                    task.endDate.toLocaleDateString('ru-RU'),
                    commentsSummary
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(wsData);
            // Авто‑подбор ширины столбцов для табличного листа
            const wsCols = buildAutoColumnWidths(wsData);
            // Столбцы "Дата начала" и "Дата окончания" (индексы 6 и 7) фиксируем в ширину 10
            if (wsCols[6]) wsCols[6].wch = 10;
            if (wsCols[7]) wsCols[7].wch = 10;
            ws['!cols'] = wsCols;

            XLSX.utils.book_append_sheet(wb, ws, 'Задачи');

            // Лист со статистикой
            XLSX.writeFile(wb, generateExportFileName('xlsx'));
            
            // Закрываем индикатор
            loadingIndicator.textContent = 'Excel готов!';
            setTimeout(() => {
                if (loadingIndicator.parentNode) {
                    document.body.removeChild(loadingIndicator);
                }
            }, 3000); // 3 секунды
        }

        function openExcelExportModal() {
            const modal = document.getElementById('excelExportModal');
            if (modal) {
                modal.style.display = 'block';
                
                // На мобильных устройствах и планшетах позиционируем модальное окно рядом с кнопкой
                const isMobile = window.innerWidth <= 1024;
                if (isMobile) {
                    // Используем requestAnimationFrame для применения стилей после рендера
                    requestAnimationFrame(() => {
                        // Находим кнопку "Выгрузить в Excel"
                        const buttons = document.querySelectorAll('.btn');
                        let excelButton = null;
                        for (let btn of buttons) {
                            if (btn.textContent && btn.textContent.includes('Выгрузить в Excel')) {
                                excelButton = btn;
                                break;
                            }
                        }
                        
                        if (excelButton) {
                            const modalContent = modal.querySelector('.modal-content');
                            if (modalContent) {
                                const buttonRect = excelButton.getBoundingClientRect();
                                
                                // Позиционируем модальное окно так, чтобы оно было видно рядом с кнопкой
                                // Вычисляем позицию: если кнопка в нижней половине экрана - показываем над ней, иначе - под ней
                                const viewportHeight = window.innerHeight;
                                const buttonBottom = buttonRect.bottom;
                                const spaceBelow = viewportHeight - buttonBottom;
                                const spaceAbove = buttonRect.top;
                                
                                // Вычисляем позицию относительно viewport (так как modal имеет position: fixed)
                                let topPosition;
                                if (spaceBelow < 300 && spaceAbove > spaceBelow) {
                                    // Показываем над кнопкой
                                    topPosition = buttonRect.top - 350; // высота модального окна примерно 350px
                                } else {
                                    // Показываем под кнопкой
                                    topPosition = buttonRect.bottom + 20; // небольшой отступ
                                }
                                
                                // Убеждаемся, что окно не выходит за пределы экрана
                                const minTop = 20;
                                const maxTop = viewportHeight - 400;
                                topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                                
                                // Применяем стили с !important через setProperty для переопределения CSS
                                modalContent.style.setProperty('position', 'absolute', 'important');
                                modalContent.style.setProperty('top', topPosition + 'px', 'important');
                                modalContent.style.setProperty('left', '50%', 'important');
                                modalContent.style.setProperty('transform', 'translateX(-50%)', 'important');
                                modalContent.style.setProperty('margin', '0', 'important');
                                modalContent.style.setProperty('width', 'calc(100% - 40px)', 'important');
                                modalContent.style.setProperty('max-width', '500px', 'important');
                            }
                        }
                    });
                } else {
                    // На десктопе сбрасываем стили (используется стандартное центрирование через CSS)
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.position = '';
                        modalContent.style.top = '';
                        modalContent.style.left = '';
                        modalContent.style.transform = '';
                        modalContent.style.margin = '';
                        modalContent.style.width = '';
                        modalContent.style.maxWidth = '';
                    }
                }
            }
        }

        function closeExcelExportModal() {
            const modal = document.getElementById('excelExportModal');
            if (modal) {
                modal.style.display = 'none';
                // Сбрасываем стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
        }

        function confirmExcelExport() {
            closeExcelExportModal();
            exportExcel();
        }

        function openPDFExportModal() {
            const modal = document.getElementById('pdfExportModal');
            if (modal) {
                modal.style.display = 'block';
                
                // На мобильных устройствах и планшетах позиционируем модальное окно рядом с кнопкой
                const isMobile = window.innerWidth <= 1024;
                if (isMobile) {
                    // Используем requestAnimationFrame для применения стилей после рендера
                    requestAnimationFrame(() => {
                        // Находим кнопку "Выгрузить в PDF"
                        const buttons = document.querySelectorAll('.btn');
                        let pdfButton = null;
                        for (let btn of buttons) {
                            if (btn.textContent && btn.textContent.includes('Выгрузить в PDF')) {
                                pdfButton = btn;
                                break;
                            }
                        }
                        
                        if (pdfButton) {
                            const modalContent = modal.querySelector('.modal-content');
                            if (modalContent) {
                                const buttonRect = pdfButton.getBoundingClientRect();
                                
                                // Позиционируем модальное окно так, чтобы оно было видно рядом с кнопкой
                                // Вычисляем позицию: если кнопка в нижней половине экрана - показываем над ней, иначе - под ней
                                const viewportHeight = window.innerHeight;
                                const buttonBottom = buttonRect.bottom;
                                const spaceBelow = viewportHeight - buttonBottom;
                                const spaceAbove = buttonRect.top;
                                
                                // Вычисляем позицию относительно viewport (так как modal имеет position: fixed)
                                let topPosition;
                                if (spaceBelow < 300 && spaceAbove > spaceBelow) {
                                    // Показываем над кнопкой
                                    topPosition = buttonRect.top - 350; // высота модального окна примерно 350px
                                } else {
                                    // Показываем под кнопкой
                                    topPosition = buttonRect.bottom + 20; // небольшой отступ
                                }
                                
                                // Убеждаемся, что окно не выходит за пределы экрана
                                const minTop = 20;
                                const maxTop = viewportHeight - 400;
                                topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                                
                                // Применяем стили с !important через setProperty для переопределения CSS
                                modalContent.style.setProperty('position', 'absolute', 'important');
                                modalContent.style.setProperty('top', topPosition + 'px', 'important');
                                modalContent.style.setProperty('left', '50%', 'important');
                                modalContent.style.setProperty('transform', 'translateX(-50%)', 'important');
                                modalContent.style.setProperty('margin', '0', 'important');
                                modalContent.style.setProperty('width', 'calc(100% - 40px)', 'important');
                                modalContent.style.setProperty('max-width', '500px', 'important');
                            }
                        }
                    });
                } else {
                    // На десктопе сбрасываем стили (используется стандартное центрирование через CSS)
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.position = '';
                        modalContent.style.top = '';
                        modalContent.style.left = '';
                        modalContent.style.transform = '';
                        modalContent.style.margin = '';
                        modalContent.style.width = '';
                        modalContent.style.maxWidth = '';
                    }
                }
            }
        }

        function closePDFExportModal() {
            const modal = document.getElementById('pdfExportModal');
            if (modal) {
                modal.style.display = 'none';
                // Сбрасываем стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
        }

        function confirmPDFExport() {
            const selectEl = document.getElementById('pdfScaleMode');
            const rawMode = selectEl ? String(selectEl.value || '').toLowerCase() : 'day';
            let scaleMode = 'day';
            if (rawMode.startsWith('week') || rawMode.startsWith('нед')) scaleMode = 'week';
            else if (rawMode.startsWith('month') || rawMode.startsWith('мес')) scaleMode = 'month';
            const modeRadio = document.querySelector('input[name="pdfContentMode"]:checked');
            const includeDiagram = modeRadio ? modeRadio.value !== 'table' : true;
            closePDFExportModal();
            exportPDF(scaleMode, includeDiagram);
        }

        // Изменение даты начала
        function editStartDate() {
            const modal = document.getElementById('editModal');
            const input = document.getElementById('startDateInput');
            input.value = formatDateForInput(startDate);
            modal.style.display = 'block';
        }

        async function updateStartDate() {
            const input = document.getElementById('startDateInput');
            const newDate = parseDateFromInput(input.value);
            
            if (isWorkday(newDate)) {
                startDate = newDate;
                await initializeTasks();
                closeModal();
            } else {
                alert('Пожалуйста, выберите рабочий день');
            }
        }

        function closeModal() {
            document.getElementById('editModal').style.display = 'none';
        }

        // Открыть модальное окно подтверждения сброса плана
        function resetSchedule() {
            if (!canEdit()) {
                return; // Блокируем сброс плана в режиме просмотра
            }
            
            const modal = document.getElementById('resetPlanConfirmModal');
            if (modal) {
                modal.style.display = 'block';
                
                // Добавляем явную обработку кликов на кнопки в модальном окне
                // Используем делегирование событий для надежности
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.addEventListener('click', (e) => {
                        const target = e.target;
                        if (target.classList.contains('btn-primary') && target.textContent.trim().includes('Да')) {
                            e.stopPropagation();
                            e.preventDefault();
                            confirmResetPlan();
                        } else if (target.classList.contains('btn-secondary') && target.textContent.trim().includes('Нет')) {
                            e.stopPropagation();
                            e.preventDefault();
                            cancelResetPlan();
                        }
                    }, true); // Используем capture phase для приоритета
                }
                
                // На мобильных устройствах и планшетах позиционируем модальное окно рядом с кнопкой
                const isMobile = window.innerWidth <= 1024;
                if (isMobile) {
                    // Используем requestAnimationFrame для применения стилей после рендера
                    requestAnimationFrame(() => {
                        // Находим кнопку "Сбросить план"
                        const resetButton = document.querySelector('.reset-plan-btn');
                        
                        if (resetButton) {
                            const modalContent = modal.querySelector('.modal-content');
                            if (modalContent) {
                                const buttonRect = resetButton.getBoundingClientRect();
                                
                                // Позиционируем модальное окно так, чтобы оно было видно рядом с кнопкой
                                // Вычисляем позицию: если кнопка в нижней половине экрана - показываем над ней, иначе - под ней
                                const viewportHeight = window.innerHeight;
                                const buttonBottom = buttonRect.bottom;
                                const spaceBelow = viewportHeight - buttonBottom;
                                const spaceAbove = buttonRect.top;
                                
                                // Вычисляем позицию относительно viewport (так как modal имеет position: fixed)
                                let topPosition;
                                if (spaceBelow < 300 && spaceAbove > spaceBelow) {
                                    // Показываем над кнопкой
                                    topPosition = buttonRect.top - 250; // высота модального окна примерно 250px
                                } else {
                                    // Показываем под кнопкой
                                    topPosition = buttonRect.bottom + 20; // небольшой отступ
                                }
                                
                                // Убеждаемся, что окно не выходит за пределы экрана
                                const minTop = 20;
                                const maxTop = viewportHeight - 300;
                                topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                                
                                // Применяем стили с !important через setProperty для переопределения CSS
                                modalContent.style.setProperty('position', 'absolute', 'important');
                                modalContent.style.setProperty('top', topPosition + 'px', 'important');
                                modalContent.style.setProperty('left', '50%', 'important');
                                modalContent.style.setProperty('transform', 'translateX(-50%)', 'important');
                                modalContent.style.setProperty('margin', '0', 'important');
                                modalContent.style.setProperty('width', 'calc(100% - 40px)', 'important');
                                modalContent.style.setProperty('max-width', '500px', 'important');
                            }
                        }
                    });
                } else {
                    // На десктопе сбрасываем стили (используется стандартное центрирование через CSS)
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.position = '';
                        modalContent.style.top = '';
                        modalContent.style.left = '';
                        modalContent.style.transform = '';
                        modalContent.style.margin = '';
                        modalContent.style.width = '';
                        modalContent.style.maxWidth = '';
                    }
                }
            }
        }

        // Закрыть модальное окно подтверждения сброса плана
        // Функции для работы с модальным окном предупреждения о масштабе
        function openScaleWarning(status, scaleMode, fromTable = false, taskIndex = null) {
            const modal = document.getElementById('scaleWarningModal');
            const warningText = document.getElementById('scaleWarningText');
            if (!modal || !warningText) return;
            
            // Формируем текст предупреждения в зависимости от источника
            if (fromTable) {
                warningText.textContent = 'Вы собираетесь проставить статус для всего срока задачи. Вы уверены, что хотите это сделать?';
                // Сохраняем данные для применения после подтверждения
                pendingStatusFromTable = { status, taskIndex };
                pendingStatusAfterScaleWarning = null;
            } else {
                // Формируем текст предупреждения в зависимости от масштаба
                let scaleText = '';
                if (scaleMode === 'week') {
                    scaleText = 'неделе';
                } else if (scaleMode === 'month') {
                    scaleText = 'месяцу';
                }
                
                warningText.textContent = `Вы собираетесь проставить статус всей ${scaleText}. Вы уверены, что хотите это сделать?`;
                
                // Сохраняем статус для применения после подтверждения
                pendingStatusAfterScaleWarning = status;
                pendingStatusFromTable = null;
            }
            
            // Убеждаемся, что модальное окно находится в body (не внутри других элементов)
            if (modal.parentElement !== document.body) {
                document.body.appendChild(modal);
            }
            
            // Устанавливаем стили для полного покрытия всего экрана
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100vw';
            modal.style.height = '100vh';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
            modal.style.zIndex = '10002';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.overflow = 'auto';
            modal.style.padding = '20px';
            modal.style.boxSizing = 'border-box';
            modal.classList.add('show');
            
            // Прокручиваем модальное окно к началу для отображения в видимой зоне
            modal.scrollTop = 0;
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.scrollTop = 0;
                // Сбрасываем все кастомные стили позиционирования контента для центрирования
                modalContent.style.position = '';
                modalContent.style.top = '';
                modalContent.style.left = '';
                modalContent.style.transform = '';
                modalContent.style.margin = '';
                modalContent.style.width = '';
                modalContent.style.maxWidth = '';
            }
            
            // Прокручиваем страницу к верху для корректного отображения
            window.scrollTo(0, 0);
            if (document.documentElement) {
                document.documentElement.scrollTop = 0;
            }
            if (document.body) {
                document.body.scrollTop = 0;
            }
        }
        
        function cancelScaleWarning() {
            const modal = document.getElementById('scaleWarningModal');
            if (modal) {
                modal.classList.remove('show');
                modal.style.display = 'none';
                // Сбрасываем все стили позиционирования
                modal.style.position = '';
                modal.style.top = '';
                modal.style.left = '';
                modal.style.width = '';
                modal.style.height = '';
                modal.style.backgroundColor = '';
                modal.style.zIndex = '';
                modal.style.alignItems = '';
                modal.style.justifyContent = '';
                modal.style.overflow = '';
                modal.style.padding = '';
                modal.style.boxSizing = '';
                // Сбрасываем стили позиционирования контента
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
            pendingStatusAfterScaleWarning = null;
            pendingStatusFromTable = null;
            closeStatusMenu();
        }
        
        function confirmScaleWarning() {
            const modal = document.getElementById('scaleWarningModal');
            if (modal) {
                modal.classList.remove('show');
                modal.style.display = 'none';
                // Сбрасываем все стили позиционирования
                modal.style.position = '';
                modal.style.top = '';
                modal.style.left = '';
                modal.style.width = '';
                modal.style.height = '';
                modal.style.backgroundColor = '';
                modal.style.zIndex = '';
                modal.style.alignItems = '';
                modal.style.justifyContent = '';
                modal.style.overflow = '';
                modal.style.padding = '';
                modal.style.boxSizing = '';
            }
            
            // Обработка статуса из таблицы
            if (pendingStatusFromTable) {
                const { status, taskIndex } = pendingStatusFromTable;
                pendingStatusFromTable = null;
                
                // Применяем статус к задаче из таблицы
                applyStatusFromTable(status, taskIndex);
                return;
            }
            
            // Обработка статуса из масштаба (неделя/месяц)
            if (pendingStatusAfterScaleWarning) {
                const status = pendingStatusAfterScaleWarning;
                pendingStatusAfterScaleWarning = null;
                
                // Применяем статус
                // Если статус требует комментария, открываем модальное окно комментария
                if (status === 'in-progress' || status === 'completed') {
                    pendingStatusForComment = status;
                    openStatusCommentModal();
                } else {
                    applyStatusToSelection(status);
                }
            }
        }
        
        // Применение статуса к задаче из таблицы после подтверждения предупреждения
        function applyStatusFromTable(status, taskIndex) {
            const task = tasks[taskIndex];
            if (!task) return;
            
            // Сохраняем состояние в историю перед изменением статуса
            addToUndoHistory();
            
            // Обновляем статус задачи
            task.status = status;
            
            // Применяем статус ко всем датам задачи
            task.dateStatuses = {};
            if (status === 'in-progress' || status === 'completed') {
                task.dates.forEach(d => {
                    const key = formatDateKey(d);
                    task.dateStatuses[key] = status;
                });
            }
            
            // Обновляем значение в select
            const statusSelect = document.querySelector(`select[data-index="${taskIndex}"][data-field="status"]`);
            if (statusSelect) {
                statusSelect.value = status;
            }
            
            // Обновляем отображение
            updateStatistics();
            if (currentView === 'gantt') {
                renderGantt();
            }
            renderTable();
            
            // Немедленное сохранение для критических операций (статусы)
            console.log('💾 Критическое изменение: статус из таблицы, сохраняем немедленно');
            saveFullGanttState();
        }

        function cancelResetPlan() {
            const modal = document.getElementById('resetPlanConfirmModal');
            if (modal) {
                modal.style.display = 'none';
                // Сбрасываем стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
        }

        // Подтвердить сброс плана к дефолтному состоянию
        async function confirmResetPlan() {
            if (!canEdit()) {
                return; // Блокируем сброс плана в режиме просмотра
            }
            
            // Сохраняем текущее состояние в историю отмены перед сбросом
            // Это позволит откатить сброс через кнопку "назад"
            console.log('💾 Сохраняем текущее состояние в историю отмены перед сбросом');
            addToUndoHistory();
            
            // Устанавливаем флаг, что последнее действие было сбросом плана
            lastActionWasReset = true;
            
            startDate = new Date(INITIAL_START_DATE);
            
            // Пытаемся загрузить скелет с сервера перед инициализацией
            await loadSkeletonFromServer();
            
            await initializeTasks();
            renderGantt();
            renderTable();
            updateStatistics();
            autoSaveGanttState(); // Автоматическое сохранение после сброса
            cancelResetPlan(); // Закрываем модальное окно
        }
        

        function toggleView() {
            currentView = currentView === 'gantt' ? 'table' : 'gantt';
            updateViewToggleUI();
            updateViewPanelsUI();
        }

        // Переключение режима отображения баров в Ганте: точки по дням / слитные полосы
        function toggleLinkColumn() {
            showLink = !showLink;

            const btn = document.getElementById('linkToggleBtn');
            if (btn) {
                if (showLink) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }

            // Управляем классом на body для отображения/скрытия колонки в таблице
            if (showLink) {
                document.body.classList.add('show-link');
            } else {
                document.body.classList.remove('show-link');
            }

            // Сохраняем текущую позицию прокрутки и активный элемент перед перерисовкой
            const scrollY = window.scrollY || window.pageYOffset;
            const scrollX = window.scrollX || window.pageXOffset;
            const chartContainer = document.getElementById('ganttChart');
            const chartScrollTop = chartContainer ? chartContainer.scrollTop : 0;
            const chartScrollLeft = chartContainer ? chartContainer.scrollLeft : 0;
            
            // Сохраняем активный элемент и убираем фокус, чтобы предотвратить автоматическую прокрутку
            const activeElement = document.activeElement;
            const activeElementInfo = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') 
                ? { element: activeElement, selectionStart: activeElement.selectionStart, selectionEnd: activeElement.selectionEnd }
                : null;
            
            if (activeElementInfo) {
                activeElementInfo.element.blur();
            }

            renderGantt();
            renderTable();
            
            // Восстанавливаем позицию прокрутки сразу, без задержки
            window.scrollTo(scrollX, scrollY);
            const newChartContainer = document.getElementById('ganttChart');
            if (newChartContainer) {
                newChartContainer.scrollTop = chartScrollTop;
                newChartContainer.scrollLeft = chartScrollLeft;
            }
            
            // Восстанавливаем фокус на элемент, если он все еще существует (без прокрутки)
            if (activeElementInfo && document.contains(activeElementInfo.element)) {
                requestAnimationFrame(() => {
                    try {
                        activeElementInfo.element.focus({ preventScroll: true });
                        if (activeElementInfo.element.setSelectionRange && 
                            activeElementInfo.selectionStart !== null && 
                            activeElementInfo.selectionEnd !== null) {
                            activeElementInfo.element.setSelectionRange(
                                activeElementInfo.selectionStart, 
                                activeElementInfo.selectionEnd
                            );
                        }
                    } catch (e) {
                        // Игнорируем ошибки при восстановлении фокуса
                    }
                });
            }
        }

        function toggleResponsibleColumn() {
            showResponsible = !showResponsible;

            const btn = document.getElementById('responsibleToggleBtn');
            if (btn) {
                if (showResponsible) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }

            // Управляем классом на body для отображения/скрытия колонки в таблице
            if (showResponsible) {
                document.body.classList.add('show-responsible');
            } else {
                document.body.classList.remove('show-responsible');
            }

            // Сохраняем текущую позицию прокрутки и активный элемент перед перерисовкой
            const scrollY = window.scrollY || window.pageYOffset;
            const scrollX = window.scrollX || window.pageXOffset;
            const chartContainer = document.getElementById('ganttChart');
            const chartScrollTop = chartContainer ? chartContainer.scrollTop : 0;
            const chartScrollLeft = chartContainer ? chartContainer.scrollLeft : 0;
            
            // Сохраняем активный элемент и убираем фокус, чтобы предотвратить автоматическую прокрутку
            const activeElement = document.activeElement;
            const activeElementInfo = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') 
                ? { element: activeElement, selectionStart: activeElement.selectionStart, selectionEnd: activeElement.selectionEnd }
                : null;
            
            if (activeElementInfo) {
                activeElementInfo.element.blur();
            }

            renderGantt();
            renderTable();
            
            // Восстанавливаем позицию прокрутки сразу, без задержки
            window.scrollTo(scrollX, scrollY);
            const newChartContainer = document.getElementById('ganttChart');
            if (newChartContainer) {
                newChartContainer.scrollTop = chartScrollTop;
                newChartContainer.scrollLeft = chartScrollLeft;
            }
            
            // Восстанавливаем фокус на элемент, если он все еще существует (без прокрутки)
            if (activeElementInfo && document.contains(activeElementInfo.element)) {
                requestAnimationFrame(() => {
                    try {
                        activeElementInfo.element.focus({ preventScroll: true });
                        if (activeElementInfo.element.setSelectionRange && 
                            activeElementInfo.selectionStart !== null && 
                            activeElementInfo.selectionEnd !== null) {
                            activeElementInfo.element.setSelectionRange(
                                activeElementInfo.selectionStart, 
                                activeElementInfo.selectionEnd
                            );
                        }
                    } catch (e) {
                        // Игнорируем ошибки при восстановлении фокуса
                    }
                });
            }
        }

        function toggleGanttBarStyle() {
            ganttBarStyle = ganttBarStyle === 'dots' ? 'segments' : 'dots';

            const btn = document.getElementById('ganttStyleToggleBtn');
            if (btn) {
                const labelSpan = btn.querySelector('span');
                if (ganttBarStyle === 'segments') {
                    // Активирован общий вид (сплошные полосы)
                    btn.classList.add('active');
                    if (labelSpan) labelSpan.textContent = 'Общий вид';
                } else {
                    // Детальный вид по дням — неактивное состояние кнопки
                    btn.classList.remove('active');
                    if (labelSpan) labelSpan.textContent = 'Детальный вид';
                }
            }

            // Переключаем класс на body, чтобы применились специальные стили для полос.
            // Не используем второй аргумент у classList.toggle для совместимости с более старыми браузерами.
            if (ganttBarStyle === 'segments') {
                document.body.classList.add('gantt-style-segments');
            } else {
                document.body.classList.remove('gantt-style-segments');
            }

            renderGantt();
        }

        function updateViewToggleUI() {
            const ganttPart = document.querySelector('.view-toggle-gantt');
            const tablePart = document.querySelector('.view-toggle-table');
            if (!ganttPart || !tablePart) return;

            if (currentView === 'gantt') {
                ganttPart.classList.add('active');
                tablePart.classList.remove('active');
            } else {
                ganttPart.classList.remove('active');
                tablePart.classList.add('active');
            }
        }

        function updateViewPanelsUI() {
            const chartContainer = document.querySelector('.chart-container');
            const tableSection = document.querySelector('.table-section');
            if (!chartContainer || !tableSection) return;

            if (currentView === 'gantt') {
                // Сначала показываем Гант сразу, чтобы не было моргания
                chartContainer.classList.remove('view-hidden');
                chartContainer.classList.add('view-active');
                
                // Затем скрываем таблицу
                tableSection.classList.remove('view-active');
                tableSection.classList.add('view-hidden');
            } else {
                // Сначала показываем таблицу сразу, чтобы не было моргания
                tableSection.classList.remove('view-hidden');
                tableSection.classList.add('view-active');
                
                // Затем скрываем Гант
                chartContainer.classList.remove('view-active');
                chartContainer.classList.add('view-hidden');
            }
        }

        // --- Настройка этапов ---

        function openStageSettingsModal(event) {
            // Блокируем открытие модального окна в режиме просмотра
            if (!canEdit()) {
                return;
            }
            buildStageSettingsList();
            const modal = document.getElementById('stageSettingsModal');
            if (!modal) return;
            
            // Получаем кнопку, которая была нажата
            const button = event ? (event.currentTarget || event.target) : document.querySelector('.stage-settings-btn');
            
            modal.style.display = 'block';
            
            // Для мобильных и планшетов позиционируем модальное окно рядом с кнопкой
            const isMobile = window.innerWidth <= 1024;
            if (isMobile && button) {
                // Двойной requestAnimationFrame для гарантии, что контент отрендерился
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const modalContent = modal.querySelector('.modal-content');
                        if (!modalContent) return;
                        
                        const buttonRect = button.getBoundingClientRect();
                        const viewportHeight = window.innerHeight;
                        const viewportWidth = window.innerWidth;
                        
                        // Получаем реальные размеры модального окна после рендера
                        const modalRect = modalContent.getBoundingClientRect();
                        const modalHeight = modalRect.height || 400; // Примерная высота по умолчанию
                        const modalWidth = Math.min(modalRect.width || 500, viewportWidth - 40);
                        
                        // Вычисляем пространство сверху и снизу от кнопки
                        const spaceBelow = viewportHeight - buttonRect.bottom;
                        const spaceAbove = buttonRect.top;
                        
                        // Определяем, где больше места - сверху или снизу
                        let topPosition;
                        if (spaceBelow < modalHeight + 20 && spaceAbove > spaceBelow) {
                            // Показываем над кнопкой
                            topPosition = buttonRect.top - modalHeight - 20;
                        } else {
                            // Показываем под кнопкой
                            topPosition = buttonRect.bottom + 20;
                        }
                        
                        // Убеждаемся, что окно не выходит за пределы экрана
                        const minTop = 20;
                        const maxTop = viewportHeight - modalHeight - 20;
                        topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                        
                        // Центрируем по горизонтали
                        const leftPosition = (viewportWidth - modalWidth) / 2;
                        
                        // Применяем позиционирование
                        modalContent.style.setProperty('position', 'fixed', 'important');
                        modalContent.style.setProperty('top', topPosition + 'px', 'important');
                        modalContent.style.setProperty('left', leftPosition + 'px', 'important');
                        modalContent.style.setProperty('transform', 'none', 'important');
                        modalContent.style.setProperty('margin', '0', 'important');
                        modalContent.style.setProperty('width', 'calc(100% - 40px)', 'important');
                        modalContent.style.setProperty('max-width', '500px', 'important');
                    });
                });
            } else {
                // На десктопе сбрасываем стили и используем стандартное центрирование
                requestAnimationFrame(() => {
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.removeProperty('position');
                        modalContent.style.removeProperty('top');
                        modalContent.style.removeProperty('left');
                        modalContent.style.removeProperty('transform');
                        modalContent.style.removeProperty('margin');
                        modalContent.style.removeProperty('width');
                        modalContent.style.removeProperty('max-width');
                    }
                });
            }
        }

        function closeStageSettingsModal() {
            const modal = document.getElementById('stageSettingsModal');
            if (modal) {
                modal.style.display = 'none';
                
                // Сбрасываем все стили позиционирования при закрытии
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.removeProperty('position');
                    modalContent.style.removeProperty('top');
                    modalContent.style.removeProperty('left');
                    modalContent.style.removeProperty('transform');
                    modalContent.style.removeProperty('margin');
                    modalContent.style.removeProperty('width');
                    modalContent.style.removeProperty('max-width');
                }
            }

            // При выходе из режима редактирования этапов всегда включаем "Все этапы"
            currentStageFilter = 'all';
            renderStageTabs();
            renderGantt();
            renderTable();
            applySelectionHighlight();
        }

        function openStageDeleteModal(shortName) {
            pendingStageToDelete = shortName;
            const modal = document.getElementById('stageDeleteModal');
            const text = document.getElementById('stageDeleteText');
            if (text && shortName) {
                text.textContent = `Вы действительно хотите удалить этап "${shortName}" со всеми его задачами?`;
            }
            if (modal) {
                modal.style.display = 'block';
            }
        }

        function openRenameStageModal(shortName) {
            pendingStageToRename = shortName;
            const modal = document.getElementById('renameStageModal');
            const input = document.getElementById('renameStageInput');
            if (input && shortName) {
                input.value = shortName;
            }
            if (modal) {
                modal.style.display = 'block';
                // Фокус на input и выделение текста
                setTimeout(() => {
                    if (input) {
                        input.focus();
                        input.select();
                    }
                }, 100);
            }
        }

        function closeRenameStageModal() {
            const modal = document.getElementById('renameStageModal');
            if (modal) {
                modal.style.display = 'none';
            }
            pendingStageToRename = null;
            const input = document.getElementById('renameStageInput');
            if (input) {
                input.value = '';
            }
        }

        function confirmRenameStage() {
            if (!pendingStageToRename) return;
            const input = document.getElementById('renameStageInput');
            if (!input) return;
            
            const newName = input.value.trim();
            if (!newName || newName === pendingStageToRename) {
                closeRenameStageModal();
                return;
            }
            
            renameStage(pendingStageToRename, newName);
            closeRenameStageModal();
        }

        // Закрытие модального окна переименования этапа при клике вне его
        window.addEventListener('click', (event) => {
            const modal = document.getElementById('renameStageModal');
            if (modal && event.target === modal) {
                closeRenameStageModal();
            }
        });

        // Закрытие модального окна переименования этапа по Escape
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                const modal = document.getElementById('renameStageModal');
                if (modal && modal.style.display === 'block') {
                    closeRenameStageModal();
                }
            }
        });

        // Сохранение по Enter в поле ввода названия этапа
        document.addEventListener('keydown', (event) => {
            const modal = document.getElementById('renameStageModal');
            if (modal && modal.style.display === 'block') {
                const input = document.getElementById('renameStageInput');
                if (input && document.activeElement === input) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        confirmRenameStage();
                    }
                }
            }
        });

        function openStatusCommentModal() {
            const modal = document.getElementById('statusCommentModal');
            const input = document.getElementById('statusCommentInput');
            if (!modal || !input || !pendingStatusForComment) return;
            
            // Прячем меню, но не сбрасываем currentStatusTarget,
            // чтобы после ввода комментария статус применился к нужным датам.
            const menu = document.getElementById('statusMenu');
            if (menu) {
                menu.style.display = 'none';
            }
            
            // Сохраняем текущую цель статуса в отдельный снапшот,
            // чтобы применить её даже если currentStatusTarget где-то обнулится.
            if (currentStatusTarget && currentStatusTarget.isMultiple) {
                // Для множественного выбора сохраняем полный объект
                window.__statusCommentTargetSnapshot = {
                    isMultiple: true,
                    cells: [...currentStatusTarget.cells],
                    groupedByTask: { ...currentStatusTarget.groupedByTask }
                };
            } else {
                window.__statusCommentTargetSnapshot = currentStatusTarget ? {
                    taskId: currentStatusTarget.taskId,
                    dateStrs: Array.isArray(currentStatusTarget.dateStrs)
                        ? [...currentStatusTarget.dateStrs]
                        : [currentStatusTarget.dateStrs]
                } : null;
            }
            
            input.value = '';
            
            // Убеждаемся, что модальное окно находится в body (не внутри других элементов)
            if (modal.parentElement !== document.body) {
                document.body.appendChild(modal);
            }
            
            // Устанавливаем стили для полного покрытия экрана
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100vw';
            modal.style.height = '100vh';
            modal.style.zIndex = '10000';
            modal.style.overflow = 'auto';
            
            // Сбрасываем все кастомные стили позиционирования контента
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.position = '';
                modalContent.style.top = '';
                modalContent.style.left = '';
                modalContent.style.transform = '';
                modalContent.style.margin = '';
                modalContent.style.width = '';
                modalContent.style.maxWidth = '';
                modalContent.style.maxHeight = '';
            }
            
            // Сбрасываем стили модального окна для центрирования
            modal.style.alignItems = '';
            modal.style.justifyContent = '';
            
            // Прокручиваем страницу к верху - используем все возможные способы
            window.scrollTo(0, 0);
            if (document.documentElement) {
                document.documentElement.scrollTop = 0;
                document.documentElement.scrollLeft = 0;
            }
            if (document.body) {
                document.body.scrollTop = 0;
                document.body.scrollLeft = 0;
            }
            
            // Прокручиваем все возможные скроллируемые контейнеры
            const scrollableElements = document.querySelectorAll('.gantt-chart, .chart-container, .tasks-table-wrapper, [style*="overflow"]');
            scrollableElements.forEach(el => {
                if (el.scrollTop !== undefined) {
                    el.scrollTop = 0;
                }
            });
            
            // Используем 'flex' для центрирования
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            
            // Прокручиваем модальное окно в начало для корректного отображения
            modal.scrollTop = 0;
            modal.scrollLeft = 0;
            
            // Дополнительная проверка через небольшую задержку для гарантии прокрутки
            setTimeout(() => {
                // Еще раз прокручиваем на всякий случай
                window.scrollTo(0, 0);
                if (document.documentElement) {
                    document.documentElement.scrollTop = 0;
                }
                if (document.body) {
                    document.body.scrollTop = 0;
                }
                
                // Прокручиваем все скроллируемые контейнеры еще раз
                scrollableElements.forEach(el => {
                    if (el.scrollTop !== undefined) {
                        el.scrollTop = 0;
                    }
                });
                
                modal.scrollTop = 0;
                if (modalContent) {
                    modalContent.scrollTop = 0;
                }
                input.focus();
            }, 100);
        }

        function confirmStatusComment() {
            const modal = document.getElementById('statusCommentModal');
            const input = document.getElementById('statusCommentInput');
            if (!modal || !input || !pendingStatusForComment) return;
            const text = input.value || '';
            const status = pendingStatusForComment;
            pendingStatusForComment = null;
            modal.style.display = 'none';
            
            // Сбрасываем все стили позиционирования
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.position = '';
                modalContent.style.top = '';
                modalContent.style.left = '';
                modalContent.style.transform = '';
                modalContent.style.margin = '';
                modalContent.style.width = '';
                modalContent.style.maxWidth = '';
                modalContent.style.maxHeight = '';
            }
            
            // Сбрасываем все стили модального окна
            modal.style.position = '';
            modal.style.top = '';
            modal.style.left = '';
            modal.style.width = '';
            modal.style.height = '';
            modal.style.zIndex = '';
            modal.style.overflow = '';
            modal.style.alignItems = '';
            modal.style.justifyContent = '';
            
            const targetSnapshot = window.__statusCommentTargetSnapshot || null;
            applyStatusToSelection(status, text, targetSnapshot);
        }

        function cancelStatusComment() {
            const modal = document.getElementById('statusCommentModal');
            if (modal) {
                modal.style.display = 'none';
                
                // Сбрасываем все стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                    modalContent.style.maxHeight = '';
                }
                
                // Сбрасываем все стили модального окна
                modal.style.position = '';
                modal.style.top = '';
                modal.style.left = '';
                modal.style.width = '';
                modal.style.height = '';
                modal.style.zIndex = '';
                modal.style.overflow = '';
                modal.style.alignItems = '';
                modal.style.justifyContent = '';
            }
            pendingStatusForComment = null;
        }

        // Переменная для хранения ссылки на исходный input
        let currentTextInputElement = null;

        // Функция открытия модального окна для ввода текста
        function openTextInputModal(inputElement) {
            console.log('🔍 openTextInputModal вызвана', inputElement);
            
            if (!canEdit()) {
                console.log('❌ Режим редактирования недоступен');
                return;
            }
            
            if (!inputElement) {
                console.log('❌ inputElement не передан');
                return;
            }
            
            currentTextInputElement = inputElement;
            const modal = document.getElementById('textInputModal');
            const textarea = document.getElementById('textInputModalTextarea');
            const title = document.getElementById('textInputModalTitle');
            const label = document.getElementById('textInputModalLabel');
            
            if (!modal) {
                console.error('❌ Модальное окно textInputModal не найдено в DOM');
                return;
            }
            
            if (!textarea) {
                console.error('❌ textarea textInputModalTextarea не найдено в DOM');
                return;
            }
            
            console.log('✅ Модальное окно найдено, открываем...');
            console.log('📋 Текущее значение поля:', inputElement.value);
            console.log('📋 data-field:', inputElement.getAttribute('data-field'));
            
            // Получаем название поля из data-field
            const fieldName = inputElement.getAttribute('data-field');
            const fieldLabels = {
                'stageSuffix': 'Этап',
                'taskTitle': 'Мероприятие',
                'control': 'Вид контроля',
                'responsible': 'Ответственный'
            };
            
            const fieldLabel = fieldLabels[fieldName] || 'Поле';
            title.textContent = `Редактирование: ${fieldLabel}`;
            label.textContent = `Введите текст для "${fieldLabel}":`;
            
            // Устанавливаем текущее значение
            textarea.value = inputElement.value || '';
            
            // Показываем модальное окно
            modal.style.display = 'block';
            
            // Позиционируем модальное окно рядом с input полем
            requestAnimationFrame(() => {
                const modalContent = modal.querySelector('.modal-content');
                if (!modalContent) return;
                
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                const isMobile = window.innerWidth <= 1024;
                
                // Примерные размеры модального окна (будут скорректированы после отображения)
                const estimatedModalWidth = isMobile ? Math.min(500, viewportWidth - 40) : 500;
                const estimatedModalHeight = 280;
                
                // Получаем координаты input поля
                const rect = inputElement.getBoundingClientRect();
                const inputTop = rect.top;
                const inputLeft = rect.left;
                const inputRight = rect.right;
                const inputBottom = rect.bottom;
                
                // Определяем доступное пространство
                const spaceBelow = viewportHeight - inputBottom;
                const spaceAbove = inputTop;
                const spaceRight = viewportWidth - inputRight;
                const spaceLeft = inputLeft;
                
                let topPosition, leftPosition;
                
                // Вертикальное позиционирование: стараемся разместить ниже input
                if (spaceBelow >= estimatedModalHeight + 20) {
                    // Размещаем ниже input
                    topPosition = inputBottom + 10;
                } else if (spaceAbove >= estimatedModalHeight + 20) {
                    // Размещаем выше input
                    topPosition = inputTop - estimatedModalHeight - 10;
                } else {
                    // Недостаточно места - размещаем по центру экрана вертикально
                    topPosition = Math.max(20, (viewportHeight - estimatedModalHeight) / 2);
                }
                
                // Горизонтальное позиционирование: стараемся разместить справа от input
                if (spaceRight >= estimatedModalWidth + 20) {
                    // Размещаем справа от input
                    leftPosition = inputRight + 10;
                } else if (spaceLeft >= estimatedModalWidth + 20) {
                    // Размещаем слева от input
                    leftPosition = inputLeft - estimatedModalWidth - 10;
                } else {
                    // Недостаточно места - центрируем по горизонтали
                    leftPosition = (viewportWidth - estimatedModalWidth) / 2;
                }
                
                // Ограничиваем позицию границами viewport
                const minTop = 20;
                const maxTop = viewportHeight - estimatedModalHeight - 20;
                topPosition = Math.max(minTop, Math.min(topPosition, maxTop));
                
                const minLeft = 20;
                const maxLeft = viewportWidth - estimatedModalWidth - 20;
                leftPosition = Math.max(minLeft, Math.min(leftPosition, maxLeft));
                
                // Применяем позиционирование
                modalContent.style.setProperty('position', 'fixed', 'important');
                modalContent.style.setProperty('top', topPosition + 'px', 'important');
                modalContent.style.setProperty('left', leftPosition + 'px', 'important');
                modalContent.style.setProperty('transform', 'none', 'important');
                modalContent.style.setProperty('margin', '0', 'important');
                modalContent.style.setProperty('width', isMobile ? 'calc(100% - 40px)' : estimatedModalWidth + 'px', 'important');
                modalContent.style.setProperty('max-width', isMobile ? '500px' : '600px', 'important');
                modalContent.style.setProperty('z-index', '10001', 'important');
                
                // После отображения корректируем позицию с учетом реальных размеров
                setTimeout(() => {
                    const actualRect = modalContent.getBoundingClientRect();
                    const actualHeight = actualRect.height;
                    const actualWidth = actualRect.width;
                    
                    // Пересчитываем вертикальную позицию, если нужно
                    if (topPosition + actualHeight > viewportHeight - 20) {
                        topPosition = Math.max(20, viewportHeight - actualHeight - 20);
                        modalContent.style.setProperty('top', topPosition + 'px', 'important');
                    }
                    
                    // Пересчитываем горизонтальную позицию, если нужно
                    if (leftPosition + actualWidth > viewportWidth - 20) {
                        leftPosition = Math.max(20, viewportWidth - actualWidth - 20);
                        modalContent.style.setProperty('left', leftPosition + 'px', 'important');
                    }
                }, 10);
            });
            
            // Фокусируемся на textarea
            setTimeout(() => {
                textarea.focus();
                textarea.select();
            }, 100);
        }

        // Функция сохранения текста из модального окна
        function saveTextInputModal() {
            if (!currentTextInputElement) return;
            
            const modal = document.getElementById('textInputModal');
            const textarea = document.getElementById('textInputModalTextarea');
            
            if (!modal || !textarea) return;
            
            // Обновляем значение в исходном input
            currentTextInputElement.value = textarea.value;
            
            // Вызываем обработчик изменения для синхронизации данных
            const changeEvent = new Event('change', { bubbles: true });
            currentTextInputElement.dispatchEvent(changeEvent);
            
            // Закрываем модальное окно
            closeTextInputModal();
        }

        // Функция закрытия модального окна ввода текста
        function closeTextInputModal() {
            const modal = document.getElementById('textInputModal');
            if (modal) {
                modal.style.display = 'none';
                // Сбрасываем стили позиционирования
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.top = '';
                    modalContent.style.left = '';
                    modalContent.style.transform = '';
                    modalContent.style.margin = '';
                    modalContent.style.width = '';
                    modalContent.style.maxWidth = '';
                }
            }
            currentTextInputElement = null;
        }

        // Закрытие модального окна при клике вне его
        window.addEventListener('click', (event) => {
            const modal = document.getElementById('textInputModal');
            if (modal && event.target === modal) {
                closeTextInputModal();
            }
        });

        // Закрытие модального окна по Escape
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                const modal = document.getElementById('textInputModal');
                if (modal && modal.style.display === 'block') {
                    closeTextInputModal();
                }
            }
        });

        // Сохранение по Enter (Ctrl+Enter или просто Enter в textarea)
        document.addEventListener('keydown', (event) => {
            const modal = document.getElementById('textInputModal');
            if (modal && modal.style.display === 'block') {
                const textarea = document.getElementById('textInputModalTextarea');
                if (textarea && document.activeElement === textarea) {
                    if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
                        event.preventDefault();
                        saveTextInputModal();
                    }
                }
            }
        });

        function cancelDeleteStage() {
            const modal = document.getElementById('stageDeleteModal');
            if (modal) {
                modal.style.display = 'none';
            }
            pendingStageToDelete = null;
        }

        function confirmDeleteStage() {
            if (!canEdit()) {
                return; // Блокируем удаление этапов в режиме просмотра
            }
            if (pendingStageToDelete) {
                deleteStage(pendingStageToDelete);
            }
            cancelDeleteStage();
        }

        function buildStageSettingsList() {
            const list = document.getElementById('stageSettingsList');
            if (!list) return;
            list.innerHTML = '';

            stageConfig.forEach((shortName, index) => {
                const item = document.createElement('div');
                item.className = 'stage-settings-item';
                item.draggable = canEdit(); // Блокируем drag&drop этапов в режиме просмотра
                item.dataset.index = String(index);

                item.addEventListener('dragstart', () => {
                    if (!canEdit()) {
                        return;
                    }
                    draggedStageIndex = index;
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', () => {
                    draggedStageIndex = null;
                    item.classList.remove('dragging');
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                item.addEventListener('drop', (e) => {
                    if (!canEdit()) {
                        e.preventDefault();
                        return;
                    }
                    e.preventDefault();
                    if (draggedStageIndex === null) return;
                    const targetIndex = parseInt(item.dataset.index, 10);
                    if (targetIndex === draggedStageIndex) return;

                    const [moved] = stageConfig.splice(draggedStageIndex, 1);
                    stageConfig.splice(targetIndex, 0, moved);
                    draggedStageIndex = null;

                    buildStageSettingsList();
                    renderStageTabs();
                });

                const left = document.createElement('div');
                left.className = 'stage-settings-left';

                const handle = document.createElement('div');
                handle.className = 'stage-settings-handle';
                handle.textContent = '≡';

                const nameEl = document.createElement('div');
                nameEl.className = 'stage-settings-name';
                nameEl.textContent = shortName;
                nameEl.title = 'Двойной клик, чтобы переименовать';

                // Обработчик двойного клика на всей строке (но не на кнопке удаления)
                item.addEventListener('dblclick', (e) => {
                    // Игнорируем двойной клик на кнопке удаления
                    if (e.target.closest('.stage-settings-delete-btn')) {
                        return;
                    }
                    // Игнорируем двойной клик во время drag
                    if (item.classList.contains('dragging')) {
                        return;
                    }
                    // Блокируем переименование в режиме просмотра
                    if (!canEdit()) {
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                    openRenameStageModal(shortName);
                });

                left.appendChild(handle);
                left.appendChild(nameEl);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'stage-settings-delete-btn';
                deleteBtn.type = 'button';
                deleteBtn.innerHTML = '<span>✕</span><span>Удалить</span>';
                deleteBtn.addEventListener('click', () => {
                    if (!canEdit()) {
                        return; // Блокируем удаление этапов в режиме просмотра
                    }
                    openStageDeleteModal(shortName);
                });

                item.appendChild(left);
                item.appendChild(deleteBtn);

                list.appendChild(item);
            });
        }

        async function deleteStage(shortName) {
            stageConfig = stageConfig.filter(name => name !== shortName);
            projectData = projectData.filter(item => !item.stage || !item.stage.startsWith(shortName));

            if (currentStageFilter === shortName) {
                currentStageFilter = 'all';
            }

            await initializeTasks();
            renderStageTabs();
            buildStageSettingsList();
        }

        async function addNewStage() {
            // Блокируем добавление этапа в режиме просмотра
            if (!canEdit()) {
                return;
            }
            let maxNumber = 0;
            stageConfig.forEach(name => {
                const match = name.match(/^Этап\s+(\d+)/);
                if (match) {
                    const num = parseInt(match[1], 10);
                    if (num > maxNumber) maxNumber = num;
                }
            });

            const newNumber = maxNumber + 1 || 1;
            const shortName = `Этап ${newNumber}`;
            stageConfig.push(shortName);

            // Добавляем одну пустую задачу для нового этапа
            projectData.push({
                stage: `${shortName}. Новый этап`,
                control: '',
                task: '',
                days: 1,
                substage: ''
            });

            currentStageFilter = shortName;
            await initializeTasks();
            renderStageTabs();
            buildStageSettingsList();
        }

        async function renameStage(oldShortName, newShortName) {
            stageConfig = stageConfig.map(name => name === oldShortName ? newShortName : name);

            projectData.forEach(item => {
                if (!item.stage) return;
                if (item.stage.startsWith(oldShortName)) {
                    item.stage = newShortName + item.stage.slice(oldShortName.length);
                }
            });

            if (currentStageFilter === oldShortName) {
                currentStageFilter = newShortName;
            }

            await initializeTasks();
            renderStageTabs();
            buildStageSettingsList();
        }

        // Управление масштабом по горизонтали
        function setZoom(level) {
            // clamp от 0.4 до 2.0
            zoomLevel = Math.max(0.4, Math.min(2, level));
            const range = document.getElementById('zoomRange');
            if (range) {
                range.value = Math.round(zoomLevel * 100);
            }

            // Если сильно отдаляемся и ранее был выбран конкретный месяц,
            // сбрасываем "локальный" диапазон и показываем весь проект
            if (zoomLevel <= 1.0 && (viewStartDate || viewEndDate)) {
                viewStartDate = null;
                viewEndDate = null;
            }

            // Перерисовываем только диаграмму Ганта
            if (currentView === 'gantt') {
                renderGantt();
                // Метки этапов не пересчитываются при зуме - они остаются на фиксированных позициях
            }
        }

        function onZoomChange(value) {
            const numeric = Number(value) || 100;
            setZoom(numeric / 100);
        }

        function increaseZoom() {
            // более крупный шаг, чтобы режимы масштаба переключались заметнее
            setZoom(zoomLevel + 0.25);
        }

        function decreaseZoom() {
            // более крупный шаг, чтобы режимы масштаба переключались заметнее
            setZoom(zoomLevel - 0.25);
        }

        // Режим "z + колесо" для зума по диаграмме
        let isZoomKeyPressed = false;

        // Перетаскивание задач (drag & drop)
        let draggingTaskId = null;

        // Открытие/закрытие меню статуса
        function openStatusMenu(x, y, taskId, dateStrs, targetElement = null) {
            // dateStrs может быть массивом дат (для недель/месяцев) или одной датой (для дней)
            const dateArray = Array.isArray(dateStrs) ? dateStrs : [dateStrs];
            currentStatusTarget = { taskId, dateStrs: dateArray };
            
            // Сохраняем координаты для позиционирования модального окна комментария на мобильных
            lastClickCoordinates.x = x;
            lastClickCoordinates.y = y;
            
            const menu = document.getElementById('statusMenu');
            if (!menu) return;
            
            // Для мобильных и планшетов используем улучшенное позиционирование рядом с ячейкой
            const isMobile = window.innerWidth <= 1024;
            
            // Убеждаемся, что меню находится в body (не внутри других элементов с transform)
            if (menu.parentElement !== document.body) {
                document.body.appendChild(menu);
            }
            
            // Сбрасываем все стили позиционирования перед установкой новых
            menu.style.left = '';
            menu.style.top = '';
            menu.style.right = '';
            menu.style.bottom = '';
            menu.style.transform = '';
            menu.style.margin = '0';
            menu.style.padding = '';
            
            // Сначала показываем меню, чтобы получить правильные размеры
            menu.style.display = 'block';
            menu.style.position = 'fixed';
            menu.style.zIndex = '200';
            
            // Получаем размеры меню и позиционируем его
            requestAnimationFrame(() => {
                const menuRect = menu.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Если передан targetElement, используем его координаты вместо координат события
                let referenceX = x;
                let referenceY = y;
                
                if (targetElement) {
                    const targetRect = targetElement.getBoundingClientRect();
                    referenceX = targetRect.right; // Правая граница элемента
                    referenceY = targetRect.top + targetRect.height / 2; // Центр по вертикали
                    console.log('📍 Используем координаты элемента:', {
                        elementRect: { left: targetRect.left, top: targetRect.top, right: targetRect.right, bottom: targetRect.bottom },
                        referenceX,
                        referenceY
                    });
                }
                
                let left = referenceX;
                let top = referenceY;
                
                console.log('📍 Клик на позиции:', { 
                    clickX: x, 
                    clickY: y,
                    referenceX,
                    referenceY,
                    isMobile, 
                    menuWidth: menuRect.width, 
                    menuHeight: menuRect.height,
                    viewport: { width: viewportWidth, height: viewportHeight }
                });
                
                if (isMobile) {
                    // На мобильных и планшетах показываем меню рядом с ячейкой
                    const offset = 15; // чуть больше отступ, чтобы палец не закрывал
                    
                    // Проверяем, влезает ли меню справа от точки клика
                    if (referenceX + menuRect.width + offset > viewportWidth) {
                        // Показываем слева от точки клика
                        left = Math.max(10, referenceX - menuRect.width - offset);
                    } else {
                        left = referenceX + offset;
                    }
                    
                    // Умное позиционирование по вертикали: проверяем, есть ли место снизу
                    const spaceBelow = viewportHeight - referenceY - offset;
                    const spaceAbove = referenceY - offset;
                    
                    if (spaceBelow >= menuRect.height + 10) {
                        // Есть место снизу - показываем меню ниже точки клика
                        top = referenceY + offset;
                    } else if (spaceAbove >= menuRect.height + 10) {
                        // Нет места снизу, но есть место сверху - показываем меню выше точки клика
                        top = referenceY - menuRect.height - offset;
                    } else {
                        // Мало места и снизу, и сверху - позиционируем так, чтобы меню было видно
                        if (spaceBelow > spaceAbove) {
                            // Больше места снизу - показываем снизу, но с учетом границ
                            top = Math.min(referenceY + offset, viewportHeight - menuRect.height - 10);
                        } else {
                            // Больше места сверху - показываем сверху, но с учетом границ
                            top = Math.max(10, referenceY - menuRect.height - offset);
                        }
                    }
                    
                    // Финальная проверка: убеждаемся, что меню не выходит за границы
                    if (top < 10) {
                        top = 10;
                    } else if (top + menuRect.height > viewportHeight - 10) {
                        top = viewportHeight - menuRect.height - 10;
                    }
                    
                    console.log('📱 Мобильная позиция меню:', { left, top, referenceX, referenceY, spaceBelow, spaceAbove });
                } else {
                    // На десктопе позиционируем меню рядом с точкой клика
                    const offset = 5;
                    
                    // Проверяем, влезает ли меню справа
                    if (referenceX + menuRect.width + offset > viewportWidth) {
                        // Показываем слева от точки клика
                        left = Math.max(10, referenceX - menuRect.width - offset);
                    } else {
                        // Показываем справа от точки клика
                        left = referenceX + offset;
                    }
                    
                    // Умное позиционирование по вертикали: проверяем, есть ли место снизу
                    const spaceBelow = viewportHeight - referenceY - offset;
                    const spaceAbove = referenceY - offset;
                    
                    if (spaceBelow >= menuRect.height + 10) {
                        // Есть место снизу - показываем меню ниже точки клика
                        top = referenceY + offset;
                    } else if (spaceAbove >= menuRect.height + 10) {
                        // Нет места снизу, но есть место сверху - показываем меню выше точки клика
                        top = referenceY - menuRect.height - offset;
                    } else {
                        // Мало места и снизу, и сверху - позиционируем так, чтобы меню было видно
                        if (spaceBelow > spaceAbove) {
                            // Больше места снизу - показываем снизу, но с учетом границ
                            top = Math.min(referenceY + offset, viewportHeight - menuRect.height - 10);
                        } else {
                            // Больше места сверху - показываем сверху, но с учетом границ
                            top = Math.max(10, referenceY - menuRect.height - offset);
                        }
                    }
                    
                    // Финальная проверка: убеждаемся, что меню не выходит за границы
                    if (top < 10) {
                        top = 10;
                    } else if (top + menuRect.height > viewportHeight - 10) {
                        top = viewportHeight - menuRect.height - 10;
                    }
                }

                // Устанавливаем позицию
                menu.style.left = `${left}px`;
                menu.style.top = `${top}px`;
                
                // Двойной requestAnimationFrame для гарантии, что стили применены
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const actualRect = menu.getBoundingClientRect();
                        const scrollX = window.scrollX || window.pageXOffset;
                        const scrollY = window.scrollY || window.pageYOffset;
                        
                        // Проверяем, не сдвинулось ли меню
                        const topDiff = Math.abs(actualRect.top - top);
                        const leftDiff = Math.abs(actualRect.left - left);
                        
                        console.log('✅ Финальная позиция меню:', { 
                            left, 
                            top, 
                            menuWidth: menuRect.width, 
                            menuHeight: menuRect.height,
                            actualLeft: actualRect.left,
                            actualTop: actualRect.top,
                            scrollX,
                            scrollY,
                            topDiff,
                            leftDiff,
                            computedLeft: window.getComputedStyle(menu).left,
                            computedTop: window.getComputedStyle(menu).top,
                            computedPosition: window.getComputedStyle(menu).position,
                            parentElement: menu.parentElement ? menu.parentElement.tagName : 'none',
                            parentTransform: menu.parentElement ? window.getComputedStyle(menu.parentElement).transform : 'none'
                        });
                        
                        // Если меню сдвинулось, корректируем позицию
                        if (topDiff > 5 || leftDiff > 5) {
                            console.warn('⚠️ Меню сдвинулось! Ожидалось:', { left, top }, 'Получилось:', { 
                                left: actualRect.left, 
                                top: actualRect.top 
                            });
                            
                            // Корректируем позицию с учетом смещения
                            // Вычисляем разницу и добавляем её к нужной позиции
                            const topOffset = top - actualRect.top;
                            const leftOffset = left - actualRect.left;
                            const correctedTop = top + topOffset;
                            const correctedLeft = left + leftOffset;
                            
                            console.log('🔧 Корректируем позицию:', { 
                                correctedLeft, 
                                correctedTop,
                                topOffset,
                                leftOffset,
                                originalTop: top,
                                actualTop: actualRect.top
                            });
                            menu.style.left = `${correctedLeft}px`;
                            menu.style.top = `${correctedTop}px`;
                            
                            // Проверяем еще раз после коррекции
                            requestAnimationFrame(() => {
                                const finalRect = menu.getBoundingClientRect();
                                const finalTopDiff = Math.abs(finalRect.top - top);
                                const finalLeftDiff = Math.abs(finalRect.left - left);
                                
                                if (finalTopDiff > 5 || finalLeftDiff > 5) {
                                    console.error('❌ Коррекция не помогла! Финальная позиция:', {
                                        expected: { left, top },
                                        actual: { left: finalRect.left, top: finalRect.top }
                                    });
                                    
                                    // Последняя попытка: используем координаты напрямую с учетом прокрутки
                                    const scrollY = window.scrollY || window.pageYOffset;
                                    const scrollX = window.scrollX || window.pageXOffset;
                                    
                                    // Пробуем установить позицию относительно viewport без учета прокрутки
                                    menu.style.position = 'fixed';
                                    menu.style.left = `${left}px`;
                                    menu.style.top = `${top}px`;
                                    menu.style.margin = '0';
                                    menu.style.transform = 'none';
                                    
                                    console.log('🔄 Последняя попытка коррекции:', { left, top, scrollX, scrollY });
                                } else {
                                    console.log('✅ Коррекция успешна!');
                                }
                            });
                        }
                    });
                });
            });
        }

        function closeStatusMenu() {
            const menu = document.getElementById('statusMenu');
            if (menu) {
                menu.style.display = 'none';
            }
            currentStatusTarget = null;
            statusMenuOpenedFromSelect = false;
        }

        // Обновление визуального выделения ячеек
        function updateCellSelection() {
            // Убираем выделение со всех ячеек
            document.querySelectorAll('.gantt-bar.cell-selected').forEach(bar => {
                bar.classList.remove('cell-selected');
            });

            // Добавляем выделение к выбранным ячейкам
            selectedCells.forEach(cellKey => {
                const [taskId, dateStr] = cellKey.split(':');
                // Находим все бары для этой задачи и даты
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;

                const date = parseDateFromInput(dateStr);
                if (!date) return;

                // Находим ячейку с этой датой в строке задачи
                const row = document.querySelector(`.gantt-row[data-task-id="${taskId}"]`);
                if (!row) return;

                // Находим все ячейки в строке и проверяем, содержит ли ячейка эту дату
                const cells = row.querySelectorAll('.gantt-cell');
                cells.forEach(cell => {
                    const cellDates = cell.getAttribute('data-dates');
                    if (cellDates) {
                        try {
                            const dates = JSON.parse(cellDates);
                            if (dates.some(d => {
                                const dDate = new Date(d);
                                return dDate.getTime() === date.getTime();
                            })) {
                                const bar = cell.querySelector('.gantt-bar');
                                if (bar) {
                                    bar.classList.add('cell-selected');
                                }
                            }
                        } catch (e) {
                            // Игнорируем ошибки парсинга
                        }
                    }
                });
            });
        }

        // Открытие меню статуса для множественного выбора
        function openStatusMenuForMultipleSelection(x, y) {
            // Создаем виртуальный target для множественного выбора
            // Собираем все выбранные ячейки
            const allSelectedCells = Array.from(selectedCells).map(cellKey => {
                const [taskId, dateStr] = cellKey.split(':');
                return { taskId, dateStr };
            });

            // Группируем по задачам
            const groupedByTask = {};
            allSelectedCells.forEach(({ taskId, dateStr }) => {
                if (!groupedByTask[taskId]) {
                    groupedByTask[taskId] = [];
                }
                groupedByTask[taskId].push(dateStr);
            });

            // Создаем специальный target для множественного выбора
            currentStatusTarget = {
                isMultiple: true,
                cells: allSelectedCells,
                groupedByTask: groupedByTask
            };

            lastClickCoordinates.x = x;
            lastClickCoordinates.y = y;

            const menu = document.getElementById('statusMenu');
            if (!menu) return;

            // Убеждаемся, что меню находится в body (не внутри других элементов с transform)
            if (menu.parentElement !== document.body) {
                document.body.appendChild(menu);
            }

            // Для мобильных и планшетов используем улучшенное позиционирование рядом с ячейкой
            const isMobile = window.innerWidth <= 1024;
            
            // Сбрасываем все стили позиционирования перед установкой новых
            menu.style.left = '';
            menu.style.top = '';
            menu.style.right = '';
            menu.style.bottom = '';
            menu.style.transform = '';
            menu.style.margin = '0';
            
            menu.style.display = 'block';
            menu.style.position = 'fixed';
            menu.style.zIndex = '200';

            requestAnimationFrame(() => {
                const menuRect = menu.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                let left = x;
                let top = y;

                if (isMobile) {
                    // На мобильных и планшетах показываем меню рядом с точкой тапа
                    const offset = 15; // чуть больше отступ, чтобы палец не закрывал
                    
                    // Проверяем, влезает ли меню справа от точки клика
                    if (x + menuRect.width + offset > viewportWidth) {
                        // Показываем слева от точки клика
                        left = Math.max(10, x - menuRect.width - offset);
                    } else {
                        left = x + offset;
                    }
                    
                    // Умное позиционирование по вертикали: проверяем, есть ли место снизу
                    const spaceBelow = viewportHeight - y - offset;
                    const spaceAbove = y - offset;
                    
                    if (spaceBelow >= menuRect.height + 10) {
                        // Есть место снизу - показываем меню ниже точки клика
                        top = y + offset;
                    } else if (spaceAbove >= menuRect.height + 10) {
                        // Нет места снизу, но есть место сверху - показываем меню выше точки клика
                        top = y - menuRect.height - offset;
                    } else {
                        // Мало места и снизу, и сверху - позиционируем так, чтобы меню было видно
                        if (spaceBelow > spaceAbove) {
                            // Больше места снизу - показываем снизу, но с учетом границ
                            top = Math.min(y + offset, viewportHeight - menuRect.height - 10);
                        } else {
                            // Больше места сверху - показываем сверху, но с учетом границ
                            top = Math.max(10, y - menuRect.height - offset);
                        }
                    }
                    
                    // Финальная проверка: убеждаемся, что меню не выходит за границы
                    if (top < 10) {
                        top = 10;
                    } else if (top + menuRect.height > viewportHeight - 10) {
                        top = viewportHeight - menuRect.height - 10;
                    }
                } else {
                    const offset = 5;
                    // Проверяем, влезает ли меню справа
                    if (x + menuRect.width + offset > viewportWidth) {
                        left = Math.max(10, x - menuRect.width - offset);
                    } else {
                        left = x + offset;
                    }
                    
                    // Умное позиционирование по вертикали: проверяем, есть ли место снизу
                    const spaceBelow = viewportHeight - y - offset;
                    const spaceAbove = y - offset;
                    
                    if (spaceBelow >= menuRect.height + 10) {
                        // Есть место снизу - показываем меню ниже точки клика
                        top = y + offset;
                    } else if (spaceAbove >= menuRect.height + 10) {
                        // Нет места снизу, но есть место сверху - показываем меню выше точки клика
                        top = y - menuRect.height - offset;
                    } else {
                        // Мало места и снизу, и сверху - позиционируем так, чтобы меню было видно
                        if (spaceBelow > spaceAbove) {
                            top = Math.min(y + offset, viewportHeight - menuRect.height - 10);
                        } else {
                            top = Math.max(10, y - menuRect.height - offset);
                        }
                    }
                    
                    // Финальная проверка: убеждаемся, что меню не выходит за границы
                    if (top < 10) {
                        top = 10;
                    } else if (top + menuRect.height > viewportHeight - 10) {
                        top = viewportHeight - menuRect.height - 10;
                    }
                }

                menu.style.left = `${left}px`;
                menu.style.top = `${top}px`;
                
                // Двойной requestAnimationFrame для гарантии, что стили применены
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const actualRect = menu.getBoundingClientRect();
                        const scrollX = window.scrollX || window.pageXOffset;
                        const scrollY = window.scrollY || window.pageYOffset;
                        
                        // Проверяем, не сдвинулось ли меню
                        const topDiff = Math.abs(actualRect.top - top);
                        const leftDiff = Math.abs(actualRect.left - left);
                        
                        console.log('✅ Финальная позиция меню (множественный выбор):', { 
                            left, 
                            top, 
                            menuWidth: menuRect.width, 
                            menuHeight: menuRect.height,
                            actualLeft: actualRect.left,
                            actualTop: actualRect.top,
                            scrollX,
                            scrollY,
                            topDiff,
                            leftDiff,
                            computedLeft: window.getComputedStyle(menu).left,
                            computedTop: window.getComputedStyle(menu).top,
                            computedPosition: window.getComputedStyle(menu).position,
                            parentElement: menu.parentElement ? menu.parentElement.tagName : 'none',
                            parentTransform: menu.parentElement ? window.getComputedStyle(menu.parentElement).transform : 'none'
                        });
                        
                        // Если меню сдвинулось, корректируем позицию
                        if (topDiff > 5 || leftDiff > 5) {
                            console.warn('⚠️ Меню сдвинулось (множественный выбор)! Ожидалось:', { left, top }, 'Получилось:', { 
                                left: actualRect.left, 
                                top: actualRect.top 
                            });
                            
                            // Корректируем позицию с учетом смещения
                            // Вычисляем разницу и добавляем её к нужной позиции
                            const topOffset = top - actualRect.top;
                            const leftOffset = left - actualRect.left;
                            const correctedTop = top + topOffset;
                            const correctedLeft = left + leftOffset;
                            
                            console.log('🔧 Корректируем позицию (множественный выбор):', { 
                                correctedLeft, 
                                correctedTop,
                                topOffset,
                                leftOffset,
                                originalTop: top,
                                actualTop: actualRect.top
                            });
                            menu.style.left = `${correctedLeft}px`;
                            menu.style.top = `${correctedTop}px`;
                            
                            // Проверяем еще раз после коррекции
                            requestAnimationFrame(() => {
                                const finalRect = menu.getBoundingClientRect();
                                const finalTopDiff = Math.abs(finalRect.top - top);
                                const finalLeftDiff = Math.abs(finalRect.left - left);
                                
                                if (finalTopDiff > 5 || finalLeftDiff > 5) {
                                    console.error('❌ Коррекция не помогла (множественный выбор)! Финальная позиция:', {
                                        expected: { left, top },
                                        actual: { left: finalRect.left, top: finalRect.top }
                                    });
                                    
                                    // Последняя попытка: используем координаты напрямую с учетом прокрутки
                                    const scrollY = window.scrollY || window.pageYOffset;
                                    const scrollX = window.scrollX || window.pageXOffset;
                                    
                                    // Пробуем установить позицию относительно viewport без учета прокрутки
                                    menu.style.position = 'fixed';
                                    menu.style.left = `${left}px`;
                                    menu.style.top = `${top}px`;
                                    menu.style.margin = '0';
                                    menu.style.transform = 'none';
                                    
                                    console.log('🔄 Последняя попытка коррекции (множественный выбор):', { left, top, scrollX, scrollY });
                                } else {
                                    console.log('✅ Коррекция успешна (множественный выбор)!');
                                }
                            });
                        }
                    });
                });
            });
        }

        function applyStatusToSelection(status, commentText, targetOverride) {
            const target = targetOverride || currentStatusTarget;
            if (!target) return;

            // Сохраняем состояние в историю перед изменением статуса
            addToUndoHistory();

            // Проверяем, является ли это множественным выбором
            if (target.isMultiple && target.cells) {
                // Обрабатываем множественный выбор
                applyStatusToMultipleCells(status, commentText, target);
                return;
            }

            const { taskId, dateStrs } = target;
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            const task = tasks[taskIndex];
            if (!task) return;

            // Убеждаемся, что у задачи есть объекты для статусов и комментариев по датам
            if (!task.dateStatuses) {
                task.dateStatuses = {};
            }
            if (!task.dateComments) {
                task.dateComments = {};
            }

            // Парсим все даты из массива
            const targetDates = dateStrs.map(ds => {
                const parsed = parseDateFromInput(ds);
                return parsed;
            }).filter(d => d !== null);

            if (targetDates.length === 0) return;

            // Для "завершено" берём последнюю дату из массива (самую позднюю)
            const targetDate = status === 'completed' ? targetDates[targetDates.length - 1] : targetDates[0];

            if (status === 'completed') {
                // 1) Обрезаем задачу по выбранной дате (все позже — выкидываем)
                const newDates = task.dates.filter(d => d <= targetDate);
                if (newDates.length > 0) {
                    task.dates = newDates;
                    task.startDate = newDates[0];
                    task.endDate = newDates[newDates.length - 1];
                    task.days = newDates.length;
                } else {
                    // На всякий случай: если по каким-то причинам ничего не попало —
                    // ставим единственный день завершения
                    task.dates = [targetDate];
                    task.startDate = targetDate;
                    task.endDate = targetDate;
                    task.days = 1;
                }

                // 2) Отмечаем все оставшиеся дни задачи как завершённые
                task.status = 'completed';
                task.dateStatuses = {};
                task.dates.forEach(d => {
                    const ds = formatDateKey(d);
                    task.dateStatuses[ds] = 'completed';
                });

                // 3) Новый комментарий, если введён, привязываем только к целевой дате завершения,
                // не затирая существующие комментарии по другим дням.
                if (commentText && commentText.trim().length > 0) {
                    const completionKey = formatDateKey(targetDate);
                    task.dateComments[completionKey] = commentText.trim();
                }

                // 4) Жёсткая последовательность: подтягиваем все последующие задачи
                recalculateFollowingTasks(taskIndex);
            } else if (status === 'in-progress') {
                // ВАЖНО: Применяем статус только к выбранным датам (не ко всей задаче)
                // Каждая ячейка (день) обрабатывается отдельно
                // Это позволяет краситься только выбранной ячейке, а не всей строке
                targetDates.forEach(d => {
                    const key = formatDateKey(d);
                    task.dateStatuses[key] = 'in-progress';
                    if (commentText && commentText.trim().length > 0) {
                        task.dateComments[key] = commentText.trim();
                    }
                });
                
                // Устанавливаем общий статус задачи только если статус применен ко всем датам задачи
                // или если это единственная дата в задаче
                const allDatesHaveStatus = task.dates.every(d => {
                    const key = formatDateKey(d);
                    return task.dateStatuses[key] === 'in-progress';
                });
                
                // Если статус применен только к одной дате, не меняем общий статус задачи
                // Это позволяет краситься только выбранной ячейке, а не всей строке
                if (allDatesHaveStatus && targetDates.length === task.dates.length) {
                    task.status = 'in-progress';
                } else if (task.dates.length === 1 && targetDates.length === 1) {
                    // Если в задаче только одна дата, устанавливаем общий статус
                    task.status = 'in-progress';
                }
                // В остальных случаях оставляем общий статус как есть (не перекрашиваем всю строку)
            } else if (status === 'pending') {
                // Возврат к статусу "Запланировано"
                // Проверяем, были ли удалены выходные дни (weekend-manual)
                const hadWeekendManual = targetDates.some(d => {
                    const key = formatDateKey(d);
                    return task.dateStatuses && task.dateStatuses[key] === 'weekend-manual';
                });
                
                // Удаляем все статусы для выбранных дат (в работе, завершено, выходной)
                targetDates.forEach(d => {
                    const key = formatDateKey(d);
                    // Удаляем любой статус для этой даты
                    if (task.dateStatuses && task.dateStatuses[key]) {
                        delete task.dateStatuses[key];
                    }
                    // Также удаляем комментарии для этой даты
                    if (task.dateComments && task.dateComments[key]) {
                        delete task.dateComments[key];
                    }
                });
                
                // Если были удалены выходные дни, пересчитываем даты задачи
                // (выходные дни снова становятся рабочими, дата завершения сдвигается назад)
                if (hadWeekendManual) {
                    recalculateTaskDatesWithWeekends(task);
                    // Жёсткая последовательность: подтягиваем все последующие задачи
                    recalculateFollowingTasks(taskIndex);
                }
                
                // Если все даты задачи вернулись к "запланировано", меняем общий статус задачи
                const hasAnyStatus = task.dates && task.dates.some(d => {
                    const key = formatDateKey(d);
                    return task.dateStatuses && task.dateStatuses[key] && 
                           (task.dateStatuses[key] === 'in-progress' || 
                            task.dateStatuses[key] === 'completed' ||
                            task.dateStatuses[key] === 'weekend-manual');
                });
                
                if (!hasAnyStatus) {
                    task.status = 'pending';
                }
            } else if (status === 'weekend-manual') {
                // Применяем статус ко всем датам периода
                targetDates.forEach(d => {
                    const key = formatDateKey(d);
                    task.dateStatuses[key] = 'weekend-manual';
                });
                
                // Пересчитываем даты задачи с учетом выходных дней
                // Дни со статусом "weekend-manual" не считаются рабочими,
                // поэтому дата завершения сдвигается вперед
                recalculateTaskDatesWithWeekends(task);
                
                // Жёсткая последовательность: подтягиваем все последующие задачи
                recalculateFollowingTasks(taskIndex);
            }

            closeStatusMenu();
            
            // Сохраняем текущую позицию прокрутки и активный элемент перед перерисовкой
            const scrollY = window.scrollY || window.pageYOffset;
            const scrollX = window.scrollX || window.pageXOffset;
            const chartContainer = document.getElementById('ganttChart');
            const chartScrollTop = chartContainer ? chartContainer.scrollTop : 0;
            const chartScrollLeft = chartContainer ? chartContainer.scrollLeft : 0;
            
            // Сохраняем активный элемент и убираем фокус, чтобы предотвратить автоматическую прокрутку
            const activeElement = document.activeElement;
            const activeElementInfo = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') 
                ? { element: activeElement, selectionStart: activeElement.selectionStart, selectionEnd: activeElement.selectionEnd }
                : null;
            
            if (activeElementInfo) {
                activeElementInfo.element.blur();
            }

            updateStatistics();
            if (currentView === 'gantt') {
                renderGantt();
            }
            renderTable();
            
            // Восстанавливаем позицию прокрутки сразу, без задержки
            window.scrollTo(scrollX, scrollY);
            const newChartContainer = document.getElementById('ganttChart');
            if (newChartContainer) {
                newChartContainer.scrollTop = chartScrollTop;
                newChartContainer.scrollLeft = chartScrollLeft;
            }
            
            // Восстанавливаем фокус на элемент, если он все еще существует (без прокрутки)
            if (activeElementInfo && document.contains(activeElementInfo.element)) {
                requestAnimationFrame(() => {
                    try {
                        activeElementInfo.element.focus({ preventScroll: true });
                        if (activeElementInfo.element.setSelectionRange && 
                            activeElementInfo.selectionStart !== null && 
                            activeElementInfo.selectionEnd !== null) {
                            activeElementInfo.element.setSelectionRange(
                                activeElementInfo.selectionStart, 
                                activeElementInfo.selectionEnd
                            );
                        }
                    } catch (e) {
                        // Игнорируем ошибки при восстановлении фокуса
                    }
                });
            }
            
            // Немедленное сохранение для критических операций (статусы и комментарии)
            console.log('💾 Критическое изменение: статус/комментарий, сохраняем немедленно');
            saveFullGanttState(); // Сохраняем сразу, без задержки
        }

        // Применение статуса к множественному выбору ячеек
        function applyStatusToMultipleCells(status, commentText, target) {
            if (!target.isMultiple || !target.cells) return;

            // Сохраняем состояние в историю перед изменением статуса
            addToUndoHistory();

            // Собираем затронутые задачи для пересчета дат
            const affectedTaskIndices = new Set();

            // Обрабатываем каждую выбранную ячейку
            target.cells.forEach(({ taskId, dateStr }) => {
                const taskIndex = tasks.findIndex(t => t.id === taskId);
                const task = tasks[taskIndex];
                if (!task) return;

                // Убеждаемся, что у задачи есть объекты для статусов и комментариев
                if (!task.dateStatuses) {
                    task.dateStatuses = {};
                }
                if (!task.dateComments) {
                    task.dateComments = {};
                }

                const date = parseDateFromInput(dateStr);
                if (!date) return;

                const key = formatDateKey(date);

                // Применяем статус в зависимости от типа
                if (status === 'completed') {
                    // Для "завершено" - обрезаем задачу до этой даты
                    const newDates = task.dates.filter(d => d <= date);
                    if (newDates.length > 0) {
                        task.dates = newDates;
                        task.startDate = newDates[0];
                        task.endDate = newDates[newDates.length - 1];
                        task.days = newDates.length;
                    }
                    task.dateStatuses[key] = 'completed';
                    if (commentText && commentText.trim().length > 0) {
                        task.dateComments[key] = commentText.trim();
                    }
                    affectedTaskIndices.add(taskIndex);
                } else if (status === 'in-progress') {
                    task.dateStatuses[key] = 'in-progress';
                    if (commentText && commentText.trim().length > 0) {
                        task.dateComments[key] = commentText.trim();
                    }
                } else if (status === 'pending') {
                    // Проверяем, был ли удален статус "weekend-manual"
                    const hadWeekendManual = task.dateStatuses[key] === 'weekend-manual';
                    
                    // Возврат к "Запланировано"
                    if (task.dateStatuses[key]) {
                        delete task.dateStatuses[key];
                    }
                    if (task.dateComments[key]) {
                        delete task.dateComments[key];
                    }
                    
                    // Если был удален выходной день, нужно пересчитать даты
                    if (hadWeekendManual) {
                        affectedTaskIndices.add(taskIndex);
                    }
                } else if (status === 'weekend-manual') {
                    task.dateStatuses[key] = 'weekend-manual';
                    // Выходные дни требуют пересчета дат
                    affectedTaskIndices.add(taskIndex);
                }
            });

            // Пересчитываем даты для всех затронутых задач
            affectedTaskIndices.forEach(taskIndex => {
                const task = tasks[taskIndex];
                if (task && (status === 'weekend-manual' || status === 'pending')) {
                    recalculateTaskDatesWithWeekends(task);
                }
            });

            // Находим минимальный индекс затронутой задачи для пересчета последующих
            const minAffectedIndex = affectedTaskIndices.size > 0 
                ? Math.min(...Array.from(affectedTaskIndices))
                : -1;
            
            if (minAffectedIndex >= 0) {
                // Пересчитываем все задачи, начиная с минимального затронутого индекса
                recalculateFollowingTasks(minAffectedIndex);
            }

            // Обновляем общие статусы задач
            tasks.forEach(task => {
                if (!task.dateStatuses) return;
                
                const hasInProgressOrCompleted = task.dates.some(d => {
                    const key = formatDateKey(d);
                    return task.dateStatuses[key] === 'in-progress' || 
                           task.dateStatuses[key] === 'completed';
                });
                
                if (!hasInProgressOrCompleted) {
                    task.status = 'pending';
                } else {
                    // Проверяем, все ли даты завершены
                    const allCompleted = task.dates.every(d => {
                        const key = formatDateKey(d);
                        return task.dateStatuses[key] === 'completed';
                    });
                    if (allCompleted) {
                        task.status = 'completed';
                    } else {
                        task.status = 'in-progress';
                    }
                }
            });

            // Пересчитываем последовательность задач
            tasks.forEach((task, index) => {
                if (task.status === 'completed') {
                    recalculateFollowingTasks(index);
                }
            });

            // Очищаем множественный выбор
            selectedCells.clear();
            updateCellSelection();

            closeStatusMenu();
            
            // Сохраняем текущую позицию прокрутки и активный элемент перед перерисовкой
            const scrollY = window.scrollY || window.pageYOffset;
            const scrollX = window.scrollX || window.pageXOffset;
            const chartContainer = document.getElementById('ganttChart');
            const chartScrollTop = chartContainer ? chartContainer.scrollTop : 0;
            const chartScrollLeft = chartContainer ? chartContainer.scrollLeft : 0;
            
            // Сохраняем активный элемент и убираем фокус, чтобы предотвратить автоматическую прокрутку
            const activeElement = document.activeElement;
            const activeElementInfo = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') 
                ? { element: activeElement, selectionStart: activeElement.selectionStart, selectionEnd: activeElement.selectionEnd }
                : null;
            
            if (activeElementInfo) {
                activeElementInfo.element.blur();
            }

            updateStatistics();
            if (currentView === 'gantt') {
                renderGantt();
            }
            renderTable();
            
            // Восстанавливаем позицию прокрутки сразу, без задержки
            window.scrollTo(scrollX, scrollY);
            const newChartContainer = document.getElementById('ganttChart');
            if (newChartContainer) {
                newChartContainer.scrollTop = chartScrollTop;
                newChartContainer.scrollLeft = chartScrollLeft;
            }
            
            // Восстанавливаем фокус на элемент, если он все еще существует (без прокрутки)
            if (activeElementInfo && document.contains(activeElementInfo.element)) {
                requestAnimationFrame(() => {
                    try {
                        activeElementInfo.element.focus({ preventScroll: true });
                        if (activeElementInfo.element.setSelectionRange && 
                            activeElementInfo.selectionStart !== null && 
                            activeElementInfo.selectionEnd !== null) {
                            activeElementInfo.element.setSelectionRange(
                                activeElementInfo.selectionStart, 
                                activeElementInfo.selectionEnd
                            );
                        }
                    } catch (e) {
                        // Игнорируем ошибки при восстановлении фокуса
                    }
                });
            }
            
            // Немедленное сохранение
            console.log('💾 Критическое изменение: множественный статус/комментарий, сохраняем немедленно');
            saveFullGanttState();
        }

        // Обработчики кликов по пунктам меню статуса
        document.addEventListener('DOMContentLoaded', function() {
            const menu = document.getElementById('statusMenu');
            if (menu) {
                menu.querySelectorAll('.status-menu-item').forEach(item => {
                    item.addEventListener('click', (event) => {
                        // Останавливаем всплытие, чтобы window.onclick не закрыл меню до применения статуса
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        
                        const status = item.getAttribute('data-status');
                        const target = currentStatusTarget;
                        
                        // Сбрасываем флаг, так как пользователь выбрал статус
                        statusMenuOpenedFromSelect = false;
                        
                        // Проверяем масштаб отображения - если неделя или месяц, показываем предупреждение
                        if (currentScaleMode === 'week' || currentScaleMode === 'month') {
                            // Показываем предупреждение о масштабе
                            openScaleWarning(status, currentScaleMode);
                            return; // Не применяем статус сразу, ждём подтверждения
                        }
                        
                        // Проверяем, является ли это множественным выбором
                        if (target && target.isMultiple && target.cells) {
                            // Для множественного выбора всегда открываем модальное окно комментария
                            // для статусов "В работе" и "Завершено"
                            if (status === 'in-progress' || status === 'completed') {
                                pendingStatusForComment = status;
                                openStatusCommentModal();
                            } else {
                                // Для других статусов применяем сразу без комментария
                                applyStatusToSelection(status);
                            }
                        } else {
                            // Обычный выбор - как раньше
                            if (status === 'in-progress' || status === 'completed') {
                                pendingStatusForComment = status;
                                openStatusCommentModal();
                            } else {
                                applyStatusToSelection(status);
                            }
                        }
                    });
                });
                
                // Обработчик клика на само меню, чтобы не закрывать его при клике внутри
                menu.addEventListener('click', (event) => {
                    event.stopPropagation();
                });
                
                // Обработчик mousedown на меню, чтобы предотвратить закрытие при нажатии кнопки мыши
                menu.addEventListener('mousedown', (event) => {
                    event.stopPropagation();
                });
            }
        });

        // Закрытие модальных окон, меню статуса
        // и сброс выделения при клике вне основных областей
        window.onclick = function(event) {
            const target = event.target;

            const modal = document.getElementById('editModal');
            if (target === modal) {
                modal.style.display = 'none';
            }

            const menu = document.getElementById('statusMenu');
            if (menu && menu.style.display === 'block' && !menu.contains(target)) {
                // Не закрываем меню, если клик был на select статуса или его родительский элемент
                const isStatusSelect = target.tagName === 'SELECT' && target.getAttribute('data-field') === 'status';
                const isInsideStatusSelect = target.closest('select[data-field="status"]') !== null;
                
                // Также проверяем, не был ли клик на ячейку таблицы, содержащую select статуса
                const isStatusCell = target.closest('td') && target.closest('td').querySelector('select[data-field="status"]');
                
                // Если меню было открыто из select, используем более мягкую логику закрытия
                if (statusMenuOpenedFromSelect) {
                    // Не закрываем меню, если клик был на select или его ячейку
                    if (!isStatusSelect && !isInsideStatusSelect && !isStatusCell) {
                        // Проверяем координаты мыши - если курсор над меню или select, не закрываем
                        const menuRect = menu.getBoundingClientRect();
                        const mouseX = event.clientX;
                        const mouseY = event.clientY;
                        const isOverMenu = mouseX >= menuRect.left && mouseX <= menuRect.right &&
                                          mouseY >= menuRect.top && mouseY <= menuRect.bottom;
                        
                        // Проверяем, не находится ли курсор над select
                        const allStatusSelects = document.querySelectorAll('select[data-field="status"]');
                        let isOverSelect = false;
                        allStatusSelects.forEach(sel => {
                            const selRect = sel.getBoundingClientRect();
                            if (mouseX >= selRect.left && mouseX <= selRect.right &&
                                mouseY >= selRect.top && mouseY <= selRect.bottom) {
                                isOverSelect = true;
                            }
                        });
                        
                        // Закрываем меню только если курсор действительно вне меню и select
                        if (!isOverMenu && !isOverSelect) {
                            closeStatusMenu();
                        }
                    }
                    // Если клик был на select или его ячейку, меню остается открытым
                } else {
                    // Если меню было открыто не из select, закрываем сразу
                    if (!isStatusSelect && !isInsideStatusSelect && !isStatusCell) {
                        closeStatusMenu();
                    }
                }
            }

            // Сброс множественного выбора при клике вне ячеек
            if (selectedCells.size > 0) {
                const isGanttBar = target.closest('.gantt-bar');
                const isStatusMenu = target.closest('.status-menu');
                const isCommentModal = target.closest('#statusCommentModal');
                const isScaleWarningModal = target.closest('#scaleWarningModal');
                
                if (!isGanttBar && !isStatusMenu && !isCommentModal && !isScaleWarningModal) {
                    selectedCells.clear();
                    updateCellSelection();
                }
            }

            const deleteModal = document.getElementById('deleteConfirmModal');
            if (target === deleteModal) {
                cancelDeleteTask();
            }

            const resetPlanModal = document.getElementById('resetPlanConfirmModal');
            if (target === resetPlanModal) {
                cancelResetPlan();
            }


            const scaleWarningModal = document.getElementById('scaleWarningModal');
            if (target === scaleWarningModal) {
                cancelScaleWarning();
            }

            const undoConfirmModal = document.getElementById('undoConfirmModal');
            if (target === undoConfirmModal) {
                cancelUndo();
            }

            const profileModal = document.getElementById('profileModal');
            if (target === profileModal) {
                closeProfileModal();
            }

            const statusCommentModal = document.getElementById('statusCommentModal');
            if (target === statusCommentModal) {
                cancelStatusComment();
            }

            const gantt = document.querySelector('.chart-container');
            const table = document.querySelector('.table-section');

            const insideGantt = gantt && gantt.contains(target);
            const insideTable = table && table.contains(target);
            const insideMenu = menu && menu.contains(target);
            const insideDeleteModal = deleteModal && deleteModal.contains(target);
            const insideResetPlanModal = resetPlanModal && resetPlanModal.contains(target);
            const insideUndoConfirmModal = undoConfirmModal && undoConfirmModal.contains(target);

            // Клик по пустому месту вне диаграммы/таблицы/меню/модалок
            // снимает выделение задач
            if (!insideGantt && !insideTable && !insideMenu && !insideDeleteModal && !insideResetPlanModal && !insideUndoConfirmModal) {
                clearSelection();
            }
        }

        // ========== РЕДАКТИРОВАНИЕ ПРОФИЛЯ ==========
        let currentUser = null;

        // Загрузить данные текущего пользователя
        function loadCurrentUser() {
            const userStr = localStorage.getItem('gantt-user');
            const ganttMode = localStorage.getItem('gantt-mode') || 'edit';
            const isViewMode = ganttMode === 'view';
            
            // В режиме просмотра не загружаем пользователя и не показываем кнопки
            if (isViewMode) {
                return;
            }
            
            if (userStr) {
                try {
                    currentUser = JSON.parse(userStr);
                    // Показываем кнопки профиля, выбора компаний и выхода только для авторизованных пользователей
                    showAuthButtons();
                    
                    // Дополнительная проверка через небольшую задержку
                    setTimeout(() => {
                        const companiesBottomBtn = document.getElementById('companiesBottomBtn');
                        if (companiesBottomBtn) {
                            companiesBottomBtn.style.display = 'flex';
                            companiesBottomBtn.style.visibility = 'visible';
                            companiesBottomBtn.style.opacity = '1';
                            console.log('Нижняя кнопка компаний принудительно показана через loadCurrentUser', {
                                display: companiesBottomBtn.style.display,
                                visibility: companiesBottomBtn.style.visibility,
                                computedDisplay: window.getComputedStyle(companiesBottomBtn).display
                            });
                        } else {
                            console.error('Нижняя кнопка компаний НЕ НАЙДЕНА в loadCurrentUser!');
                        }
                    }, 200);
                } catch (e) {
                    console.error('Ошибка загрузки данных пользователя:', e);
                }
            }
        }


        // Переход на страницу выбора компаний
        function goToCompanies() {
            window.location.href = 'companies.html';
        }

        // Выход из системы
        function logout() {
            // Очищаем данные авторизации из localStorage
            localStorage.removeItem('gantt-user');
            localStorage.removeItem('gantt-mode');
            localStorage.removeItem('gantt-company');
            
            // Перенаправляем на страницу авторизации
            window.location.href = 'auth.html';
        }

        // Перетаскивание модального окна
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let initialPosition = { x: 0, y: 0 };

        function initProfileModalDrag() {
            const modal = document.getElementById('profileModal');
            const modalContent = modal?.querySelector('.profile-modal-content');
            const modalHeader = modal?.querySelector('.profile-modal-header');
            
            if (!modalContent || !modalHeader) return;

            modalHeader.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('profile-modal-close')) {
                    return; // Не перетаскиваем при клике на кнопку закрытия
                }
                
                isDragging = true;
                const rect = modalContent.getBoundingClientRect();
                
                // Вычисляем смещение от точки клика до левого верхнего угла окна
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                // Сохраняем начальную позицию окна
                initialPosition.x = rect.left;
                initialPosition.y = rect.top;
                
                // Переключаем на fixed позиционирование для корректного перетаскивания
                modalContent.style.position = 'fixed';
                modalContent.style.left = rect.left + 'px';
                modalContent.style.top = rect.top + 'px';
                modalContent.style.margin = '0';
                modalContent.style.transition = 'none';
                
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const modalContent = document.querySelector('.profile-modal-content');
                if (!modalContent) return;

                // Вычисляем новую позицию так, чтобы точка клика оставалась под курсором
                let newX = e.clientX - dragOffset.x;
                let newY = e.clientY - dragOffset.y;
                
                // Ограничиваем перемещение границами экрана
                const maxX = window.innerWidth - modalContent.offsetWidth;
                const maxY = window.innerHeight - modalContent.offsetHeight;
                
                newX = Math.max(0, Math.min(newX, maxX));
                newY = Math.max(0, Math.min(newY, maxY));
                
                modalContent.style.left = newX + 'px';
                modalContent.style.top = newY + 'px';
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    const modalContent = document.querySelector('.profile-modal-content');
                    if (modalContent) {
                        // Возвращаем transition для плавных анимаций
                        modalContent.style.transition = '';
                        // Оставляем position: fixed, чтобы окно осталось на месте
                    }
                }
            });
        }

        // Открыть модальное окно профиля
        function openProfileModal() {
            const modal = document.getElementById('profileModal');
            const modalContent = modal?.querySelector('.profile-modal-content');
            const loginInput = document.getElementById('profileLogin');
            if (modal && currentUser && loginInput) {
                loginInput.value = currentUser.login || '';
                document.getElementById('profilePassword').value = '';
                document.getElementById('profilePasswordConfirm').value = '';
                document.getElementById('profileMessage').classList.remove('show');
                
                // Сбрасываем позицию при открытии
                if (modalContent) {
                    modalContent.style.position = '';
                    modalContent.style.left = '';
                    modalContent.style.top = '';
                    modalContent.style.margin = '';
                    modalContent.style.transform = '';
                }
                
                modal.classList.add('show');
            }
        }

        // Закрыть модальное окно профиля
        function closeProfileModal() {
            const modal = document.getElementById('profileModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // Сохранить изменения профиля
        async function saveProfile(event) {
            event.preventDefault();
            
            const loginInput = document.getElementById('profileLogin');
            const passwordInput = document.getElementById('profilePassword');
            const passwordConfirmInput = document.getElementById('profilePasswordConfirm');
            const messageEl = document.getElementById('profileMessage');
            
            const newLogin = loginInput.value.trim();
            const newPassword = passwordInput.value;
            const passwordConfirm = passwordConfirmInput.value;

            // Проверка паролей
            if (newPassword && newPassword !== passwordConfirm) {
                messageEl.textContent = 'Пароли не совпадают';
                messageEl.className = 'profile-message error show';
                return;
            }

            if (newPassword && newPassword.length < 6) {
                messageEl.textContent = 'Пароль должен содержать минимум 6 символов';
                messageEl.className = 'profile-message error show';
                return;
            }

            if (!newLogin) {
                messageEl.textContent = 'Логин не может быть пустым';
                messageEl.className = 'profile-message error show';
                return;
            }

            try {
                const updateData = {
                    oldLogin: currentUser.login,
                    newLogin: newLogin,
                    password: newPassword || null
                };

                const response = await fetch('/api/users/update', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });

                const result = await response.json();

                if (result.ok) {
                    // Обновляем данные пользователя в localStorage
                    currentUser.login = newLogin;
                    localStorage.setItem('gantt-user', JSON.stringify(currentUser));
                    
                    messageEl.textContent = 'Профиль успешно обновлён';
                    messageEl.className = 'profile-message success show';
                    
                    setTimeout(() => {
                        closeProfileModal();
                    }, 1500);
                } else {
                    messageEl.textContent = result.error || 'Ошибка обновления профиля';
                    messageEl.className = 'profile-message error show';
                }
            } catch (error) {
                console.error('Ошибка обновления профиля:', error);
                messageEl.textContent = 'Ошибка подключения к серверу';
                messageEl.className = 'profile-message error show';
            }
        }

        // Проверка доступа пользователя к компании
        async function checkCompanyAccess() {
            if (!currentCompany) {
                // Если компания не указана, разрешаем доступ (для обратной совместимости)
                return true;
            }

            const userStr = localStorage.getItem('gantt-user');
            if (!userStr) {
                // Если пользователь не авторизован, разрешаем доступ (режим просмотра)
                return true;
            }

            try {
                const user = JSON.parse(userStr);
                // Админы имеют доступ ко всем компаниям
                if (user.role === 'admin') {
                    return true;
                }
                // Проверяем, есть ли у пользователя доступ к компании
                const userCompanies = user.companies || [];
                return userCompanies.includes(currentCompany);
            } catch (e) {
                console.error('Ошибка проверки доступа:', e);
                return true; // В случае ошибки разрешаем доступ
            }
        }

        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', async function() {
            // Проверяем доступ к компании перед загрузкой данных
            const hasAccess = await checkCompanyAccess();
            if (!hasAccess && currentCompany) {
                alert('У вас нет доступа к этой компании. Вы будете перенаправлены на страницу авторизации.');
                window.location.href = `auth.html?company=${currentCompany}`;
                return;
            }

            // Сначала загружаем информацию о компании, чтобы узнать тип графика
            await loadCompanyInfo();
            
            // Загружаем скелет графика с сервера (если есть)
            await loadSkeletonFromServer();
            
            // Пытаемся загрузить полное состояние графика
            const fullStateLoaded = await loadFullGanttState();
            if (!fullStateLoaded) {
                // Если полное состояние не загружено, инициализируем задачи по умолчанию
                console.log('🔄 Загрузка не удалась, инициализируем задачи по умолчанию...');
                await initializeTasks();
                // Загружаем baseline для обратной совместимости
                await loadBaselineFromServer();
            }
            // Убеждаемся, что график отрисован
            console.log('📊 Финальное количество задач:', tasks.length);
            if (tasks.length > 0) {
                console.log('✅ Отрисовка графика и таблицы...');
                renderGantt();
                renderTable();
                renderStageTabs();
                
                // Инициализируем lastSavedState после отрисовки (если еще не инициализирован)
                if (!lastSavedState) {
                    const snapshot = createFullGanttSnapshot();
                    lastSavedState = JSON.parse(JSON.stringify(snapshot));
                    console.log('✅ lastSavedState инициализирован после отрисовки графика');
                }
            } else {
                console.error('❌ КРИТИЧЕСКАЯ ОШИБКА: Массив задач пустой после инициализации!');
                console.error('   Проверьте консоль на наличие ошибок выше.');
            }
            // Обновляем состояние кнопки "Директивный план"
            updateBaselineToggleButton();
            loadCurrentUser();
            
            // Загружаем историю отмены действий
            loadUndoHistory();
            
            
            // ПРИНУДИТЕЛЬНО показываем кнопку отмены после загрузки страницы
            setTimeout(() => {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    undoBtn.style.display = 'inline-flex';
                    undoBtn.style.visibility = 'visible';
                    undoBtn.style.opacity = '1';
                    updateUndoButtonState();
                    console.log('✅ Кнопка отмены проверена и показана');
                } else {
                    console.warn('⚠️ Кнопка отмены не найдена!');
                }
            }, 100);
            
            // ПРИНУДИТЕЛЬНО показываем кнопки авторизации после загрузки страницы
            const forceShowAuthButtons = () => {
                const userStr = localStorage.getItem('gantt-user');
                const ganttMode = localStorage.getItem('gantt-mode') || 'edit';
                const isViewMode = ganttMode === 'view';
                
                // В режиме просмотра не показываем кнопки авторизации
                if (isViewMode) {
                    return;
                }
                
                if (userStr) {
                    const profileBtn = document.getElementById('profileBtn');
                    const companiesBottomBtn = document.getElementById('companiesBottomBtn');
                    const logoutBtn = document.getElementById('logoutBtn');
                    
                    console.log('🔍 forceShowAuthButtons:', { 
                        profileBtn: !!profileBtn, 
                        companiesBottomBtn: !!companiesBottomBtn, 
                        logoutBtn: !!logoutBtn 
                    });
                    
                    if (profileBtn) {
                        profileBtn.style.display = 'flex';
                        profileBtn.style.visibility = 'visible';
                        profileBtn.style.opacity = '1';
                    }
                    if (companiesBottomBtn) {
                        companiesBottomBtn.style.display = 'flex';
                        companiesBottomBtn.style.visibility = 'visible';
                        companiesBottomBtn.style.opacity = '1';
                        console.log('✅ Нижняя кнопка компаний ПРИНУДИТЕЛЬНО показана!', {
                            display: companiesBottomBtn.style.display,
                            visibility: companiesBottomBtn.style.visibility,
                            opacity: companiesBottomBtn.style.opacity,
                            computedDisplay: window.getComputedStyle(companiesBottomBtn).display,
                            computedVisibility: window.getComputedStyle(companiesBottomBtn).visibility,
                            position: companiesBottomBtn.getBoundingClientRect()
                        });
                    } else {
                        console.error('❌ Нижняя кнопка компаний НЕ НАЙДЕНА в DOM!');
                    }
                    if (logoutBtn) {
                        logoutBtn.style.display = 'flex';
                        logoutBtn.style.visibility = 'visible';
                        logoutBtn.style.opacity = '1';
                    }
                } else {
                    console.warn('⚠️ Пользователь не авторизован (нет gantt-user в localStorage)');
                }
            };
            
            // Множественные попытки показать кнопки с разными задержками
            forceShowAuthButtons();
            setTimeout(forceShowAuthButtons, 100);
            setTimeout(forceShowAuthButtons, 300);
            setTimeout(forceShowAuthButtons, 500);
            setTimeout(forceShowAuthButtons, 1000);
            setTimeout(forceShowAuthButtons, 2000);
            
            // Обработчики для профиля
            const profileBtn = document.getElementById('profileBtn');
            if (profileBtn) {
                profileBtn.addEventListener('click', openProfileModal);
            }
            
            const profileForm = document.getElementById('profileForm');
            if (profileForm) {
                profileForm.addEventListener('submit', saveProfile);
            }

            // Инициализация перетаскивания модального окна
            initProfileModalDrag();

            // Закрытие модального окна при клике вне его
            const profileModal = document.getElementById('profileModal');
            if (profileModal) {
                profileModal.addEventListener('click', function(e) {
                    if (e.target === profileModal && !isDragging) {
                        closeProfileModal();
                    }
                });
            }

            const chartContainer = document.querySelector('.chart-container');
            const tableSection = document.querySelector('.table-section');
            const stageButtons = document.querySelectorAll('.stage-tab-btn');
            const companyNameDisplay = document.getElementById('companyNameDisplay');
            const companyLogoInput = document.getElementById('companyLogoInput');
            const companyLogoWrapper = document.getElementById('companyLogoWrapper');

            if (companyNameDisplay) {
                // Убираем возможность редактирования названия компании на странице графика
                // Редактирование доступно только через админ-панель или страницу выбора компаний
                companyNameDisplay.contentEditable = 'false';
                companyNameDisplay.style.cursor = 'default';
            }

            // Убираем возможность загрузки логотипа на странице графика
            // Загрузка доступна только через админ-панель или страницу выбора компаний
            if (companyLogoInput) {
                companyLogoInput.style.display = 'none';
            }
            
            if (companyLogoWrapper) {
                companyLogoWrapper.style.cursor = 'default';
            }

            // Инициализируем вкладки этапов на основе текущей конфигурации
            renderStageTabs();

            // Инициализируем подсветку переключателя "Гант / Таблица" и активной панели
            updateViewToggleUI();
            updateViewPanelsUI();
            
            // Блокируем кнопку "Сбросить план" в режиме просмотра
            if (isViewMode) {
                const resetBtn = document.querySelector('.reset-plan-btn');
                if (resetBtn) {
                    resetBtn.classList.add('view-mode-disabled');
                }
            }

            // Отслеживаем нажатие/отжатие клавиши Z (или той же физической клавиши в русской раскладке)
            window.addEventListener('keydown', (event) => {
                // Отслеживание Ctrl/Cmd для мультивыбора
                if (event.ctrlKey || event.metaKey) {
                    isCtrlPressed = true;
                }
                
                // Используем event.code, чтобы сочетание работало и в русской раскладке (KeyZ = Z/Я)
                // Устанавливаем флаг зума только если не зажат Ctrl (Ctrl+Z используется для отмены)
                if (event.code === 'KeyZ' && !(event.ctrlKey || event.metaKey)) {
                    isZoomKeyPressed = true;
                }

                // Вставка новой задачи под выделенной по клавише Insert
                if (event.key === 'Insert') {
                    if (!canEdit()) {
                        return; // Блокируем Insert в режиме просмотра
                    }
                    const target = event.target;
                    // Не перехватываем нажатие, если фокус в инпуте/селекте/редактируемом элементе
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }
                    event.preventDefault();
                    insertTaskBelowSelected();
                    return;
                }

                // Удаление выбранной задачи по клавише Delete (с подтверждением)
                if (event.key === 'Delete') {
                    if (!canEdit()) {
                        return; // Блокируем Delete в режиме просмотра
                    }
                    const target = event.target;
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }
                    event.preventDefault();
                    openDeleteConfirm();
                    return;
                }

                // Отмена последнего действия по Ctrl+Z (англ) или Ctrl+Я (рус)
                // Используем event.code, чтобы сочетание работало и в русской раскладке (KeyZ = Z/Я)
                if ((event.ctrlKey || event.metaKey) && event.code === 'KeyZ' && !event.shiftKey) {
                    const target = event.target;
                    // Не перехватываем нажатие, если фокус в инпуте/textarea/select (стандартная отмена в полях ввода)
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }
                    event.preventDefault();
                    undoLastAction();
                    return;
                }

                // Сохранение директивного (baseline) плана по F2
                if (event.key === 'F2') {
                    const target = event.target;
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }
                    event.preventDefault();

                    // Проверяем режим просмотра
                    if (!canEdit()) {
                        showBaselineToast('В режиме просмотра нельзя задать новый директивный план. Можно только включить отображение существующего.');
                        return;
                    }

                    const newSnapshot = buildBaselineSnapshot();
                    const hasExistingBaseline =
                        baselineSnapshot &&
                        Array.isArray(baselineSnapshot.tasks) &&
                        baselineSnapshot.tasks.some(t => Array.isArray(t.baselineDates) && t.baselineDates.length > 0);

                    console.log('F2 pressed. hasExistingBaseline:', hasExistingBaseline, 'baselineSnapshot:', baselineSnapshot);

                    if (hasExistingBaseline) {
                        openBaselineConfirmModal(newSnapshot);
                    } else {
                        try {
                            baselineSnapshot = newSnapshot;
                            applyBaselineToTasks();
                            saveBaselineToServer(baselineSnapshot);
                            // Сохраняем полное состояние, чтобы baselineSnapshot попал в файл
                            autoSaveGanttState();
                            console.log('Calling showBaselineToast for first time');
                            // Показываем сообщение сразу
                            showBaselineToast('Вы задали базовый план. Нажмите "Директивный план" или F3 для отображения.');
                            // Обновляем состояние кнопки
                            updateBaselineToggleButton();
                        } catch (error) {
                            console.error('Ошибка при сохранении базового плана:', error);
                            // Показываем сообщение даже при ошибке
                            showBaselineToast('Вы задали базовый план. Нажмите "Директивный план" или F3 для отображения.');
                            updateBaselineToggleButton();
                        }
                    }
                    return;
                }

                // Переключение отображения baseline-полосы по F3
                if (event.key === 'F3') {
                    const target = event.target;
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }
                    event.preventDefault();

                    const hasBaseline =
                        baselineSnapshot &&
                        Array.isArray(baselineSnapshot.tasks) &&
                        baselineSnapshot.tasks.some(t => Array.isArray(t.baselineDates) && t.baselineDates.length > 0);

                    if (!hasBaseline) {
                        if (isViewMode) {
                            showBaselineToast('Директивный план не задан. В режиме просмотра можно только включить отображение существующего плана.');
                        } else {
                            showBaselineToast('Базовый план не задан. Нажмите F2, чтобы сохранить текущий график как директивный.');
                        }
                        return;
                    }

                    showBaseline = !showBaseline;
                    updateBaselineToggleButton();
                    renderGantt();
                    return;
                }

                // Если открыто модальное окно предупреждения о масштабе — обрабатываем Escape и Enter
                const scaleWarningModal = document.getElementById('scaleWarningModal');
                if (scaleWarningModal && scaleWarningModal.style.display === 'block') {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        cancelScaleWarning();
                        return;
                    }
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        confirmScaleWarning();
                        return;
                    }
                }
                
                // Если открыто модальное окно комментария к статусу — закрываем по Escape
                const statusCommentModal = document.getElementById('statusCommentModal');
                if (statusCommentModal && (statusCommentModal.style.display === 'flex' || statusCommentModal.style.display === 'block')) {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        cancelStatusComment();
                        return;
                    }
                }

                // Если открыто модальное окно профиля — закрываем по Escape
                const profileModal = document.getElementById('profileModal');
                if (profileModal && profileModal.classList.contains('show')) {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        closeProfileModal();
                        return;
                    }
                }

                // Если открыто окно подтверждения удаления — обрабатываем только его
                if (isDeleteConfirmOpen) {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        cancelDeleteTask();
                        return;
                    }
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        confirmDeleteTask();
                        return;
                    }
                }

                // Если открыто окно подтверждения сброса плана — обрабатываем только его
                const resetPlanModal = document.getElementById('resetPlanConfirmModal');
                if (resetPlanModal && resetPlanModal.style.display === 'block') {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        cancelResetPlan();
                        return;
                    }
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        confirmResetPlan();
                        return;
                    }
                }

                // Если открыто окно подтверждения отмены действия — обрабатываем только его
                const undoConfirmModal = document.getElementById('undoConfirmModal');
                if (undoConfirmModal && undoConfirmModal.style.display === 'block') {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        cancelUndo();
                        return;
                    }
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        confirmUndo();
                        return;
                    }
                }

                // Клавиатурная навигация по задачам (ArrowUp / ArrowDown)
                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    const target = event.target;
                    if (
                        target instanceof HTMLInputElement ||
                        target instanceof HTMLTextAreaElement ||
                        target instanceof HTMLSelectElement ||
                        target.isContentEditable
                    ) {
                        return;
                    }

                    if (!tasks.length) return;

                    event.preventDefault();

                    let currentIndex = -1;
                    const primaryId = getPrimarySelectedTaskId();
                    if (primaryId !== null) {
                        currentIndex = tasks.findIndex(t => t.id === primaryId);
                    }

                    if (currentIndex === -1) {
                        // Если ничего не выбрано — начинаем с первой/последней
                        currentIndex = event.key === 'ArrowDown' ? 0 : tasks.length - 1;
                    } else {
                        if (event.key === 'ArrowDown' && currentIndex < tasks.length - 1) {
                            currentIndex += 1;
                        } else if (event.key === 'ArrowUp' && currentIndex > 0) {
                            currentIndex -= 1;
                        }
                    }

                    const newTask = tasks[currentIndex];
                    if (!newTask) return;

                    // Стрелками всегда выбираем одну задачу (сброс диапазона)
                    selectTask(newTask.id, { range: false });

                    // Скроллим Гант к выбранной строке
                    const row = document.querySelector(`.gantt-row[data-task-id="${newTask.id}"]`);
                    if (row && row.scrollIntoView) {
                        row.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    }
                    return;
                }
            });

            window.addEventListener('keyup', (event) => {
                // Отслеживание Ctrl/Cmd для мультивыбора
                if (!event.ctrlKey && !event.metaKey) {
                    isCtrlPressed = false;
                }
                
                if (event.code === 'KeyZ') {
                    isZoomKeyPressed = false;
                }
            });

            // Колесо мыши над диаграммой: при зажатой Z — зум, при Shift — горизонтальный скролл, иначе обычный скролл
            const ganttChart = document.getElementById('ganttChart');
            if (ganttChart) {
                ganttChart.addEventListener('wheel', (event) => {
                    // Если зажата Z — зум
                    if (isZoomKeyPressed) {
                        event.preventDefault();
                        const direction = event.deltaY > 0 ? -1 : 1; // вниз = отдаление, вверх = приближение
                        const step = 0.1 * direction;
                        setZoom(zoomLevel + step);
                        return;
                    }
                    
                    // Если зажат Shift — горизонтальный скролл
                    if (event.shiftKey) {
                        event.preventDefault();
                        ganttChart.scrollLeft += event.deltaY; // deltaY для горизонтального скролла при Shift
                        return;
                    }
                    
                    // Иначе обычный вертикальный скролл (не блокируем)
                }, { passive: false });
            }

            // Pinch-to-zoom для мобильных устройств и планшетов
            if (chartContainer) {
                let initialDistance = 0;
                let initialZoom = zoomLevel;
                let isPinching = false;
                let lastTouchTime = 0;
                let initialTouchElements = [null, null]; // Сохраняем начальные элементы для проверки
                const touchThrottle = 8; // Уменьшено для более отзывчивой работы (~120fps)

                // Функция для вычисления расстояния между двумя точками касания
                // Работает для любых углов (не зависит от направления)
                function getDistance(touch1, touch2) {
                    const dx = touch2.clientX - touch1.clientX;
                    const dy = touch2.clientY - touch1.clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }

                // Проверка, что touch событие произошло не на ячейке дня (где проставляются статусы)
                function isNotOnDayCell(target) {
                    if (!target) return true;
                    // Проверяем, что элемент не является ячейкой дня или её дочерним элементом
                    const cell = target.closest('.gantt-cell');
                    return !cell; // Возвращаем true, если не нашли ячейку (можно зумить)
                }

                // Проверка, что оба касания находятся вне ячеек дней
                function canZoom(event) {
                    if (event.touches.length !== 2) return false;
                    
                    // Используем сохраненные элементы из touchstart для более надежной проверки
                    if (initialTouchElements[0] && initialTouchElements[1]) {
                        return isNotOnDayCell(initialTouchElements[0]) && isNotOnDayCell(initialTouchElements[1]);
                    }
                    
                    // Fallback: проверяем текущие элементы (для touchmove)
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    
                    // Получаем элементы под точками касания
                    const element1 = document.elementFromPoint(touch1.clientX, touch1.clientY);
                    const element2 = document.elementFromPoint(touch2.clientX, touch2.clientY);
                    
                    // Зумирование разрешено, если оба касания вне ячеек дней
                    return isNotOnDayCell(element1) && isNotOnDayCell(element2);
                }

                chartContainer.addEventListener('touchstart', (event) => {
                    if (event.touches.length === 2) {
                        // Сохраняем начальные элементы для проверки
                        const touch1 = event.touches[0];
                        const touch2 = event.touches[1];
                        initialTouchElements[0] = document.elementFromPoint(touch1.clientX, touch1.clientY);
                        initialTouchElements[1] = document.elementFromPoint(touch2.clientX, touch2.clientY);
                        
                        // Проверяем, что оба касания вне ячеек дней
                        if (canZoom(event)) {
                            event.preventDefault();
                            isPinching = true;
                            initialDistance = getDistance(event.touches[0], event.touches[1]);
                            initialZoom = zoomLevel;
                            lastTouchTime = performance.now();
                        } else {
                            // Если хотя бы одно касание на ячейке дня, не начинаем зум
                            isPinching = false;
                            initialDistance = 0;
                            initialTouchElements = [null, null];
                        }
                    } else if (event.touches.length === 1) {
                        // Сбрасываем состояние, если остался один палец
                        isPinching = false;
                        initialDistance = 0;
                        initialTouchElements = [null, null];
                    }
                }, { passive: false });

                chartContainer.addEventListener('touchmove', (event) => {
                    if (event.touches.length === 2) {
                        // Проверяем, что оба касания все еще вне ячеек дней
                        if (!canZoom(event)) {
                            // Если хотя бы одно касание попало на ячейку дня, прекращаем зум
                            if (isPinching) {
                                isPinching = false;
                                initialDistance = 0;
                                initialTouchElements = [null, null];
                            }
                            return;
                        }
                        
                        event.preventDefault();
                        
                        const now = performance.now();
                        // Throttling для производительности (более частые обновления)
                        if (now - lastTouchTime < touchThrottle && isPinching && initialDistance > 0) {
                            return;
                        }
                        lastTouchTime = now;
                        
                        // Вычисляем текущее расстояние между пальцами
                        const currentDistance = getDistance(event.touches[0], event.touches[1]);
                        
                        // Если это начало жеста или расстояние не было инициализировано
                        if (!isPinching || initialDistance === 0) {
                            // Инициализируем с текущего расстояния (работает для любых расстояний)
                            isPinching = true;
                            initialDistance = currentDistance;
                            initialZoom = zoomLevel;
                            return;
                        }
                        
                        // Вычисляем масштаб на основе изменения расстояния
                        // Работает для любых углов и любых расстояний (коротких и длинных)
                        if (initialDistance > 0 && currentDistance > 0) {
                            const scale = currentDistance / initialDistance;
                            
                            // Применяем масштабирование напрямую (без жестких ограничений)
                            // setZoom уже имеет встроенные ограничения (0.4 - 2.0)
                            const newZoom = initialZoom * scale;
                            setZoom(newZoom);
                        }
                    } else if (event.touches.length === 1 && isPinching) {
                        // Если остался один палец во время жеста, сбрасываем
                        isPinching = false;
                        initialDistance = 0;
                        initialTouchElements = [null, null];
                    }
                }, { passive: false });

                chartContainer.addEventListener('touchend', (event) => {
                    if (event.touches.length < 2) {
                        isPinching = false;
                        initialDistance = 0;
                        initialTouchElements = [null, null];
                    }
                }, { passive: false });

                chartContainer.addEventListener('touchcancel', (event) => {
                    isPinching = false;
                    initialDistance = 0;
                    initialTouchElements = [null, null];
                }, { passive: false });
            }
        });
    </script>
    
    <footer class="footer">
        <p>&copy; 2025 SetlTech. Все права защищены.</p>
    </footer>
</body>
</html>

